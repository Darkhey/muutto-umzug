# Build a subscriptions integration

Create and manage subscriptions to accept recurring payments.

# Stripe-hosted page

> This is a Stripe-hosted page for when platform is web and ui is stripe-hosted. View the original doc at https://docs.stripe.com/billing/subscriptions/build-subscriptions?platform=web&ui=stripe-hosted.

Customize logo, images, and colors.

Use prebuilt hosted forms to collect payments and manage *subscriptions*.

Clone a sample integration [from GitHub](https://github.com/stripe-samples/checkout-single-subscription).

For an immersive version of this guide, see the [Billing integration quickstart](https://docs.stripe.com/billing/quickstart.md).

Explore the [sample on GitHub](https://github.com/stripe-samples/checkout-single-subscription) or the [demo](https://checkout.stripe.dev/).

## What you’ll build 

This guide describes how to sell fixed-price monthly subscriptions using [Stripe Checkout](https://docs.stripe.com/payments/checkout.md).

This guide shows you how to:

- Model your business by building a product catalog
- Add a Checkout session to your site, including a button and success and cancellation pages
- Monitor subscription events and provision access to your service
- Set up the [customer portal](https://docs.stripe.com/customer-management.md)
- Add a customer portal session to your site, including a button and redirect
- Let customers manage their subscription through the portal

If you aren’t ready to code an integration, you can set up basic subscriptions [manually in the Dashboard](https://docs.stripe.com/no-code/subscriptions.md) or use [Payment Links](https://docs.stripe.com/payment-links.md) to set up subscriptions without writing any code.

Learn more about [designing an integration](https://docs.stripe.com/billing/subscriptions/designing-integration.md) to understand the decisions and required resources in a full integration.

After you complete the integration, you can extend it to:

- [Display taxes](https://docs.stripe.com/payments/checkout/taxes.md)
- [Apply discounts](https://docs.stripe.com/billing/subscriptions/coupons.md#using-coupons-in-checkout)
- [Offer customers a free trial period](https://docs.stripe.com/billing/subscriptions/trials.md)
- [Add more payment methods](https://docs.stripe.com/payments/payment-methods/integration-options.md)
- [Integrate the hosted invoice page](https://docs.stripe.com/invoicing/hosted-invoice-page.md)
- [Use Checkout in setup mode](https://docs.stripe.com/payments/save-and-reuse.md)
- [Set up usage-based billing](https://docs.stripe.com/products-prices/pricing-models.md#usage-based-pricing), [pricing tiers](https://docs.stripe.com/products-prices/pricing-models.md#tiered-pricing), and [usage-based pricing](https://docs.stripe.com/products-prices/pricing-models.md#usage-based-pricing)
- [Manage prorations](https://docs.stripe.com/billing/subscriptions/prorations.md)
- [Allow customers to subscribe to multiple products](https://docs.stripe.com/billing/subscriptions/multiple-products.md)
- [Integrate entitlements to manage access to your product’s features](https://docs.stripe.com/billing/entitlements.md)

## Set up Stripe

Install the Stripe client of your choice:

```bash
\# Available as a gem
sudo gem install stripe
```

```ruby
\# If you use bundler, you can add this line to your Gemfile
gem 'stripe'
```

```bash
\# Install through pip
pip3 install --upgrade stripe
```

```bash
\# Or find the Stripe package on http://pypi.python.org/pypi/stripe/
```

```python
\# Find the version you want to pin:
# https://github.com/stripe/stripe-python/blob/master/CHANGELOG.md
# Specify that version in your requirements.txt file
stripe>=5.0.0
```

```bash
\# Install the PHP library with Composer
composer require stripe/stripe-php
```

```bash
\# Or download the source directly: https://github.com/stripe/stripe-php/releases
```

```java
/*
  For Gradle, add the following dependency to your build.gradle and replace with
  the version number you want to use from:
  - https://mvnrepository.com/artifact/com.stripe/stripe-java or
  - https://github.com/stripe/stripe-java/releases/latest
*/
implementation "com.stripe:stripe-java:29.0.0"
```

```xml
<!--
  For Maven, add the following dependency to your POM and replace with the
  version number you want to use from:
  - https://mvnrepository.com/artifact/com.stripe/stripe-java or
  - https://github.com/stripe/stripe-java/releases/latest
-->
<dependency>
  <groupId>com.stripe</groupId>
  <artifactId>stripe-java</artifactId>
  <version>29.0.0</version>
</dependency>
```

```bash
\# For other environments, manually install the following JARs:
# - The Stripe JAR from https://github.com/stripe/stripe-java/releases/latest
# - Google Gson from https://github.com/google/gson
```

```bash
\# Install with npm
npm install stripe --save
```

```bash
\# Make sure your project is using Go Modules
go mod init
# Install stripe-go
go get -u github.com/stripe/stripe-go/v82
```

```go
// Then import the package
import (
  "github.com/stripe/stripe-go/v82"
)
```

```bash
\# Install with dotnet
dotnet add package Stripe.net
dotnet restore
```

```bash
\# Or install with NuGet
Install-Package Stripe.net
```

Install the Stripe CLI (optional). The CLI provides [webhook](https://docs.stripe.com/webhooks.md#test-webhook) testing, and you can run it to create your products and prices.

```bash
\# Install Homebrew to run this command: https://brew.sh/
brew install stripe/stripe-cli/stripe

# Connect the CLI to your dashboard
stripe login
```

```bash
\# 1. Download the latest `mac-os` tar.gz file of your cpu architecture type from https://github.com/stripe/stripe-cli/releases/latest

# 2. Tar the downloaded file
tar -xvf stripe_[X.X.X]_mac-os_[ARCH_TYPE].tar.gz

# Optionally, install the binary in a location where you can execute it globally (for example, `/usr/local/bin`).

# Connect the CLI to your dashboard
stripe login
```

To install the Stripe CLI on Debian and Ubuntu-based distributions:

```bash
brew install stripe/stripe-cli/stripe

# Connect the CLI to your dashboard
stripe login
```

On April 5th, 2024, we changed Stripe CLI’s GPG key to install the Stripe CLI through apt. If you configured the public key before April 5th, you’ll encounter this error:

```
W: An error occurred during the signature verification. The repository is not updated and the previous index files will be used. GPG error: https://packages.stripe.dev/stripe-cli-debian-local stable InRelease: The following signatures were invalid: EXPKEYSIG DEEBD57F917C83E3 Stripe <security@stripe.com>
W: Failed to fetch https://packages.stripe.dev/stripe-cli-debian-local/dists/stable/InRelease  The following signatures were invalid: EXPKEYSIG DEEBD57F917C83E3 Stripe <security@stripe.com>
W: Some index files failed to download. They have been ignored, or old ones used instead
```

To resolve this error, refresh Stripe’s GPG key by following step 1.

To install the Stripe CLI on Debian and Ubuntu-based distributions:

```bash
\# 1. Add Stripe CLI's GPG key to the apt sources keyring:
curl -s https://packages.stripe.dev/api/security/keypair/stripe-cli-gpg/public | gpg --dearmor | sudo tee /usr/share/keyrings/stripe.gpg

# 2. Add CLI's apt repository to the apt sources list:
echo "deb [signed-by=/usr/share/keyrings/stripe.gpg] https://packages.stripe.dev/stripe-cli-debian-local stable main" | sudo tee -a /etc/apt/sources.list.d/stripe.list

# 3. Update the package list
sudo apt update

# 4. Install the CLI
sudo apt install stripe

# 5. Connect the CLI to your dashboard
stripe login
```

```bash
\# 1. Add CLI's yum repository to the yum sources list:
echo -e "[Stripe]\nname=stripe\nbaseurl=https://packages.stripe.dev/stripe-cli-rpm-local/\nenabled=1\ngpgcheck=0" >> /etc/yum.repos.d/stripe.repo

# 2. Install the CLI
sudo yum install stripe
```

```bash
\# Download the latest `linux` tar.gz file from <https://github.com/stripe/stripe-cli/releases/latest>

# Unzip the file:
tar -xvf stripe_X.X.X_linux_x86_64.tar.gz

# Move `./stripe` to your execution path.

# Connect the CLI to your dashboard
stripe login
```

```bash
\# 1. Download the latest `windows` zip file from
# https://github.com/stripe/stripe-cli/releases/latest

# 2. Unzip the `stripe_X.X.X_windows_x86_64.zip` file

# 3. Run the unzipped `.exe` file

# Connect the CLI to your dashboard
stripe login
```

```bash
\# See https://scoop.sh

scoop bucket add stripe https://github.com/stripe/scoop-stripe-cli.git

scoop install stripe
```

For additional install options, see [Get started with the Stripe CLI](https://docs.stripe.com/stripe-cli.md).

## Create the pricing model

## Create a Checkout Session

Add a checkout button to your website that calls a server-side endpoint to create a Checkout Session.

```html
<html>
  <head>
    <title>Checkout</title>
  </head>
  <body>
    <form action="/create-checkout-session" method="POST">
      <!-- Note: If using PHP set the action to /create-checkout-session.php -->

      <input type="hidden" name="priceId" value="price_G0FvDp6vZvdwRZ" />
      <button type="submit">Checkout</button>
    </form>
  </body>
</html>
```

On the backend of your application, define an endpoint that [creates the session](https://docs.stripe.com/api/checkout/sessions/create.md) for your frontend to call. You need these values:

- The price ID of the subscription the customer is signing up for—your frontend passes this value
- Your `success_url`, a page on your website that Checkout returns your customer to after they complete the payment

You can optionally provide `cancel_url`, a page on your website that Checkout returns your customer to if they cancel the payment process. You can also configure a [billing cycle anchor](https://docs.stripe.com/billing/subscriptions/billing-cycle.md) to your subscription in this call.

If you created a one-time price in [step 2](https://docs.stripe.com/billing/subscriptions/build-subscriptions.md#create-pricing-model), pass that price ID as well. After creating a Checkout Session, redirect your customer to the [URL](https://docs.stripe.com/api/checkout/sessions/object.md#checkout_session_object-url) returned in the response.

You can use [lookup_keys](https://docs.stripe.com/products-prices/manage-prices.md#lookup-keys) to fetch prices rather than Price IDs. See the [sample application](https://github.com/stripe-samples/subscription-use-cases/tree/main/fixed-price-subscriptions) for an example.

```ruby
<<setup key>>

# The price ID passed from the front end.
#   price_id = params['priceId']
price_id = '{{PRICE_ID}}'

session = Stripe::Checkout::Session.create({
  success_url: 'https://example.com/success.html?session_id={CHECKOUT_SESSION_ID}',
  cancel_url: 'https://example.com/canceled.html',
  mode: 'subscription',
  line_items: [{
    # For usage-based billing, don't pass quantity
    quantity: 1,
    price: price_id,
  }],
})

# Redirect to the URL returned on the session
#   redirect session.url, 303
```

```python
# The price ID passed from the front end.
#   price_id = request.form.get('priceId')
price_id = '{{PRICE_ID}}'

session = stripe.checkout.Session.create(
  success_url='https://example.com/success.html?session_id={CHECKOUT_SESSION_ID}',
  cancel_url='https://example.com/canceled.html',
  mode='subscription',
  line_items=[{
    'price': price_id,
    # For usage-based billing, don't pass quantity
    'quantity': 1
  }],
)

# Redirect to the URL returned on the session
#   return redirect(session.url, code=303)
```

```php
<<setup key>>

// The price ID passed from the front end.
//   $priceId = $_POST['priceId'];
$priceId = '{{PRICE_ID}}';

$session = \Stripe\Checkout\Session::create([
  'success_url' => 'https://example.com/success.html?session_id={CHECKOUT_SESSION_ID}',
  'cancel_url' => 'https://example.com/canceled.html',
  'mode' => 'subscription',
  'line_items' => [[
    'price' => $priceId,
    // For usage-based billing, don't pass quantity
    'quantity' => 1,
  ]],
]);

// Redirect to the URL returned on the Checkout Session.
// With vanilla PHP, you can redirect with:
//   header("HTTP/1.1 303 See Other");
//   header("Location: " . $session->url);
```

```java
<<setup key>>

// The price ID passed from the client
//   String priceId = request.queryParams("priceId");
String priceId = "{{PRICE_ID}}";

SessionCreateParams params = new SessionCreateParams.Builder()
  .setSuccessUrl("https://example.com/success.html?session_id={CHECKOUT_SESSION_ID}")
  .setCancelUrl("https://example.com/canceled.html")
  .setMode(SessionCreateParams.Mode.SUBSCRIPTION)
  .addLineItem(new SessionCreateParams.LineItem.Builder()
    // For usage-based billing, don't pass quantity
    .setQuantity(1L)
    .setPrice(priceId)
    .build()
  )
  .build();

Session session = Session.create(params);

// Redirect to the URL returned on the Checkout Session.
// With Spark, you can redirect with:
//   response.redirect(session.getUrl(), 303);
//   return "";
```

```javascript
<<setup key>>

// The price ID passed from the client
//   const {priceId} = req.body;
const priceId = '{{PRICE_ID}}';

const session = await stripe.checkout.sessions.create({
  mode: 'subscription',
  line_items: [
    {
      price: priceId,
      // For usage-based billing, don't pass quantity
      quantity: 1,
    },
  ],
  // {CHECKOUT_SESSION_ID} is a string literal; do not change it!
  // the actual Session ID is returned in the query parameter when your customer
  // is redirected to the success page.
  success_url: 'https://example.com/success.html?session_id={CHECKOUT_SESSION_ID}',
  cancel_url: 'https://example.com/canceled.html',
});

// Redirect to the URL returned on the Checkout Session.
// With express, you can redirect with:
//   res.redirect(303, session.url);
```

```go
<<setup key>>

// The price ID passed from the front end
// You can extract the form value with the following:
//   r.ParseForm()
//   priceId, err := strconv.ParseInt(r.PostFormValue("priceId")[0:], 10, 64)
//   if err != nil {
//     http.Error(w, fmt.Sprintf("error parsing quantity %v", err.Error()), http.StatusInternalServerError)
//     return
//   }
priceId := "{{PRICE_ID}}"

params := &stripe.CheckoutSessionParams{
  SuccessURL: "https://example.com/success.html?session_id={CHECKOUT_SESSION_ID}",
  CancelURL: "https://example.com/canceled.html",
  Mode: stripe.String(string(stripe.CheckoutSessionModeSubscription)),
  LineItems: []*stripe.CheckoutSessionLineItemParams{
    &stripe.CheckoutSessionLineItemParams{
      Price:    stripe.String(priceId),
      // For usage-based billing, don't pass quantity
      Quantity: stripe.Int64(1),
    },
  },
}

s, _ := session.New(params)

// Then redirect to the URL on the Checkout Session
//   http.Redirect(w, r, s.URL, http.StatusSeeOther)
```

```dotnet
<<setup key>>

// The price ID passed from the front end.
// You can extract the form value with the following:
//   var priceId = Request.Form["priceId"];
var priceId = "{{PRICE_ID}}";

var options = new SessionCreateOptions
{
  // See https://stripe.com/docs/api/checkout/sessions/create
  // for additional parameters to pass.
  // {CHECKOUT_SESSION_ID} is a string literal; do not change it!
  // the actual Session ID is returned in the query parameter when your customer
  // is redirected to the success page.
  SuccessUrl = "https://example.com/success.html?session_id={CHECKOUT_SESSION_ID}",
  CancelUrl = "https://example.com/canceled.html",
  Mode = "subscription",
  LineItems = new List<SessionLineItemOptions>
  {
    new SessionLineItemOptions
    {
      Price = priceId,
      // For usage-based billing, don't pass quantity
      Quantity = 1,
    },
  },
};

var service = new SessionService();
var session = await service.CreateAsync(options);

// Redirect to the URL returned on the Checkout Session.
//   Response.Headers.Add("Location", session.Url);
//   return new StatusCodeResult(303);
```

This example customizes the `success_url` by appending the Session ID. For more information about this approach, see the documentation on how to [Customize your success page](https://docs.stripe.com/payments/checkout/custom-success-page.md).

From your [Dashboard](https://dashboard.stripe.com/settings/payment_methods), enable the payment methods you want to accept from your customers. Checkout supports [several payment methods](https://docs.stripe.com/payments/payment-methods/payment-method-support.md#product-support).

## Provision and monitor subscriptions

After the subscription signup succeeds, the customer returns to your website at the `success_url`, which initiates a `checkout.session.completed` *webhooks*. When you receive a `checkout.session.completed` event, you can [provision the subscription](https://docs.stripe.com/billing/subscriptions/overview.md#provisioning). Continue to provision each month (if billing monthly) as you receive `invoice.paid` events. If you receive an `invoice.payment_failed` event, notify your customer and send them to the customer portal to update their payment method.

To determine the next step for your system’s logic, check the event type and parse the payload of each [event object](https://docs.stripe.com/api/events/object.md), such as `invoice.paid`. Store the `subscription.id` and `customer.id` event objects in your database for verification.

For testing purposes, you can monitor events in the [Dashboard](https://dashboard.stripe.com/events). For production, set up a webhook endpoint and subscribe to appropriate event types. If you don’t know your `STRIPE_WEBHOOK_SECRET` key, click the [webhook](https://dashboard.stripe.com/webhooks) in the Dashboard to view it.

```ruby
<<setup key>>

post '/webhook' do
  webhook_secret = '{{STRIPE_WEBHOOK_SECRET}}'
  payload = request.body.read
  if !webhook_secret.empty?
    # Retrieve the event by verifying the signature using the raw body and secret if webhook signing is configured.
    sig_header = request.env['HTTP_STRIPE_SIGNATURE']
    event = nil

    begin
      event = Stripe::Webhook.construct_event(
        payload, sig_header, webhook_secret
      )
    rescue JSON::ParserError => e
      # Invalid payload
      status 400
      return
    rescue Stripe::SignatureVerificationError => e
      # Invalid signature
      puts '⚠️  Webhook signature verification failed.'
      status 400
      return
    end
  else
    data = JSON.parse(payload, symbolize_names: true)
    event = Stripe::Event.construct_from(data)
  end
  # Get the type of webhook event sent
  event_type = event['type']
  data = event['data']
  data_object = data['object']

  case event_type
  when 'checkout.session.completed'
    # Payment is successful and the subscription is created.
    # You should provision the subscription and save the customer ID to your database.
  when 'invoice.paid'
    # Continue to provision the subscription as payments continue to be made.
    # Store the status in your database and check when a user accesses your service.
    # This approach helps you avoid hitting rate limits.
  when 'invoice.payment_failed'
    # The payment failed or the customer does not have a valid payment method.
    # The subscription becomes past_due. Notify your customer and send them to the
    # customer portal to update their payment information.
  else
    puts "Unhandled event type: \#{event.type}"
  end

  status 200
end
```

```python
<<setup key>>

@app.route('/webhook', methods=['POST'])
def webhook_received():
  webhook_secret = '{{STRIPE_WEBHOOK_SECRET}}'
  request_data = json.loads(request.data)

  if webhook_secret:
    # Retrieve the event by verifying the signature using the raw body and secret if webhook signing is configured.
    signature = request.headers.get('stripe-signature')
    try:
      event = stripe.Webhook.construct_event(
          payload=request.data, sig_header=signature, secret=webhook_secret)
      data = event['data']
    except Exception as e:
      return e
    # Get the type of webhook event sent - used to check the status of PaymentIntents.
    event_type = event['type']
  else:
    data = request_data['data']
    event_type = request_data['type']
  data_object = data['object']

  if event_type == 'checkout.session.completed':
    # Payment is successful and the subscription is created.
    # You should provision the subscription and save the customer ID to your database.
    print(data)
  elif event_type == 'invoice.paid':
    # Continue to provision the subscription as payments continue to be made.
    # Store the status in your database and check when a user accesses your service.
    # This approach helps you avoid hitting rate limits.
    print(data)
  elif event_type == 'invoice.payment_failed':
    # The payment failed or the customer does not have a valid payment method.
    # The subscription becomes past_due. Notify your customer and send them to the
    # customer portal to update their payment information.
    print(data)
  else:
    print('Unhandled event type {}'.format(event_type))

  return jsonify({'status': 'success'})
```

```php
<<setup key>>

$event = null;
$payload = @file_get_contents('php://input');
$sig_header = $_SERVER['HTTP_STRIPE_SIGNATURE'];
$webhook_secret = '{{STRIPE_WEBHOOK_SECRET}}';

try {
  $event = \Stripe\Webhook::constructEvent(
    $payload, $sig_header, $webhook_secret
  );
} catch(\UnexpectedValueException $e) {
  // Invalid payload
  http_response_code(400);
  exit();
} catch(\Stripe\Exception\SignatureVerificationException $e) {
  // Invalid signature
  http_response_code(400);
  exit();
}

// Handle the event
switch ($event->type) {
  case 'checkout.session.completed':
    // Payment is successful and the subscription is created.
    // You should provision the subscription and save the customer ID to your database.
    break;
  case 'invoice.paid':
    // Continue to provision the subscription as payments continue to be made.
    // Store the status in your database and check when a user accesses your service.
    // This approach helps you avoid hitting rate limits.
    break;
  case 'invoice.payment_failed':
    // The payment failed or the customer does not have a valid payment method.
    // The subscription becomes past_due. Notify your customer and send them to the
    // customer portal to update their payment information.
    break;
  default:
    // Unhandled event type
}

http_response_code(200);
```

```java
<<setup key>>

post("/webhook", (request, response) -> {
  String payload = request.body();
  String sigHeader = request.headers("Stripe-Signature");
  String endpointSecret = "{{STRIPE_WEBHOOK_SECRET}}";

  Event event = null;

  try {
    event = Webhook.constructEvent(payload, sigHeader, endpointSecret);
  } catch (SignatureVerificationException e) {
    // Invalid signature
    response.status(400);
    return "";
  }

  switch (event.getType()) {
    case "checkout.session.completed":
      // Payment is successful and the subscription is created.
      // You should provision the subscription and save the customer ID to your database.
      break;
    case "invoice.paid":
      // Continue to provision the subscription as payments continue to be made.
      // Store the status in your database and check when a user accesses your service.
      // This approach helps you avoid hitting rate limits.
      break;
    case "invoice.payment_failed":
      // The payment failed or the customer does not have a valid payment method.
      // The subscription becomes past_due. Notify your customer and send them to the
      // customer portal to update their payment information.
      break;
    default:
      // System.out.println("Unhandled event type: " + event.getType());
  }

  response.status(200);
  return "";
});
```

```javascript
<<setup key>>

app.post("/webhook", async (req, res) => {
  let data;
  let eventType;
  // Check if webhook signing is configured.
  const webhookSecret = '{{STRIPE_WEBHOOK_SECRET}}';
  if (webhookSecret) {
    // Retrieve the event by verifying the signature using the raw body and secret.
    let event;
    let signature = req.headers["stripe-signature"];

    try {
      event = stripe.webhooks.constructEvent(
        req.body,
        signature,
        webhookSecret
      );
    } catch (err) {
      console.log(`⚠️  Webhook signature verification failed.`);
      return res.sendStatus(400);
    }
    // Extract the object from the event.
    data = event.data;
    eventType = event.type;
  } else {
    // Webhook signing is recommended, but if the secret is not configured in `config.js`,
    // retrieve the event data directly from the request body.
    data = req.body.data;
    eventType = req.body.type;
  }

  switch (eventType) {
    case 'checkout.session.completed':
      // Payment is successful and the subscription is created.
      // You should provision the subscription and save the customer ID to your database.
      break;
    case 'invoice.paid':
      // Continue to provision the subscription as payments continue to be made.
      // Store the status in your database and check when a user accesses your service.
      // This approach helps you avoid hitting rate limits.
      break;
    case 'invoice.payment_failed':
      // The payment failed or the customer does not have a valid payment method.
      // The subscription becomes past_due. Notify your customer and send them to the
      // customer portal to update their payment information.
      break;
    default:
      // Unhandled event type
  }

  res.sendStatus(200);
});
```

```go
<<setup key>>

func handleWebhook(w http.ResponseWriter, r *http.Request) {
  if r.Method != "POST" {
    http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
    return
  }
  b, err := ioutil.ReadAll(r.Body)
  if err != nil {
    http.Error(w, err.Error(), http.StatusBadRequest)
    log.Printf("ioutil.ReadAll: %v", err)
    return
  }

  event, err := webhook.ConstructEvent(b, r.Header.Get("Stripe-Signature"), "{{STRIPE_WEBHOOK_SECRET}}")
  if err != nil {
    http.Error(w, err.Error(), http.StatusBadRequest)
    log.Printf("webhook.ConstructEvent: %v", err)
    return
  }

  switch event.Type {
    case "checkout.session.completed":
      // Payment is successful and the subscription is created.
      // You should provision the subscription and save the customer ID to your database.
    case "invoice.paid":
      // Continue to provision the subscription as payments continue to be made.
      // Store the status in your database and check when a user accesses your service.
      // This approach helps you avoid hitting rate limits.
    case "invoice.payment_failed":
      // The payment failed or the customer does not have a valid payment method.
      // The subscription becomes past_due. Notify your customer and send them to the
      // customer portal to update their payment information.
    default:
      // unhandled event type
  }
}
```

```dotnet
<<setup key>>

[HttpPost("webhook")]
public async Task<IActionResult> Webhook()
{
  var json = await new StreamReader(HttpContext.Request.Body).ReadToEndAsync();
  Event stripeEvent;
  try
  {
    var webhookSecret = "{{STRIPE_WEBHOOK_SECRET}}"
    stripeEvent = EventUtility.ConstructEvent(
      json,
      Request.Headers["Stripe-Signature"],
      webhookSecret
    );
    Console.WriteLine($"Webhook notification with type: {stripeEvent.Type} found for {stripeEvent.Id}");
  }
  catch (Exception e)
  {
    Console.WriteLine($"Something failed {e}");
    return BadRequest();
  }

  switch (stripeEvent.Type) {
    case "checkout.session.completed":
      // Payment is successful and the subscription is created.
      // You should provision the subscription and save the customer ID to your database.
      break;
    case "invoice.paid":
      // Continue to provision the subscription as payments continue to be made.
      // Store the status in your database and check when a user accesses your service.
      // This approach helps you avoid hitting rate limits.
      break;
    case "invoice.payment_failed":
      // The payment failed or the customer does not have a valid payment method.
      // The subscription becomes past_due. Notify your customer and send them to the
      // customer portal to update their payment information.
      break;
    default:
      // Unhandled event type
      break;
  }

  return Ok();
}
```

The minimum event types to monitor:

| Event name                   | Description                                                                                        |
| ---------------------------- | -------------------------------------------------------------------------------------------------- |
| `checkout.session.completed` | Sent when a customer successfully completes the Checkout Session, informing you of a new purchase. |
| `invoice.paid`               | Sent each billing interval when a payment succeeds.                                                |
| `invoice.payment_failed`     | Sent each billing interval if there is an issue with your customer’s payment method.               |

For even more events to monitor, see [Subscription webhooks](https://docs.stripe.com/billing/subscriptions/webhooks.md).

## Configure the customer portal

The [customer portal](https://docs.stripe.com/customer-management.md) lets your customers directly manage their existing subscriptions and invoices.

Use [the Dashboard](https://dashboard.stripe.com/test/settings/billing/portal) to configure the portal. At a minimum, make sure to configure it so that customers can update their payment methods. See [Integrating the customer portal](https://docs.stripe.com/customer-management.md) for information about other settings you can configure.

## Create a portal Session

Define an endpoint that [creates the customer portal session](https://docs.stripe.com/api/customer_portal/sessions/create.md) for your frontend to call. Here `CUSTOMER_ID` refers to the customer ID created by a Checkout Session that you saved while processing the `checkout.session.completed` webhook. You can also set a default redirect link for the portal in the Dashboard.

Pass an optional `return_url` value for the page on your site to redirect your customer to after they finish managing their subscription:

```ruby
<<setup key>>

# This is the URL that users are redirected to after they're done
# managing their billing.
return_url = '{{DOMAIN_URL}}'
customer_id = '{{CUSTOMER_ID}}'

session = Stripe::BillingPortal::Session.create({
  customer: customer_id,
  return_url: return_url,
})

# Redirect to the URL for the session
#   redirect session.url, 303
```

```python
<<setup key>>

# This is the URL that the customer is redirected to after they're
# done managing their billing with the portal.
return_url = '{{DOMAIN_URL}}'
customer_id = '{{CUSTOMER_ID}}'

session = stripe.billing_portal.Session.create(
    customer=customer_id,
    return_url=return_url,
)

# redirect to the URL for the session
#   return redirect(session.url, code=303)
```

```php
<<setup key>>

// This is the URL to which the user will be redirected after they have
// finished managing their billing in the portal.
$return_url = '{{DOMAIN_URL}}';
$stripe_customer_id = '{{CUSTOMER_ID}}';

$session = \Stripe\BillingPortal\Session::create([
  'customer' => $stripe_customer_id,
  'return_url' => $return_url,
]);

// Redirect to the URL for the session
//   header("HTTP/1.1 303 See Other");
//   header("Location: " . $session->url);
```

```java
<<setup key>>

// This is the URL to which the user will be redirected after they have
// finished managing their billing in the portal.
String domainUrl = "{{DOMAIN_URL}}";
String customer = "{{CUSTOMER_ID}}";

com.stripe.param.billingportal.SessionCreateParams params = new com.stripe.param.billingportal.SessionCreateParams.Builder()
    .setReturnUrl(domainUrl)
    .setCustomer(customer)
    .build();
com.stripe.model.billingportal.Session portalSession = com.stripe.model.billingportal.Session.create(params);

// Redirect to the URL for the session
//   response.redirect(portalSession.getUrl(), 303);
//   return "";
```

```javascript
<<setup key>>

// This is the url to which the customer will be redirected when they're done
// managing their billing with the portal.
const returnUrl = '{{DOMAIN_URL}}';
const customerId = '{{CUSTOMER_ID}}';

const portalSession = await stripe.billingPortal.sessions.create({
  customer: customerId,
  return_url: returnUrl,
});

// Redirect to the URL for the session
//   res.redirect(303, portalSession.url);
```

```go
<<setup key>>

// The URL to which the user is redirected when they're done managing
// billing in the portal.
returnURL := "{{DOMAIN_URL}}"
customerID := "{{CUSTOMER_ID}}"

params := &stripe.BillingPortalSessionParams{
  Customer:  stripe.String(customerID),
  ReturnURL: stripe.String(returnURL),
}
ps, _ := portalsession.New(params)

// Redirect to the URL for the session
//   http.Redirect(w, r, ps.URL, http.StatusSeeOther)
```

```dotnet
<<setup key>>

// This is the URL to which your customer will return after
// they're done managing billing in the .
var customerId = '{{CUSTOMER_ID}}',
var returnUrl = '{{DOMAIN_URL}}',

var options = new Stripe.BillingPortal.SessionCreateOptions
{
    Customer = customerId,
    ReturnUrl = returnUrl,
};
var service = new Stripe.BillingPortal.SessionService(this.client);
var session = await service.CreateAsync(options);

// Redirect to the URL for the session
//   Response.Headers.Add("Location", session.Url);
//   return new StatusCodeResult(303);
```

## Send customers to the customer portal

On your frontend, add a button to the page at the `success_url` that provides a link to the customer portal:

```html
<html>
  <head>
    <title>Manage Billing</title>
  </head>
  <body>
    <form action="/customer-portal" method="POST">
      <!-- Note: If using PHP set the action to /customer-portal.php -->
      <button type="submit">Manage Billing</button>
    </form>
  </body>
</html>
```

After exiting the customer portal, the Customer returns to your website at the `return_url`. Continue to [monitor events](https://docs.stripe.com/billing/subscriptions/webhooks.md) to track the state of the Customer’s subscription.

If you configure the customer portal to allow actions such as canceling a subscription, see [Integrating the customer portal](https://docs.stripe.com/customer-management/integrate-customer-portal.md#webhooks) for additional events to monitor.

## Test your integration

### Test payment methods

Use the following table to test different payment methods and scenarios.

| Payment method    | Scenario                                                                                         | How to test                                                                                                                                                                                                  |
| ----------------- | ------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| BECS Direct Debit | Your customer successfully pays with BECS Direct Debit.                                          | Fill out the form using the account number `900123456` and BSB `000-000`. The confirmed PaymentIntent initially transitions to `processing`, then transitions to the `succeeded` status three minutes later. |
| BECS Direct Debit | Your customer’s payment fails with an `account_closed` error code.                               | Fill out the form using the account number `111111113` and BSB `000-000`.                                                                                                                                    |
| Credit card       | The card payment succeeds and doesn’t require authentication.                                    | Fill out the credit card form using the credit card number `4242 4242 4242 4242` with any expiration, CVC, and postal code.                                                                                  |
| Credit card       | The card payment requires *authentication*.                                                      | Fill out the credit card form using the credit card number `4000 0025 0000 3155` with any expiration, CVC, and postal code.                                                                                  |
| Credit card       | The card is declined with a decline code like `insufficient_funds`.                              | Fill out the credit card form using the credit card number `4000 0000 0000 9995` with any expiration, CVC, and postal code.                                                                                  |
| SEPA Direct Debit | Your customer successfully pays with SEPA Direct Debit.                                          | Fill out the form using the account number `AT321904300235473204`. The confirmed PaymentIntent initially transitions to processing, then transitions to the succeeded status three minutes later.            |
| SEPA Direct Debit | Your customer’s PaymentIntent status transitions from `processing` to `requires_payment_method`. | Fill out the form using the account number `AT861904300235473202`.                                                                                                                                           |

### Monitoring events

Set up webhooks to listen to subscription change events, such as upgrades and cancellations. Learn more about [subscription webhooks](https://docs.stripe.com/billing/subscriptions/webhooks.md). You can view events in the [Dashboard](https://dashboard.stripe.com/test/events) or with the [Stripe CLI](https://docs.stripe.com/webhooks.md#test-webhook).

For more details about [testing your Billing integration](https://docs.stripe.com/billing/testing.md), read the guide.

## See Also

- [Offer customers a free trial period](https://docs.stripe.com/billing/subscriptions/trials.md)
- [Apply discounts](https://docs.stripe.com/billing/subscriptions/coupons.md#using-coupons-in-checkout)
- [Manage prorations](https://docs.stripe.com/billing/subscriptions/prorations.md)
- [Integrate entitlements to manage access to your product’s features](https://docs.stripe.com/billing/entitlements.md)

# Embedded form

> This is a Embedded form for when platform is web and ui is embedded-form. View the original doc at https://docs.stripe.com/billing/subscriptions/build-subscriptions?platform=web&ui=embedded-form.

Customize the appearance.

Use prebuilt embedded forms to collect payments and manage *subscriptions*.

## Set up the server

### Set up Stripe

Install the Stripe client of your choice:

```bash
\# Available as a gem
sudo gem install stripe
```

```ruby
\# If you use bundler, you can add this line to your Gemfile
gem 'stripe'
```

```bash
\# Install through pip
pip3 install --upgrade stripe
```

```bash
\# Or find the Stripe package on http://pypi.python.org/pypi/stripe/
```

```python
\# Find the version you want to pin:
# https://github.com/stripe/stripe-python/blob/master/CHANGELOG.md
# Specify that version in your requirements.txt file
stripe>=5.0.0
```

```bash
\# Install the PHP library with Composer
composer require stripe/stripe-php
```

```bash
\# Or download the source directly: https://github.com/stripe/stripe-php/releases
```

```java
/*
  For Gradle, add the following dependency to your build.gradle and replace with
  the version number you want to use from:
  - https://mvnrepository.com/artifact/com.stripe/stripe-java or
  - https://github.com/stripe/stripe-java/releases/latest
*/
implementation "com.stripe:stripe-java:29.0.0"
```

```xml
<!--
  For Maven, add the following dependency to your POM and replace with the
  version number you want to use from:
  - https://mvnrepository.com/artifact/com.stripe/stripe-java or
  - https://github.com/stripe/stripe-java/releases/latest
-->
<dependency>
  <groupId>com.stripe</groupId>
  <artifactId>stripe-java</artifactId>
  <version>29.0.0</version>
</dependency>
```

```bash
\# For other environments, manually install the following JARs:
# - The Stripe JAR from https://github.com/stripe/stripe-java/releases/latest
# - Google Gson from https://github.com/google/gson
```

```bash
\# Install with npm
npm install stripe --save
```

```bash
\# Make sure your project is using Go Modules
go mod init
# Install stripe-go
go get -u github.com/stripe/stripe-go/v82
```

```go
// Then import the package
import (
  "github.com/stripe/stripe-go/v82"
)
```

```bash
\# Install with dotnet
dotnet add package Stripe.net
dotnet restore
```

```bash
\# Or install with NuGet
Install-Package Stripe.net
```

### Create a product and price

If you offer multiple billing intervals, use Checkout to [upsell](https://docs.stripe.com/payments/checkout/upsells.md) customers on longer billing intervals and collect more revenue upfront.

For other pricing models, see [Billing examples](https://docs.stripe.com/products-prices/pricing-models.md).

### Create a Checkout Session

Add an endpoint on your server that creates a *Checkout Session*.

When you create the [Checkout Session](https://docs.stripe.com/api/checkout/sessions/create.md), pass the following parameters:

- To use the embedded Checkout form, set [ui_mode](https://docs.stripe.com/api/checkout/sessions/create.md#create_checkout_session-ui_mode) to `embedded`.
- To create subscriptions when your customer checks out, set [mode](https://docs.stripe.com/api/checkout/sessions/create.md#create_checkout_session-mode) to `subscription`.
- To define the page your customer returns to after completing or attempting payment, specify a [return_url](https://docs.stripe.com/api/checkout/sessions/create.md#create_checkout_session-return_url). Include the `{CHECKOUT_SESSION_ID}` template variable in the URL. Checkout replaces the variable with the Checkout Session ID before redirecting your customer. You create and host the return page on your website.

To mount Checkout, use the Checkout Session’s `client_secret` returned in the response.

```dotnet
StripeConfiguration.ApiKey = "<<secret key>>";

var options = new Stripe.Checkout.SessionCreateOptions
{
    Mode = "subscription",
    LineItems = new List<Stripe.Checkout.SessionLineItemOptions>
    {
        new Stripe.Checkout.SessionLineItemOptions { Price = "<<price>>", Quantity = 1 },
    },
    UiMode = "embedded",
    ReturnUrl = "https://example.com/checkout/return?session_id={CHECKOUT_SESSION_ID}",
};
var service = new Stripe.Checkout.SessionService();
Stripe.Checkout.Session session = service.Create(options);
```

```go
stripe.Key = "<<secret key>>"

params := &stripe.CheckoutSessionParams{
  Mode: stripe.String(string(stripe.CheckoutSessionModeSubscription)),
  LineItems: []*stripe.CheckoutSessionLineItemParams{
    &stripe.CheckoutSessionLineItemParams{
      Price: stripe.String("<<price>>"),
      Quantity: stripe.Int64(1),
    },
  },
  UIMode: stripe.String(string(stripe.CheckoutSessionUIModeEmbedded)),
  ReturnURL: stripe.String("https://example.com/checkout/return?session_id={CHECKOUT_SESSION_ID}"),
};
result, err := session.New(params);
```

```java
Stripe.apiKey = "<<secret key>>";

SessionCreateParams params =
  SessionCreateParams.builder()
    .setMode(SessionCreateParams.Mode.SUBSCRIPTION)
    .addLineItem(
      SessionCreateParams.LineItem.builder().setPrice("<<price>>").setQuantity(1L).build()
    )
    .setUiMode(SessionCreateParams.UiMode.EMBEDDED)
    .setReturnUrl("https://example.com/checkout/return?session_id={CHECKOUT_SESSION_ID}")
    .build();

Session session = Session.create(params);
```

```node
const stripe = require('stripe')('<<secret key>>');

const session = await stripe.checkout.sessions.create({
  mode: 'subscription',
  line_items: [
    {
      price: '<<price>>',
      quantity: 1,
    },
  ],
  ui_mode: 'embedded',
  return_url: 'https://example.com/checkout/return?session_id={CHECKOUT_SESSION_ID}',
});
```

```python
import stripe
stripe.api_key = "<<secret key>>"

session = stripe.checkout.Session.create(
  mode="subscription",
  line_items=[{"price": "<<price>>", "quantity": 1}],
  ui_mode="embedded",
  return_url="https://example.com/checkout/return?session_id={CHECKOUT_SESSION_ID}",
)
```

```php
$stripe = new \Stripe\StripeClient('<<secret key>>');

$session = $stripe->checkout->sessions->create([
  'mode' => 'subscription',
  'line_items' => [
    [
      'price' => '<<price>>',
      'quantity' => 1,
    ],
  ],
  'ui_mode' => 'embedded',
  'return_url' => 'https://example.com/checkout/return?session_id={CHECKOUT_SESSION_ID}',
]);
```

```ruby
Stripe.api_key = '<<secret key>>'

session = Stripe::Checkout::Session.create({
  mode: 'subscription',
  line_items: [
    {
      price: '<<price>>',
      quantity: 1,
    },
  ],
  ui_mode: 'embedded',
  return_url: 'https://example.com/checkout/return?session_id={CHECKOUT_SESSION_ID}',
})
```

## Build your subscription page

### Mount Checkout

#### Load Stripe.js

Use *Stripe.js* to remain *PCI compliant* by ensuring that payment details are sent directly to Stripe without hitting your server. Always load Stripe.js from js.stripe.com to remain compliant. Don’t include the script in a bundle or host it yourself.

#### Define the payment form

To securely collect the customer’s information, create an empty placeholder `div`. Stripe inserts an iframe into the `div`.

Checkout is available as part of [Stripe.js](https://docs.stripe.com/js). Include the Stripe.js script on your page by adding it to the head of your HTML file. Next, create an empty DOM node (container) to use for mounting.

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Accept a payment</title>
    <meta name="description" content="A demo of a payment on Stripe" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="style.css" />
    <!-- Add the Stripe.js script here -->
    <script src="https://js.stripe.com/basil/stripe.js"></script>
    <script src="checkout.js" defer></script>
  </head>
  <body>
    <!-- Display a payment form -->
      <div id="checkout">
        <!-- Checkout inserts the payment form here -->
      </div>
  </body>
</html>
```

#### Initialize Stripe.js

Initialize Stripe.js with your publishable API key.

#### Fetch a Checkout Session client secret

Create an asynchronous `fetchClientSecret` function that makes a request to your server to [create a Checkout Session](https://docs.stripe.com/api/checkout/sessions/create.md) and retrieve the client secret.

#### Initialize Checkout

Initialize Checkout with your `fetchClientSecret` function and mount it to the placeholder `<div>` in your payment form. Checkout is rendered in an iframe that securely sends payment information to Stripe over an HTTPS connection.

Avoid placing Checkout within another iframe because some payment methods require redirecting to another page for payment confirmation.

```javascript
// Initialize Stripe.js

initialize();

// Fetch Checkout Session and retrieve the client secret
async function initialize() {
  const fetchClientSecret = async () => {
    const response = await fetch("/create-checkout-session", {
      method: "POST",
    });
    const { clientSecret } = await response.json();
    return clientSecret;
  };

  // Initialize Checkout
  const checkout = await stripe.initEmbeddedCheckout({
    fetchClientSecret,
  });

  // Mount Checkout
  checkout.mount('#checkout');
}
```

#### Add Stripe to your React app

To stay *PCI compliant* by ensuring that payment details go directly to Stripe and never reach your server, install [React Stripe.js](https://docs.stripe.com/sdks/stripejs-react.md).

#### Load Stripe.js

To configure the Stripe library, call `loadStripe()` with your Stripe publishable API key. Create an `EmbeddedCheckoutProvider`. Pass the returned `Promise` to the provider.

#### Fetch a Checkout Session client secret

Create an asynchronous `fetchClientSecret` function that makes a request to your server to [create a Checkout Session](https://docs.stripe.com/api/checkout/sessions/create.md) and retrieve the client secret.

#### Initialize Checkout

To allow the child components to access the Stripe service through the embedded Checkout consumer, pass the resulting promise from `loadStripe` and the `fetchClientSecret` function as an `option` to the embedded Checkout provider.

```jsx
import * as React from 'react';
import {loadStripe} from '@stripe/stripe-js';
import {
  EmbeddedCheckoutProvider,
  EmbeddedCheckout
} from '@stripe/react-stripe-js';

// Make sure to call `loadStripe` outside of a component’s render to avoid
// recreating the `Stripe` object on every render.
const stripePromise = loadStripe('pk_test_123', {
});

const App = ({fetchClientSecret}) => {
  const options = {fetchClientSecret};

  return (
    <EmbeddedCheckoutProvider
      stripe={stripePromise}
      options={options}
    >
      <EmbeddedCheckout />
    </EmbeddedCheckoutProvider>
  )
}
```

## Show a return page

After your customer attempts payment, Stripe redirects them to a return page that you host on your site. When you created the Checkout Session, you specified the URL of the return page in the [return_url](https://docs.stripe.com/api/checkout/sessions/create.md#create_checkout_session-return_url) parameter.

During payment, some payment methods redirect the customer to an intermediate page, such as a bank authorization page. When they complete that page, Stripe redirects them to your return page.

#### Create an endpoint to retrieve a Checkout Session

Add an endpoint to retrieve a Checkout Session status with the Checkout Session ID in the URL.

#### Retrieve a Checkout Session

To use details for the Checkout session, immediately make a request to the endpoint on your server to [retrieve the Checkout Session](https://docs.stripe.com/api/checkout/sessions/retrieve.md) status using the Checkout Session ID in the URL as soon as your return page loads.

#### Handle the session

Handle the result according to the session status:

- `complete`: The payment succeeded. Use the information from the Checkout Session to render a success page.
- `open`: The payment failed or was canceled. Remount Checkout so that your customer can try again.

```js
// Retrieve a Checkout Session
// Use the session ID
initialize();

async function initialize() {
  const queryString = window.location.search;
  const urlParams = new URLSearchParams(queryString);
  const sessionId = urlParams.get('session_id');
  const response = await fetch(`/session-status?session_id=${sessionId}`);
  const session = await response.json();
// Handle the session according to its status
  if (session.status == 'open') {
    // Remount embedded Checkout
    window.location.replace('http://localhost:4242/checkout.html')
  } else if (session.status == 'complete') {
    document.getElementById('success').classList.remove('hidden');
    document.getElementById('customer-email').textContent = session.customer_email;
    // Show success page
    // Optionally use session.payment_status or session.customer_email
    // to customize the success page
  }
}
```

```javascript
// Add an endpoint to fetch the Checkout Session status
app.get('/session_status', async (req, res) => {
  const session = await stripe.checkout.sessions.retrieve(req.query.session_id);
  const customer = await stripe.customers.retrieve(session.customer);

  res.send({
    status: session.status,
    payment_status: session.payment_status,
    customer_email: customer.email
  });
});
```

## Configure the customer portal

You can set up the *customer portal* to let your customers directly manage their existing subscriptions and invoices.

You can configure the portal in the Dashboard. To reduce churn, you can configure the portal to allow customers to update their payment methods in the case of failed payments.

To help customers find it, add a button on your website to redirect to the customer portal to allow customers to manage their subscription. Clicking this button redirects your customer to the Stripe-hosted customer portal page.

Read more about the [customer portal](https://docs.stripe.com/customer-management.md) and other customer management options.

#### Create a portal session

To add the portal to your customer experience, define an endpoint that [creates the customer portal session](https://docs.stripe.com/api/customer_portal/sessions/create.md) for your frontend to call. Here `CUSTOMER_ID` refers to the customer ID created by a Checkout Session that you saved while processing the `checkout.session.completed` webhook. You can also set a default redirect link for the portal in the Dashboard.

Pass an optional `return_url` value for the page on your site to redirect your customer to after they finish managing their subscription:

```ruby
<<setup key>>

# This is the URL that users are redirected to after they're done
# managing their billing.
return_url = '{{DOMAIN_URL}}'
customer_id = '{{CUSTOMER_ID}}'

session = Stripe::BillingPortal::Session.create({
  customer: customer_id,
  return_url: return_url,
})

# Redirect to the URL for the session
#   redirect session.url, 303
```

```python
<<setup key>>

# This is the URL that the customer is redirected to after they're
# done managing their billing with the portal.
return_url = '{{DOMAIN_URL}}'
customer_id = '{{CUSTOMER_ID}}'

session = stripe.billing_portal.Session.create(
    customer=customer_id,
    return_url=return_url,
)

# redirect to the URL for the session
#   return redirect(session.url, code=303)
```

```php
<<setup key>>

// This is the URL to which the user will be redirected after they have
// finished managing their billing in the portal.
$return_url = '{{DOMAIN_URL}}';
$stripe_customer_id = '{{CUSTOMER_ID}}';

$session = \Stripe\BillingPortal\Session::create([
  'customer' => $stripe_customer_id,
  'return_url' => $return_url,
]);

// Redirect to the URL for the session
//   header("HTTP/1.1 303 See Other");
//   header("Location: " . $session->url);
```

```java
<<setup key>>

// This is the URL to which the user will be redirected after they have
// finished managing their billing in the portal.
String domainUrl = "{{DOMAIN_URL}}";
String customer = "{{CUSTOMER_ID}}";

com.stripe.param.billingportal.SessionCreateParams params = new com.stripe.param.billingportal.SessionCreateParams.Builder()
    .setReturnUrl(domainUrl)
    .setCustomer(customer)
    .build();
com.stripe.model.billingportal.Session portalSession = com.stripe.model.billingportal.Session.create(params);

// Redirect to the URL for the session
//   response.redirect(portalSession.getUrl(), 303);
//   return "";
```

```javascript
<<setup key>>

// This is the url to which the customer will be redirected when they're done
// managing their billing with the portal.
const returnUrl = '{{DOMAIN_URL}}';
const customerId = '{{CUSTOMER_ID}}';

const portalSession = await stripe.billingPortal.sessions.create({
  customer: customerId,
  return_url: returnUrl,
});

// Redirect to the URL for the session
//   res.redirect(303, portalSession.url);
```

```go
<<setup key>>

// The URL to which the user is redirected when they're done managing
// billing in the portal.
returnURL := "{{DOMAIN_URL}}"
customerID := "{{CUSTOMER_ID}}"

params := &stripe.BillingPortalSessionParams{
  Customer:  stripe.String(customerID),
  ReturnURL: stripe.String(returnURL),
}
ps, _ := portalsession.New(params)

// Redirect to the URL for the session
//   http.Redirect(w, r, ps.URL, http.StatusSeeOther)
```

```dotnet
<<setup key>>

// This is the URL to which your customer will return after
// they're done managing billing in the .
var customerId = '{{CUSTOMER_ID}}',
var returnUrl = '{{DOMAIN_URL}}',

var options = new Stripe.BillingPortal.SessionCreateOptions
{
    Customer = customerId,
    ReturnUrl = returnUrl,
};
var service = new Stripe.BillingPortal.SessionService(this.client);
var session = await service.CreateAsync(options);

// Redirect to the URL for the session
//   Response.Headers.Add("Location", session.Url);
//   return new StatusCodeResult(303);
```

#### Send customers to the customer portal

On your frontend, add a button to the page at the `success_url` that provides a link to the customer portal:

```html
<html>
  <head>
    <title>Manage Billing</title>
  </head>
  <body>
    <form action="/customer-portal" method="POST">
      <!-- Note: If using PHP set the action to /customer-portal.php -->
      <button type="submit">Manage Billing</button>
    </form>
  </body>
</html>
```

After exiting the customer portal, the Customer returns to your website at the `return_url`. Continue to [monitor events](https://docs.stripe.com/billing/subscriptions/webhooks.md) to track the state of the Customer’s subscription.

If you configure the customer portal to allow actions such as canceling a subscription, you should monitor [additional events](https://docs.stripe.com/customer-management/integrate-customer-portal.md#webhooks).

## Provision access

Now that the subscription is active, give your user access to your service.  To do this, listen to the `customer.subscription.created`, `customer.subscription.updated`, and `customer.subscription.deleted` events.  These events pass a subscription object that contains a `status` field indicating whether the subscription is active, past due, or canceled.  See [the subscription lifecycle](https://docs.stripe.com/billing/subscriptions/overview.md#subscription-lifecycle) for a complete list of statuses. To learn about managing access to your product’s feature, see the doc on [integrating entitlements](https://docs.stripe.com/billing/entitlements.md).

In your webhook handler:

1. Verify the subscription status.  If it’s `active` then your user has paid for your product.
1. Check the product the customer subscribed to and grant access to your service. Checking the product instead of the price gives you more flexibility if you need to change the pricing or billing interval.
1. Store the `product.id`, `subscription.id` and `subscription.status` in your database along with the `customer.id` you already saved.  Check this record when determining which features to enable for the user in your application.

The state of a subscription might change at any point during its lifetime, even if your application does not directly make any calls to Stripe.  For example, a renewal might fail due to an expired credit card, which puts the subscription into a past due state.  Or, if you implement the [customer portal](https://docs.stripe.com/customer-management.md), a user might cancel their subscription without directly visiting your application.  Implementing your handler correctly keeps your application state in sync with Stripe.

## Test your integration

### Test payment methods

Use the following table to test different payment methods and scenarios.

| Payment method    | Scenario                                                                                         | How to test                                                                                                                                                                                                  |
| ----------------- | ------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| BECS Direct Debit | Your customer successfully pays with BECS Direct Debit.                                          | Fill out the form using the account number `900123456` and BSB `000-000`. The confirmed PaymentIntent initially transitions to `processing`, then transitions to the `succeeded` status three minutes later. |
| BECS Direct Debit | Your customer’s payment fails with an `account_closed` error code.                               | Fill out the form using the account number `111111113` and BSB `000-000`.                                                                                                                                    |
| Credit card       | The card payment succeeds and doesn’t require authentication.                                    | Fill out the credit card form using the credit card number `4242 4242 4242 4242` with any expiration, CVC, and postal code.                                                                                  |
| Credit card       | The card payment requires *authentication*.                                                      | Fill out the credit card form using the credit card number `4000 0025 0000 3155` with any expiration, CVC, and postal code.                                                                                  |
| Credit card       | The card is declined with a decline code like `insufficient_funds`.                              | Fill out the credit card form using the credit card number `4000 0000 0000 9995` with any expiration, CVC, and postal code.                                                                                  |
| SEPA Direct Debit | Your customer successfully pays with SEPA Direct Debit.                                          | Fill out the form using the account number `AT321904300235473204`. The confirmed PaymentIntent initially transitions to processing, then transitions to the succeeded status three minutes later.            |
| SEPA Direct Debit | Your customer’s PaymentIntent status transitions from `processing` to `requires_payment_method`. | Fill out the form using the account number `AT861904300235473202`.                                                                                                                                           |

### Monitoring events

Set up webhooks to listen to subscription change events such as upgrades and cancellations. Learn more about [subscription webhooks](https://docs.stripe.com/billing/subscriptions/webhooks.md). You can view events in the [Dashboard](https://dashboard.stripe.com/test/events) or with the [Stripe CLI](https://docs.stripe.com/webhooks.md#test-webhook).

Learn more about [testing your Billing integration](https://docs.stripe.com/billing/testing.md).

# Custom flow

> This is a Custom flow for when platform is web and ui is elements. View the original doc at https://docs.stripe.com/billing/subscriptions/build-subscriptions?platform=web&ui=elements.

Customize with the [Appearance API](https://docs.stripe.com/elements/appearance-api.md).

Use the [Payment Element](https://docs.stripe.com/payments/payment-element.md) to create a custom payment form that you embed in your application to collect payments.

See the [Embedded components quickstart](https://docs.stripe.com/checkout/custom/quickstart.md) to learn how to use the Checkout API to create and manage your overall payment flow.

We’re developing a Payment Element integration that helps manage subscription features, including free trials, billing cycle anchors, and proration. Learn more about [building a checkout form with embedded components](https://docs.stripe.com/checkout/custom/quickstart.md).

Use this guide to learn how to sell fixed-price *subscriptions*. You’ll use the [Payment Element](https://docs.stripe.com/payments/payment-element.md) to create a custom payment form that you embed in your application.

If you don’t want to build a custom payment form, you can integrate with Checkout. For an immersive version of that end-to-end integration guide, see the Billing [quickstart](https://docs.stripe.com/billing/quickstart.md).

If you aren’t ready to code an integration, you can set up basic subscriptions [manually in the Dashboard](https://docs.stripe.com/no-code/subscriptions.md). You can also use [Payment Links](https://docs.stripe.com/payment-links.md) to set up subscriptions without writing any code. Learn more about [designing an integration](https://docs.stripe.com/billing/subscriptions/designing-integration.md) to understand the decisions you need to make and the resources you need.

## What you’ll build 

This guide shows you how to:

- Model your business by building a product catalog.
- Build a registration process that creates a customer.
- Create subscriptions and collect payment information.
- Test and monitor payment and subscription status.
- Let customers change their plan or cancel the subscription.

## How to model it on Stripe

[Subscriptions](https://docs.stripe.com/api/subscriptions.md) simplify your billing by automatically creating *Invoices* and [PaymentIntents](https://docs.stripe.com/api/payment_intents.md) for you.  To create and activate a subscription, you need to first create a *Product* to model what is being sold, and a *Price* which determines the interval and amount to charge. You also need a [Customer](https://docs.stripe.com/api/customers.md) to store *PaymentMethods* used to make each recurring payment.

### API object definitions

| Resource                                                                      | Definition                                                                                                                                                                                                                                                                                                                                                                                                    |
| ----------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [Entitlement](https://docs.stripe.com/api/entitlements/active-entitlement.md) | Represents a customer’s access to a feature included in a service product that they subscribe to. When you create a subscription for a customer’s recurring purchase of a product, an active entitlement is automatically created for each feature associated with that product. When a customer accesses your services, use their active entitlements to enable the features included in their subscription. |
| [Feature](https://docs.stripe.com/api/entitlements/feature.md)                | Represents a function or ability that your customers can access when they subscribe to a service product. You can include features in a product by creating ProductFeatures.                                                                                                                                                                                                                                  |
| [Invoice](https://docs.stripe.com/api/invoices.md)                            | A statement of amounts a customer owes that tracks payment statuses from draft through paid or otherwise finalized. Subscriptions automatically generate invoices.                                                                                                                                                                                                                                            |
| [PaymentIntent](https://docs.stripe.com/api/payment_intents.md)               | A way to build dynamic payment flows. A PaymentIntent tracks the lifecycle of a customer checkout flow and triggers additional authentication steps when required by regulatory mandates, custom Radar fraud rules, or redirect-based payment methods. Invoices automatically create PaymentIntents.                                                                                                          |
| [PaymentMethod](https://docs.stripe.com/api/payment_methods.md)               | A customer’s payment methods that they use to pay for your products. For example, you can store a credit card on a Customer object and use it to make recurring payments for that customer. Typically used with the Payment Intents or Setup Intents APIs.                                                                                                                                                    |
| [Price](https://docs.stripe.com/api/prices.md)                                | Defines the unit price, currency, and billing cycle for a product.                                                                                                                                                                                                                                                                                                                                            |
| [Product](https://docs.stripe.com/api/products.md)                            | A good or service that your business sells. A service product can include one or more features.                                                                                                                                                                                                                                                                                                               |
| [ProductFeature](https://docs.stripe.com/api/product-feature.md)              | Represents a single feature’s inclusion in a single product. Each product is associated with a ProductFeature for each feature that it includes, and each feature is associated with a ProductFeature for each product that includes it.                                                                                                                                                                      |
| [Subscription](https://docs.stripe.com/api/subscriptions.md)                  | Represents a customer’s scheduled recurring purchase of a product. Use a subscription to collect payments and provide repeated delivery of or continuous access to a product.                                                                                                                                                                                                                                 |

Here’s an example of how products, features, and entitlements work together. Imagine that you want to set up a subscription service that offers two tiers: a standard product with basic functionality, and an advanced product that adds extended functionality.

1. You create two features: `basic_features` and `extended_features`.
1. You create two products: `standard_product` and `advanced_product`.
1. For the standard product, you create one ProductFeature that associates `basic_features` with `standard_product`.
1. For the advanced product, you create two ProductFeatures: one that associates `basic_features` with `advanced_product` and one that associates `extended_features` with `advanced_product`.

A customer, `first_customer`, subscribes to the standard product. When you create the subscription, Stripe automatically creates an Entitlement that associates `first_customer` with `basic_features`.

Another customer, `second_customer`, subscribes to the advanced product. When you create the Subscription, Stripe automatically creates two Entitlements: one that associates `second_customer` with `basic_features`, and one that associates `second_customer` with `extended_features`.

You can determine which features to provision for a customer by [retrieving their active entitlements or listening to the Active Entitlement Summary event](https://docs.stripe.com/billing/entitlements.md#entitlements). You don’t have to retrieve their subscriptions, products, and features.

## Set up Stripe

Install the Stripe client of your choice:

```bash
\# Available as a gem
sudo gem install stripe
```

```ruby
\# If you use bundler, you can add this line to your Gemfile
gem 'stripe'
```

```bash
\# Install through pip
pip3 install --upgrade stripe
```

```bash
\# Or find the Stripe package on http://pypi.python.org/pypi/stripe/
```

```python
\# Find the version you want to pin:
# https://github.com/stripe/stripe-python/blob/master/CHANGELOG.md
# Specify that version in your requirements.txt file
stripe>=5.0.0
```

```bash
\# Install the PHP library with Composer
composer require stripe/stripe-php
```

```bash
\# Or download the source directly: https://github.com/stripe/stripe-php/releases
```

```java
/*
  For Gradle, add the following dependency to your build.gradle and replace with
  the version number you want to use from:
  - https://mvnrepository.com/artifact/com.stripe/stripe-java or
  - https://github.com/stripe/stripe-java/releases/latest
*/
implementation "com.stripe:stripe-java:29.0.0"
```

```xml
<!--
  For Maven, add the following dependency to your POM and replace with the
  version number you want to use from:
  - https://mvnrepository.com/artifact/com.stripe/stripe-java or
  - https://github.com/stripe/stripe-java/releases/latest
-->
<dependency>
  <groupId>com.stripe</groupId>
  <artifactId>stripe-java</artifactId>
  <version>29.0.0</version>
</dependency>
```

```bash
\# For other environments, manually install the following JARs:
# - The Stripe JAR from https://github.com/stripe/stripe-java/releases/latest
# - Google Gson from https://github.com/google/gson
```

```bash
\# Install with npm
npm install stripe --save
```

```bash
\# Make sure your project is using Go Modules
go mod init
# Install stripe-go
go get -u github.com/stripe/stripe-go/v82
```

```go
// Then import the package
import (
  "github.com/stripe/stripe-go/v82"
)
```

```bash
\# Install with dotnet
dotnet add package Stripe.net
dotnet restore
```

```bash
\# Or install with NuGet
Install-Package Stripe.net
```

And then install the Stripe CLI. The CLI provides webhook testing and you can run it to make API calls to Stripe.  This guide shows how to use the CLI to set up a pricing model in a later section.

```bash
\# Install Homebrew to run this command: https://brew.sh/
brew install stripe/stripe-cli/stripe

# Connect the CLI to your dashboard
stripe login
```

```bash
\# 1. Download the latest `mac-os` tar.gz file of your cpu architecture type from https://github.com/stripe/stripe-cli/releases/latest

# 2. Tar the downloaded file
tar -xvf stripe_[X.X.X]_mac-os_[ARCH_TYPE].tar.gz

# Optionally, install the binary in a location where you can execute it globally (for example, `/usr/local/bin`).

# Connect the CLI to your dashboard
stripe login
```

To install the Stripe CLI on Debian and Ubuntu-based distributions:

```bash
brew install stripe/stripe-cli/stripe

# Connect the CLI to your dashboard
stripe login
```

On April 5th, 2024, we changed Stripe CLI’s GPG key to install the Stripe CLI through apt. If you configured the public key before April 5th, you’ll encounter this error:

```
W: An error occurred during the signature verification. The repository is not updated and the previous index files will be used. GPG error: https://packages.stripe.dev/stripe-cli-debian-local stable InRelease: The following signatures were invalid: EXPKEYSIG DEEBD57F917C83E3 Stripe <security@stripe.com>
W: Failed to fetch https://packages.stripe.dev/stripe-cli-debian-local/dists/stable/InRelease  The following signatures were invalid: EXPKEYSIG DEEBD57F917C83E3 Stripe <security@stripe.com>
W: Some index files failed to download. They have been ignored, or old ones used instead
```

To resolve this error, refresh Stripe’s GPG key by following step 1.

To install the Stripe CLI on Debian and Ubuntu-based distributions:

```bash
\# 1. Add Stripe CLI's GPG key to the apt sources keyring:
curl -s https://packages.stripe.dev/api/security/keypair/stripe-cli-gpg/public | gpg --dearmor | sudo tee /usr/share/keyrings/stripe.gpg

# 2. Add CLI's apt repository to the apt sources list:
echo "deb [signed-by=/usr/share/keyrings/stripe.gpg] https://packages.stripe.dev/stripe-cli-debian-local stable main" | sudo tee -a /etc/apt/sources.list.d/stripe.list

# 3. Update the package list
sudo apt update

# 4. Install the CLI
sudo apt install stripe

# 5. Connect the CLI to your dashboard
stripe login
```

```bash
\# 1. Add CLI's yum repository to the yum sources list:
echo -e "[Stripe]\nname=stripe\nbaseurl=https://packages.stripe.dev/stripe-cli-rpm-local/\nenabled=1\ngpgcheck=0" >> /etc/yum.repos.d/stripe.repo

# 2. Install the CLI
sudo yum install stripe
```

```bash
\# Download the latest `linux` tar.gz file from <https://github.com/stripe/stripe-cli/releases/latest>

# Unzip the file:
tar -xvf stripe_X.X.X_linux_x86_64.tar.gz

# Move `./stripe` to your execution path.

# Connect the CLI to your dashboard
stripe login
```

```bash
\# 1. Download the latest `windows` zip file from
# https://github.com/stripe/stripe-cli/releases/latest

# 2. Unzip the `stripe_X.X.X_windows_x86_64.zip` file

# 3. Run the unzipped `.exe` file

# Connect the CLI to your dashboard
stripe login
```

```bash
\# See https://scoop.sh

scoop bucket add stripe https://github.com/stripe/scoop-stripe-cli.git

scoop install stripe
```

For additional install options, see [Get started with the Stripe CLI](https://docs.stripe.com/stripe-cli.md).

## Create the pricing model

## Create the Customer

Stripe needs a *Customer* for each subscription.  In your application frontend, collect any necessary information from your users and pass it to the backend.

If you need to collect address details, the Address Element enables you to collect a shipping or billing address for your customers. For more information on the Address Element, visit the [Address Element](https://docs.stripe.com/elements/address-element.md) page.

```html
<form id="signup-form">
  <label>
    Email
    <input id="email" type="email" placeholder="Email address" value="test@example.com" required />
  </label>

  <button type="submit">
    Register
  </button>
</form>
```

```javascript
const emailInput = document.querySelector('#email');

fetch('/create-customer', {
  method: 'post',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    email: emailInput.value,
  }),
}).then(r => r.json());
```

On the server, create the Stripe Customer object.

```dotnet
StripeConfiguration.ApiKey = "<<secret key>>";

var options = new CustomerCreateOptions
{
    Email = "{{CUSTOMER_EMAIL}}",
    Name = "{{CUSTOMER_NAME}}",
    Shipping = new ShippingOptions
    {
        Address = new AddressOptions
        {
            City = "Brothers",
            Country = "US",
            Line1 = "27 Fredrick Ave",
            PostalCode = "97712",
            State = "CA",
        },
        Name = "{{CUSTOMER_NAME}}",
    },
    Address = new AddressOptions
    {
        City = "Brothers",
        Country = "US",
        Line1 = "27 Fredrick Ave",
        PostalCode = "97712",
        State = "CA",
    },
};
var service = new CustomerService();
Customer customer = service.Create(options);
```

```go
stripe.Key = "<<secret key>>"

params := &stripe.CustomerParams{
  Email: stripe.String("{{CUSTOMER_EMAIL}}"),
  Name: stripe.String("{{CUSTOMER_NAME}}"),
  Shipping: &stripe.CustomerShippingParams{
    Address: &stripe.AddressParams{
      City: stripe.String("Brothers"),
      Country: stripe.String("US"),
      Line1: stripe.String("27 Fredrick Ave"),
      PostalCode: stripe.String("97712"),
      State: stripe.String("CA"),
    },
    Name: stripe.String("{{CUSTOMER_NAME}}"),
  },
  Address: &stripe.AddressParams{
    City: stripe.String("Brothers"),
    Country: stripe.String("US"),
    Line1: stripe.String("27 Fredrick Ave"),
    PostalCode: stripe.String("97712"),
    State: stripe.String("CA"),
  },
};
result, err := customer.New(params);
```

```java
Stripe.apiKey = "<<secret key>>";

CustomerCreateParams params =
  CustomerCreateParams.builder()
    .setEmail("{{CUSTOMER_EMAIL}}")
    .setName("{{CUSTOMER_NAME}}")
    .setShipping(
      CustomerCreateParams.Shipping.builder()
        .setAddress(
          CustomerCreateParams.Shipping.Address.builder()
            .setCity("Brothers")
            .setCountry("US")
            .setLine1("27 Fredrick Ave")
            .setPostalCode("97712")
            .setState("CA")
            .build()
        )
        .setName("{{CUSTOMER_NAME}}")
        .build()
    )
    .setAddress(
      CustomerCreateParams.Address.builder()
        .setCity("Brothers")
        .setCountry("US")
        .setLine1("27 Fredrick Ave")
        .setPostalCode("97712")
        .setState("CA")
        .build()
    )
    .build();

Customer customer = Customer.create(params);
```

```node
const stripe = require('stripe')('<<secret key>>');

const customer = await stripe.customers.create({
  email: '{{CUSTOMER_EMAIL}}',
  name: '{{CUSTOMER_NAME}}',
  shipping: {
    address: {
      city: 'Brothers',
      country: 'US',
      line1: '27 Fredrick Ave',
      postal_code: '97712',
      state: 'CA',
    },
    name: '{{CUSTOMER_NAME}}',
  },
  address: {
    city: 'Brothers',
    country: 'US',
    line1: '27 Fredrick Ave',
    postal_code: '97712',
    state: 'CA',
  },
});
```

```python
import stripe
stripe.api_key = "<<secret key>>"

customer = stripe.Customer.create(
  email="{{CUSTOMER_EMAIL}}",
  name="{{CUSTOMER_NAME}}",
  shipping={
    "address": {
      "city": "Brothers",
      "country": "US",
      "line1": "27 Fredrick Ave",
      "postal_code": "97712",
      "state": "CA",
    },
    "name": "{{CUSTOMER_NAME}}",
  },
  address={
    "city": "Brothers",
    "country": "US",
    "line1": "27 Fredrick Ave",
    "postal_code": "97712",
    "state": "CA",
  },
)
```

```php
$stripe = new \Stripe\StripeClient('<<secret key>>');

$customer = $stripe->customers->create([
  'email' => '{{CUSTOMER_EMAIL}}',
  'name' => '{{CUSTOMER_NAME}}',
  'shipping' => [
    'address' => [
      'city' => 'Brothers',
      'country' => 'US',
      'line1' => '27 Fredrick Ave',
      'postal_code' => '97712',
      'state' => 'CA',
    ],
    'name' => '{{CUSTOMER_NAME}}',
  ],
  'address' => [
    'city' => 'Brothers',
    'country' => 'US',
    'line1' => '27 Fredrick Ave',
    'postal_code' => '97712',
    'state' => 'CA',
  ],
]);
```

```ruby
Stripe.api_key = '<<secret key>>'

customer = Stripe::Customer.create({
  email: '{{CUSTOMER_EMAIL}}',
  name: '{{CUSTOMER_NAME}}',
  shipping: {
    address: {
      city: 'Brothers',
      country: 'US',
      line1: '27 Fredrick Ave',
      postal_code: '97712',
      state: 'CA',
    },
    name: '{{CUSTOMER_NAME}}',
  },
  address: {
    city: 'Brothers',
    country: 'US',
    line1: '27 Fredrick Ave',
    postal_code: '97712',
    state: 'CA',
  },
})
```

## Create the subscription

If you want to render the Payment Element without first creating a subscription, see [Collect payment details before creating an Intent](https://docs.stripe.com/payments/accept-a-payment-deferred.md?type=subscription).

Let your new customer choose a plan and then create the subscription—in this guide, they choose between Basic and Premium.

On the frontend, pass the selected price ID and the ID of the customer record to the backend.

```javascript
fetch('/create-subscription', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    priceId: priceId,
    customerId: customerId,
  }),
})
```

On the backend, create the subscription with status `incomplete` using `payment_behavior=default_incomplete`. Then, return the `client_secret` from the subscription’s first [payment intent](https://docs.stripe.com/payments/payment-intents.md) to the frontend to complete payment by expanding the [`confirmation_secret`](https://docs.stripe.com/api/invoices/object.md#invoice_object-confirmation_secret) on the latest invoice of the subscription.

Set [save_default_payment_method](https://docs.stripe.com/api/subscriptions/object.md#subscription_object-payment_settings-save_default_payment_method) to `on_subscription` to save the payment method as the default for a subscription when a payment succeeds. Saving a default payment method increases the success rate of future subscription payments.

```ruby
<<setup key>>

post '/create-subscription' do
  content_type 'application/json'
  data = JSON.parse(request.body.read)
  customer_id = cookies[:customer]
  price_id = data['priceId']

  # Create the subscription. Note we're expanding the Subscription's
  # latest invoice and that invoice's confirmation_secret
  # so we can pass it to the front end to confirm the payment
  subscription = Stripe::Subscription.create(
    customer: customer_id,
    items: [{
      price: price_id,
    }],
    payment_behavior: 'default_incomplete',
    payment_settings: {save_default_payment_method: 'on_subscription'},
    expand: ['latest_invoice.confirmation_secret']
  )

  { subscriptionId: subscription.id, clientSecret: subscription.latest_invoice.confirmation_secret.client_secret }.to_json
end
```

```python
<<setup key>>

@app.route('/create-subscription', methods=['POST'])
def create_subscription():
    data = json.loads(request.data)
    customer_id = data['customerId']
    price_id = data['priceId']

    try:
        # Create the subscription. Note we're expanding the Subscription's
        # latest invoice and that invoice's confirmation_secret
        # so we can pass it to the front end to confirm the payment
        subscription = stripe.Subscription.create(
            customer=customer_id,
            items=[{
                'price': price_id,
            }],
            payment_behavior='default_incomplete',
            payment_settings={'save_default_payment_method': 'on_subscription'},
            expand=['latest_invoice.confirmation_secret'],
        )
        return jsonify(subscriptionId=subscription.id, clientSecret=subscription.latest_invoice.confirmation_secret.client_secret)

    except Exception as e:
        return jsonify(error={'message': e.user_message}), 400
```

```php
<<setup key>>

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    // Get the request body and decode it as JSON.
    $body = file_get_contents('php://input');
    $json = json_decode($body);

    // Get the customer ID from the cookie and the price ID from the JSON data.
    $customer_id = $_COOKIE['customer'];
    $price_id = $json->priceId;

    // Create the subscription with the customer ID, price ID, and necessary options.
    $subscription = $stripe->subscriptions->create([
        'customer' => $customer_id,
        'items' => [[
            'price' => $price_id,
        ]],
        'payment_behavior' => 'default_incomplete',
        'payment_settings' => ['save_default_payment_method' => 'on_subscription'],
        'expand' => ['latest_invoice.confirmation_secret'],
    ]);

    // Return the subscription ID and client secret as a JSON response.
    header('Content-Type: application/json');
    echo json_encode([
        'subscriptionId' => $subscription->id,
        'clientSecret' => $subscription->latest_invoice->confirmation_secret->client_secret,
    ]);
}
```

```java
<<setup key>>

post(
  "/create-subscription",
  (request, response) -> {
    response.type("application/json");
    String customerId = request.cookie("customer");
    CreateSubscriptionRequest postBody = gson.fromJson(
      request.body(),
      CreateSubscriptionRequest.class
    );
    String priceId = postBody.getPriceId();

    // Automatically save the payment method to the subscription
    // when the first payment is successful.
    SubscriptionCreateParams.PaymentSettings paymentSettings =
      SubscriptionCreateParams.PaymentSettings
        .builder()
        .setSaveDefaultPaymentMethod(SaveDefaultPaymentMethod.ON_SUBSCRIPTION)
        .build();

    // Create the subscription. Note we're expanding the Subscription's
    // latest invoice and that invoice's confirmation_secret
    // so we can pass it to the front end to confirm the payment
    SubscriptionCreateParams subCreateParams = SubscriptionCreateParams
      .builder()
      .setCustomer(customerId)
      .addItem(
        SubscriptionCreateParams
          .Item.builder()
          .setPrice(priceId)
          .build()
      )
      .setPaymentSettings(paymentSettings)
      .setPaymentBehavior(SubscriptionCreateParams.PaymentBehavior.DEFAULT_INCOMPLETE)
      .addAllExpand(Arrays.asList("latest_invoice.confirmation_secret"))
      .build();

    Subscription subscription = Subscription.create(subCreateParams);

    Map<String, Object> responseData = new HashMap<>();
    responseData.put("subscriptionId", subscription.getId());
    responseData.put("clientSecret", subscription.getLatestInvoiceObject().getConfirmationSecret().getClientSecret());
    return StripeObject.PRETTY_PRINT_GSON.toJson(responseData);
  }
);
```

```javascript
<<setup key>>

app.post('/create-subscription', async (req, res) => {
  const customerId = req.cookies['customer'];
  const priceId = req.body.priceId;

  try {
    // Create the subscription. Note we're expanding the Subscription's
    // latest invoice and that invoice's confirmation_secret
    // so we can pass it to the front end to confirm the payment
    const subscription = await stripe.subscriptions.create({
      customer: customerId,
      items: [{
        price: priceId,
      }],
      payment_behavior: 'default_incomplete',
      payment_settings: { save_default_payment_method: 'on_subscription' },
      expand: ['latest_invoice.confirmation_secret'],
    });

    res.send({
      subscriptionId: subscription.id,
      clientSecret: subscription.latest_invoice.confirmation_secret.client_secret,
    });
  } catch (error) {
    return res.status(400).send({ error: { message: error.message } });
  }
});
```

```go
<<setup key>>

func handleCreateSubscription(w http.ResponseWriter, r *http.Request) {
    if r.Method != "POST" {
        http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
        return
    }

    var req struct {
        PriceID string `json:"priceId"`
    }

    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        writeJSON(w, nil, err)
        log.Printf("json.NewDecoder.Decode: %v", err)
        return
    }

    cookie, _ := r.Cookie("customer")
    customerID := cookie.Value

    // Automatically save the payment method to the subscription
    // when the first payment is successful.
    paymentSettings := &stripe.SubscriptionPaymentSettingsParams{
		    SaveDefaultPaymentMethod: stripe.String("on_subscription"),
  	}

    // Create the subscription. Note we're expanding the Subscription's
    // latest invoice and that invoice's confirmation_secret
    // so we can pass it to the front end to confirm the payment
    subscriptionParams := &stripe.SubscriptionParams{
        Customer: stripe.String(customerID),
        Items: []*stripe.SubscriptionItemsParams{
            {
                Price: stripe.String(req.PriceID),
            },
        },
        PaymentSettings: paymentSettings,
        PaymentBehavior: stripe.String("default_incomplete"),
    }
    subscriptionParams.AddExpand("latest_invoice.confirmation_secret")
    s, err := subscription.New(subscriptionParams)

    if err != nil {
        writeJSON(w, nil, err)
        log.Printf("subscription.New: %v", err)
        return
    }

    writeJSON(w, struct {
        SubscriptionID string `json:"subscriptionId"`
        ClientSecret string `json:"clientSecret"`
    }{
        SubscriptionID: s.ID,
        ClientSecret: s.LatestInvoice.ConfirmationSecret.ClientSecret,
    }, nil)
}
```

```dotnet
<<setup key>>

[HttpPost("create-subscription")]
public ActionResult<SubscriptionCreateResponse> CreateSubscription([FromBody] CreateSubscriptionRequest req)
{
    var customerId = HttpContext.Request.Cookies["customer"];

    // Automatically save the payment method to the subscription
    // when the first payment is successful.
    var paymentSettings = new SubscriptionPaymentSettingsOptions {
        SaveDefaultPaymentMethod = "on_subscription",
    };

    // Create the subscription. Note we're expanding the Subscription's
    // latest invoice and that invoice's confirmation_secret
    // so we can pass it to the front end to confirm the payment
    var subscriptionOptions = new SubscriptionCreateOptions
    {
        Customer = customerId,
        Items = new List<SubscriptionItemOptions>
        {
            new SubscriptionItemOptions
            {
                Price = req.PriceId,
            },
        },
        PaymentSettings = paymentSettings,
        PaymentBehavior = "default_incomplete",
    };
    subscriptionOptions.AddExpand("latest_invoice.confirmation_secret");
    var subscriptionService = new SubscriptionService();
    try
    {
        Subscription subscription = subscriptionService.Create(subscriptionOptions);

        return new SubscriptionCreateResponse
        {
          SubscriptionId = subscription.Id,
          ClientSecret = subscription.LatestInvoice.ConfirmationSecret.ClientSecret,
        };
    }
    catch (StripeException e)
    {
        Console.WriteLine($"Failed to create subscription.{e}");
        return BadRequest();
    }
}
```

If you’re using a *multi-currency Price*, use the [currency](https://docs.stripe.com/api/subscriptions/create.md#create_subscription-currency) parameter to tell the Subscription which of the Price’s currencies to use. (If you omit the `currency` parameter, then the Subscription uses the Price’s default currency.)

At this point the Subscription is `inactive` and awaiting payment. Here’s an example response. The minimum fields to store are highlighted, but store whatever your application frequently accesses.

```json
{
  "id": "sub_JgRjFjhKbtD2qz",
  "object": "subscription",
  "application_fee_percent": null,
  "automatic_tax": {
    "disabled_reason": null,
    "enabled": false,
    "liability": "null"
  },
  "billing_cycle_anchor": 1623873347,
  "billing_cycle_anchor_config": null,
  "cancel_at": null,
  "cancel_at_period_end": false,
  "canceled_at": null,
  "cancellation_details": {
    comment: null,
    feedback: null,
    reason: null
  },
  "collection_method": "charge_automatically",
  "created": 1623873347,
  "currency": "usd
  "customer": "cus_CMqDWO2xODTZqt",
  "days_until_due": null,
  "default_payment_method": null,
  "default_source": null,
  "default_tax_rates": [

  ],
  "discounts": [],
  "ended_at": null,
  "invoice_customer_balance_settings": {
    "account_tax_ids": null,
    issuer: {
      type: "self"
    }
  },
  "items": {
    "object": "list",
    "data": [
      {
        "id": "si_JgRjmS4Ur1khEx",
        "object": "subscription_item",
        "created": 1623873347,
        "current_period_end": 1626465347,
        "current_period_start": 1623873347,
        discounts: [],
        "metadata": {
        },
        "plan": {
          "id": "price_1J32RfGPZ1iASj5zHHp57z7C",
          "object": "plan",
          "active": true,
          "amount": 2000,
          "amount_decimal": "2000",
          "billing_scheme": "per_unit",
          "created": 1623864151,
          "currency": "usd",
          "interval": "month",
          "interval_count": 1,
          "livemode": false,
          "metadata": {
          },
          "nickname": null,
          "product": "prod_JgPF5xnq7qBun3",
          "tiers": null,
          "tiers_mode": null,
          "transform_usage": null,
          "trial_period_days": null,
          "usage_type": "licensed"
        },
        "price": {
          "id": "price_1J32RfGPZ1iASj5zHHp57z7C",
          "object": "price",
          "active": true,
          "billing_scheme": "per_unit",
          "created": 1623864151,
          "currency": "usd",
          "livemode": false,
          "lookup_key": null,
          "metadata": {
          },
          "nickname": null,
          "product": "prod_JgPF5xnq7qBun3",
          "recurring": {
            "interval": "month",
            "interval_count": 1,
            "trial_period_days": null,
            "usage_type": "licensed"
          },
          "tiers_mode": null,
          "transform_quantity": null,
          "type": "recurring",
          "unit_amount": 2000,
          "unit_amount_decimal": "2000"
        },
        "quantity": 1,
        "subscription": "sub_JgRjFjhKbtD2qz",
        "tax_rates": [

        ]
      }
    ],
    "has_more": false,
    "total_count": 1,
    "url": "/v1/subscription_items?subscription=sub_JgRjFjhKbtD2qz"
  },
  "latest_invoice": {
    "id": "in_1J34pzGPZ1iASj5zB87qdBNZ",
    "object": "invoice",
    "account_country": "US",
    "account_name": "Angelina's Store",
    "account_tax_ids": null,
    "amount_due": 2000,
    "amount_overpaid": 0,
    "amount_paid": 0,
    "amount_remaining": 2000,
    "amount_shipping": 0,
    "attempt_count": 0,
    "attempted": false,
    "auto_advance": false,
    "automatic_tax": {
      "disabled_reason": null,
      "enabled": false,
      liability: null,
      "status": null
    },
    "automatically_finalizes_at": null,
    "billing_reason": "subscription_update",
    "collection_method": "charge_automatically",
    "created": 1623873347,
    "currency": "usd",
    "custom_fields": null,
    "customer": "cus_CMqDWO2xODTZqt",
    "customer_address": null,
    "customer_email": "angelina@stripe.com",
    "customer_name": null,
    "customer_phone": null,
    "customer_shipping": {
      "address": {
        "city": "",
        "country": "US",
        "line1": "Berry",
        "line2": "",
        "postal_code": "",
        "state": ""
      },
      "name": "",
      "phone": null
    },
    "customer_tax_exempt": "none",
    "customer_tax_ids": [

    ],
    "default_payment_method": null,
    "default_source": null,
    "default_tax_rates": [

    ],
    "description": null,
    "discounts": [],
    "due_date": null,
    "effective_at": "1623873347
    "ending_balance": 0,
    "footer": null,
    "from_invoice": null,
    "hosted_invoice_url": "https://invoice.stripe.com/i/acct_1By64KGPZ1iASj5z/invst_JgRjzIOILGeq2MKC9T0KtyXnD5udsLp",
    "invoice_pdf": "https://pay.stripe.com/invoice/acct_1By64KGPZ1iASj5z/invst_JgRjzIOILGeq2MKC9T0KtyXnD5udsLp/pdf",
    "last_finalization_error": null,
    "latest_revision": null,
    "lines": {
      "object": "list",
      "data": [
        {
          "id": "il_1N2CjMBwKQ696a5NeOawRQP2",
          "object": "line_item",
          "amount": 2000,
          "currency": "usd",
          "description": "1 × Gold Special (at $20.00 / month)",
          "discount_amounts": [

          ],
          "discountable": true,
          "discounts": [

          ],
          "invoice": "in_1J34pzGPZ1iASj5zB87qdBNZ",
          "livemode": false,
          "metadata": {
          },
          "parent": {
            "invoice_item_details": null,
            "subscription_item_details":
            {
              "invoice_item": null
            "proration": false
            "proration_details":
            {
              "credited_items": null
            }
            subscription:
            "sub_JgRjFjhKbtD2qz"
            subscription_item:
              "si_JgRjmS4Ur1khEx"
            }
            type: "subscription_item_details"
          },
          "period": {
            "end": 1626465347,
            "start": 1623873347
          },
          "plan": {
            "id": "price_1J32RfGPZ1iASj5zHHp57z7C",
            "object": "plan",
            "active": true,
            "amount": 2000,
            "amount_decimal": "2000",
            "billing_scheme": "per_unit",
            "created": 1623864151,
            "currency": "usd",
            "interval": "month",
            "interval_count": 1,
            "livemode": false,
            "metadata": {
            },
            "nickname": null,
            "product": "prod_JgPF5xnq7qBun3",
            "tiers": null,
            "tiers_mode": null,
            "transform_usage": null,
            "trial_period_days": null,
            "usage_type": "licensed"
          },
          "price": {
            "id": "price_1J32RfGPZ1iASj5zHHp57z7C",
            "object": "price",
            "active": true,
            "billing_scheme": "per_unit",
            "created": 1623864151,
            "currency": "usd",
            "livemode": false,
            "lookup_key": null,
            "metadata": {
            },
            "nickname": null,
            "product": "prod_JgPF5xnq7qBun3",
            "recurring": {
              "interval": "month",
              "interval_count": 1,
              "trial_period_days": null,
              "usage_type": "licensed"
            },
            "tiers_mode": null,
            "transform_quantity": null,
            "type": "recurring",
            "unit_amount": 2000,
            "unit_amount_decimal": "2000"
          },
          "quantity": 1,
          "taxes": [],
        }
      ],
      "has_more": false,
      "total_count": 1,
      "url": "/v1/invoices/in_1J34pzGPZ1iASj5zB87qdBNZ/lines"
    },
    "livemode": false,
    "metadata": {
    },
    "next_payment_attempt": null,
    "number": "C008FC2-0354",
    "on_behalf_of": null,
    "parent": {
      "quote_details": null,
      "subscription_details": {
        "metadata": {},
        "pause_collection": null,
        "subscription": "sub_JgRjFjhKbtD2qz",
      }
    }
    "payment_intent": {
      "id": "pi_1J34pzGPZ1iASj5zI2nOAaE6",
      "object": "payment_intent",
      "allowed_source_types": [
        "card"
      ],
      "amount": 2000,
      "amount_capturable": 0,
      "amount_received": 0,
      "application": null,
      "application_fee_amount": null,
      "canceled_at": null,
      "cancellation_reason": null,
      "capture_method": "automatic",
      "charges": {
        "object": "list",
        "data": [

        ],
        "has_more": false,
        "total_count": 0,
        "url": "/v1/charges?payment_intent=pi_1J34pzGPZ1iASj5zI2nOAaE6"
      },
      "client_secret": "pi_1J34pzGPZ1iASj5zI2nOAaE6_secret_l7FN6ldFfXiFmJEumenJ2y2wu",
      "confirmation_method": "automatic",
      "created": 1623873347,
      "currency": "usd",
      "customer": "cus_CMqDWO2xODTZqt",
      "description": "Subscription creation",
      "invoice": "in_1J34pzGPZ1iASj5zB87qdBNZ",
      "last_payment_error": null,
      "livemode": false,
      "metadata": {
      },
      "next_action": null,
      "next_source_action": null,
      "on_behalf_of": null,
      "payment_method": null,
      "payment_method_options": {
        "card": {
          "installments": null,
          "network": null,
          "request_three_d_secure": "automatic"
        }
      },
      "payment_method_types": [
        "card"
      ],
      "receipt_email": null,
      "review": null,
      "setup_future_usage": "off_session",
      "shipping": null,
      "source": "card_1By6iQGPZ1iASj5z7ijKBnXJ",
      "statement_descriptor": null,
      "statement_descriptor_suffix": null,
      "status": "requires_confirmation",
      "transfer_data": null,
      "transfer_group": null
    },
    "payment_settings": {
      "payment_method_options": null,
      "payment_method_types": null,
      "save_default_payment_method": "on_subscription"
    },
    "period_end": 1623873347,
    "period_start": 1623873347,
    "post_payment_credit_notes_amount": 0,
    "pre_payment_credit_notes_amount": 0,
    "receipt_number": null,
    "starting_balance": 0,
    "statement_descriptor": null,
    "status": "open",
    "status_transitions": {
      "finalized_at": 1623873347,
      "marked_uncollectible_at": null,
      "paid_at": null,
      "voided_at": null
    },
    "subscription": "sub_JgRjFjhKbtD2qz",
    "subtotal": 2000,
    "tax": null,
    "tax_percent": null,
    "total": 2000,
    "total_discount_amounts": [],
    "total_tax_amounts": [],
    "transfer_data": null,
    "webhooks_delivered_at": 1623873347
  },
  "livemode": false,
  "metadata": {
  },
  "next_pending_invoice_item_invoice": null,
  "pause_collection": null,
  "pending_invoice_item_interval": null,
  "pending_setup_intent": null,
  "pending_update": null,
  "plan": {
    "id": "price_1J32RfGPZ1iASj5zHHp57z7C",
    "object": "plan",
    "active": true,
    "amount": 2000,
    "amount_decimal": "2000",
    "billing_scheme": "per_unit",
    "created": 1623864151,
    "currency": "usd",
    "interval": "month",
    "interval_count": 1,
    "livemode": false,
    "metadata": {
    },
    "nickname": null,
    "product": "prod_JgPF5xnq7qBun3",
    "tiers": null,
    "tiers_mode": null,
    "transform_usage": null,
    "trial_period_days": null,
    "usage_type": "licensed"
  },
  "quantity": 1,
  "schedule": null,
  "start": 1623873347,
  "start_date": 1623873347,
  "status": "incomplete",
  "tax_percent": null,
  "transfer_data": null,
  "trial_end": null,
  "trial_start": null
}
```

## Collect payment information

Use [Stripe Elements](https://docs.stripe.com/payments/elements.md) to collect payment details and activate the subscription. You can customize Elements to match the look-and-feel of your application.

The [Payment Element](https://docs.stripe.com/payments/payment-element.md) supports [Link](https://docs.stripe.com/payments/link.md), credit cards, SEPA direct debit, and BECS direct debit payment methods for subscriptions. It displays your enabled payment methods and securely collects the payment details according to the customer’s selection.

### Set up Stripe Elements

The Payment Element is automatically available as a feature of Stripe.js. Include the Stripe.js script on your checkout page by adding it to the `head` of your HTML file. Always load Stripe.js directly from js.stripe.com to remain PCI compliant. Don’t include the script in a bundle or host a copy of it yourself.

```html
<head>
  <title>Checkout</title>
  <script src="https://js.stripe.com/basil/stripe.js"></script>
</head>
<body>
  <!-- content here -->
</body>
```

Create an instance of Stripe with the following JavaScript on your checkout page:

```javascript
// Set your publishable key: remember to change this to your live publishable key in production
// See your keys here: https://dashboard.stripe.com/apikeys
const stripe = Stripe('<<publishable key>>');
```

### Add the Payment Element to your page

The Payment Element needs a place to live on your payment page. Create an empty DOM node (container) with a unique ID in your payment form.

```html
<form id="payment-form">
  <div id="payment-element">
    <!-- Elements will create form elements here -->
  </div>
  <button id="submit">Subscribe</button>
  <div id="error-message">
    <!-- Display error message to your customers here -->
  </div>
</form>
```

When the form above has loaded, create an instance of the Payment Element and mount it to the container DOM node. In the [create the subscription](#create-subscription) step, you passed the `client_secret` value to the frontend. Pass this value as an option when creating an instance of Elements.

```javascript
const options = {
  clientSecret: '{{CLIENT_SECRET}}',
  // Fully customizable with appearance API.
  appearance: {/*...*/},
};

// Set up Stripe.js and Elements to use in checkout form, passing the client secret obtained in step 5
const elements = stripe.elements(options);

const paymentElementOptions = {
  layout: "tabs",
};

// Create and mount the Payment Element
const paymentElement = elements.create('payment', paymentElementOptions);
paymentElement.mount('#payment-element');
```

The Payment Element renders a dynamic form that allows your customer to select a payment method. The form automatically collects all necessary payments details for the payment method that they select.

#### Optional Payment Element configurations

- Customize the Payment Element to match the design of your site by passing the [appearance object](https://docs.stripe.com/js/elements_object/create#stripe_elements-options-appearance) into `options` when creating an instance of Elements.
- Configure the Apple Pay interface to return a [merchant token](https://docs.stripe.com/apple-pay/merchant-tokens.md?pay-element=web-pe) to support recurring, auto reload, and deferred payments.

### Complete payment

Use `stripe.confirmPayment` to complete the payment using details from the Payment Element and activate the subscription. This creates a PaymentMethod and confirms the incomplete Subscription’s first PaymentIntent, causing a charge to be made. If *Strong Customer Authentication* (SCA) is required for the payment, the Payment Element handles the authentication process before confirming the PaymentIntent.

Provide a [return_url](https://docs.stripe.com/api/payment_intents/create.md#create_payment_intent-return_url) to this function to indicate where Stripe redirects the user after they complete the payment. Your user might first be redirected to an intermediate site, like a bank authorization page, before being redirected to the `return_url`. Card payments immediately redirect to the `return_url` when a payment is successful.

```javascript
const form = document.getElementById('payment-form');

form.addEventListener('submit', async (event) => {
  event.preventDefault();

  const {error} = await stripe.confirmPayment({
    //`Elements` instance that was used to create the Payment Element
    elements,
    confirmParams: {
      return_url: "https://example.com/order/123/complete",
    }
  });

  if (error) {
    // This point will only be reached if there is an immediate error when
    // confirming the payment. Show error to your customer (for example, payment
    // details incomplete)
    const messageContainer = document.querySelector('#error-message');
    messageContainer.textContent = error.message;
  } else {
    // Your customer will be redirected to your `return_url`. For some payment
    // methods like iDEAL, your customer will be redirected to an intermediate
    // site first to authorize the payment, then redirected to the `return_url`.
  }
});
```

When your customer submits a payment, Stripe redirects them to the `return_url` and includes the following URL query parameters. The return page can use them to get the status of the PaymentIntent so it can display the payment status to the customer.

When you specify the `return_url`, you can also append your own query parameters for use on the return page.

| Parameter                      | Description                                                                                                                                                                                                                                                                                                                                                |
| ------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `payment_intent`               | The unique identifier for the `PaymentIntent`.                                                                                                                                                                                                                                                                                                             |
| `payment_intent_client_secret` | The [client secret](https://docs.stripe.com/api/payment_intents/object.md#payment_intent_object-client_secret) of the `PaymentIntent` object. For subscription integrations, this client_secret is also exposed on the `Invoice` object through [`confirmation_secret`](https://docs.stripe.com/api/invoices/object.md#invoice_object-confirmation_secret) |

When the customer is redirected back to your site, you can use the `payment_intent_client_secret` to query for the PaymentIntent and display the transaction status to your customer.

If you have tooling that tracks the customer’s browser session, you might need to add the `stripe.com` domain to the referrer exclude list. Redirects cause some tools to create new sessions, which prevents you from tracking the complete session.

Use one of the query parameters to retrieve the PaymentIntent. Inspect the [status of the PaymentIntent](https://docs.stripe.com/payments/paymentintents/lifecycle.md) to decide what to show your customers. You can also append your own query parameters when providing the `return_url`, which persist through the redirect process.

```javascript
// Initialize Stripe.js using your publishable key
const stripe = Stripe('<<publishable key>>');

// Retrieve the "payment_intent_client_secret" query parameter appended to
// your return_url by Stripe.js
const clientSecret = new URLSearchParams(window.location.search).get(
  'payment_intent_client_secret'
);

// Retrieve the PaymentIntent
stripe.retrievePaymentIntent(clientSecret).then(({paymentIntent}) => {
  const message = document.querySelector('#message')

  // Inspect the PaymentIntent `status` to indicate the status of the payment
  // to your customer.
  //
  // Some payment methods will [immediately succeed or fail][0] upon
  // confirmation, while others will first enter a `processing` state.
  //
  // [0]: https://stripe.com/docs/payments/payment-methods#payment-notification
  switch (paymentIntent.status) {
    case 'succeeded':
      message.innerText = 'Success! Payment received.';
      break;

    case 'processing':
      message.innerText = "Payment processing. We'll update you when payment is received.";
      break;

    case 'requires_payment_method':
      message.innerText = 'Payment failed. Please try another payment method.';
      // Redirect your user back to your payment page to attempt collecting
      // payment again
      break;

    default:
      message.innerText = 'Something went wrong.';
      break;
  }
});
```

## Listen for webhooks

To complete the integration, you need to process *webhooks* sent by Stripe. These are events triggered whenever state inside of Stripe changes, such as subscriptions creating new invoices. In your application, set up an HTTP handler to accept a POST request containing the webhook event, and verify the signature of the event:

```ruby
<<setup key>>

post '/webhook' do
  # You can use webhooks to receive information about asynchronous payment events.
  # For more about our webhook events check out https://stripe.com/docs/webhooks.
  webhook_secret = ENV['STRIPE_WEBHOOK_SECRET']
  payload = request.body.read
  if !webhook_secret.empty?
    # Retrieve the event by verifying the signature using the raw body and secret if webhook signing is configured.
    sig_header = request.env['HTTP_STRIPE_SIGNATURE']
    event = nil

    begin
      event = Stripe::Webhook.construct_event(
        payload, sig_header, webhook_secret
      )
    rescue JSON::ParserError => e
      # Invalid payload
      status 400
      return
    rescue Stripe::SignatureVerificationError => e
      # Invalid signature
      puts '⚠️  Webhook signature verification failed.'
      status 400
      return
    end
  else
    data = JSON.parse(payload, symbolize_names: true)
    event = Stripe::Event.construct_from(data)
  end
  # Get the type of webhook event sent - used to check the status of PaymentIntents.
  event_type = event['type']
  data = event['data']
  data_object = data['object']

  if event_type == 'invoice.paid'
    # Used to provision services after the trial has ended.
    # The status of the invoice will show up as paid. Store the status in your
    # database to reference when a user accesses your service to avoid hitting rate
    # limits.
    # puts data_object
  end

  if event_type == 'invoice.payment_failed'
    # If the payment fails or the customer does not have a valid payment method,
    # an invoice.payment_failed event is sent, the subscription becomes past_due.
    # Use this webhook to notify your user that their payment has
    # failed and to retrieve new card details.
    # puts data_object
  end

  if event_type == 'customer.subscription.deleted'
    # handle subscription canceled automatically based
    # upon your subscription settings. Or if the user cancels it.
    # puts data_object
  end

  content_type 'application/json'
  { status: 'success' }.to_json
end
```

```python
<<setup key>>

@app.route('/webhook', methods=['POST'])
def webhook_received():
  # You can use webhooks to receive information about asynchronous payment events.
  # For more about our webhook events check out https://stripe.com/docs/webhooks.
  webhook_secret = os.getenv('STRIPE_WEBHOOK_SECRET')
  request_data = json.loads(request.data)

  if webhook_secret:
    # Retrieve the event by verifying the signature using the raw body and secret if webhook signing is configured.
    signature = request.headers.get('stripe-signature')
    try:
      event = stripe.Webhook.construct_event(
        payload=request.data, sig_header=signature, secret=webhook_secret)
      data = event['data']
    except Exception as e:
      return e
    # Get the type of webhook event sent - used to check the status of PaymentIntents.
    event_type = event['type']
  else:
    data = request_data['data']
    event_type = request_data['type']

  data_object = data['object']

  if event_type == 'invoice.paid':
    # Used to provision services after the trial has ended.
    # The status of the invoice will show up as paid. Store the status in your
    # database to reference when a user accesses your service to avoid hitting rate
    # limits.
    print(data)

  if event_type == 'invoice.payment_failed':
    # If the payment fails or the customer does not have a valid payment method,
    # an invoice.payment_failed event is sent, the subscription becomes past_due.
    # Use this webhook to notify your user that their payment has
    # failed and to retrieve new card details.
    print(data)

  if event_type == 'customer.subscription.deleted':
    # handle subscription canceled automatically based
    # upon your subscription settings. Or if the user cancels it.
    print(data)

  return jsonify({'status': 'success'})
```

```php
<<setup key>>

$event = null;
$payload = @file_get_contents('php://input');
$sig_header = $_SERVER['HTTP_STRIPE_SIGNATURE'];
$webhook_secret = '{{STRIPE_WEBHOOK_SECRET}}';
try {
  $event = \Stripe\Webhook::constructEvent(
    $payload, $sig_header, $webhook_secret
  );
} catch(\UnexpectedValueException $e) {
  // Invalid payload
  http_response_code(400);
  exit();
} catch(\Stripe\Exception\SignatureVerificationException $e) {
  // Invalid signature
  http_response_code(400);
  exit();
}

// Handle the event
// Review important events for Billing webhooks
// https://stripe.com/docs/billing/webhooks
// Remove comment to see the various objects sent for this sample
switch ($event->type) {
  case 'invoice.paid':
    // The status of the invoice will show up as paid. Store the status in your
    // database to reference when a user accesses your service to avoid hitting rate
    // limits.
    break;
  case 'invoice.payment_failed':
    // If the payment fails or the customer does not have a valid payment method,
    // an invoice.payment_failed event is sent, the subscription becomes past_due.
    // Use this webhook to notify your user that their payment has
    // failed and to retrieve new card details.
    break;
  case 'customer.subscription.deleted':
    // handle subscription canceled automatically based
    // upon your subscription settings. Or if the user
    // cancels it.
    break;
  // ... handle other event types
  default:
    // Unhandled event type
}

http_response_code(200);
```

```java
<<setup key>>

post(
  "/webhook",
  (request, response) -> {
    String payload = request.body();
    String sigHeader = request.headers("Stripe-Signature");
    String endpointSecret = dotenv.get("STRIPE_WEBHOOK_SECRET");
    Event event = null;

    try {
      event = Webhook.constructEvent(payload, sigHeader, endpointSecret);
    } catch (SignatureVerificationException e) {
      // Invalid signature
      response.status(400);
      return "";
    }

    // Deserialize the nested object inside the event
    EventDataObjectDeserializer dataObjectDeserializer = event.getDataObjectDeserializer();
    StripeObject stripeObject = null;
    if (dataObjectDeserializer.getObject().isPresent()) {
      stripeObject = dataObjectDeserializer.getObject().get();
    } else {
      // Deserialization failed, probably due to an API version mismatch.
      // Refer to the Javadoc documentation on `EventDataObjectDeserializer` for
      // instructions on how to handle this case, or return an error here.
    }

    switch (event.getType()) {
      case "invoice.paid":
        // Used to provision services after the trial has ended.
        // The status of the invoice will show up as paid. Store the status in your
        // database to reference when a user accesses your service to avoid hitting rate
        // limits.
        break;
      case "invoice.payment_failed":
        // If the payment fails or the customer does not have a valid payment method,
        // an invoice.payment_failed event is sent, the subscription becomes past_due.
        // Use this webhook to notify your user that their payment has
        // failed and to retrieve new card details.
        break;
      case "customer.subscription.deleted":
        // handle subscription canceled automatically based
        // upon your subscription settings. Or if the user
        // cancels it.
        break;
      default:
      // Unhandled event type
    }

    response.status(200);
    return "";
  }
);
```

```javascript
<<setup key>>

app.post(
  '/webhook',
  bodyParser.raw({ type: 'application/json' }),
  async (req, res) => {
    // Retrieve the event by verifying the signature using the raw body and secret.
    let event;

    try {
      event = stripe.webhooks.constructEvent(
        req.body,
        req.headers['stripe-signature'],
        process.env.STRIPE_WEBHOOK_SECRET
      );
    } catch (err) {
      console.log(err);
      console.log(`⚠️  Webhook signature verification failed.`);
      console.log(
        `⚠️  Check the env file and enter the correct webhook secret.`
      );
      return res.sendStatus(400);
    }
    // Extract the object from the event.
    const dataObject = event.data.object;

    // Handle the event
    // Review important events for Billing webhooks
    // https://stripe.com/docs/billing/webhooks
    // Remove comment to see the various objects sent for this sample
    switch (event.type) {
      case 'invoice.paid':
        // Used to provision services after the trial has ended.
        // The status of the invoice will show up as paid. Store the status in your
        // database to reference when a user accesses your service to avoid hitting rate limits.
        break;
      case 'invoice.payment_failed':
        // If the payment fails or the customer does not have a valid payment method,
        //  an invoice.payment_failed event is sent, the subscription becomes past_due.
        // Use this webhook to notify your user that their payment has
        // failed and to retrieve new card details.
        break;
      case 'customer.subscription.deleted':
        if (event.request != null) {
          // handle a subscription canceled by your request
          // from above.
        } else {
          // handle subscription canceled automatically based
          // upon your subscription settings.
        }
        break;
      default:
      // Unexpected event type
    }
    res.sendStatus(200);
  }
);
```

```go
<<setup key>>

func handleWebhook(w http.ResponseWriter, r *http.Request) {
  if r.Method != "POST" {
    http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
    return
  }
  b, err := ioutil.ReadAll(r.Body)
  if err != nil {
    http.Error(w, err.Error(), http.StatusBadRequest)
    log.Printf("ioutil.ReadAll: %v", err)
    return
  }

  event, err := webhook.ConstructEvent(b, r.Header.Get("Stripe-Signature"), os.Getenv("STRIPE_WEBHOOK_SECRET"))
  if err != nil {
    http.Error(w, err.Error(), http.StatusBadRequest)
    log.Printf("webhook.ConstructEvent: %v", err)
    return
  }

  if event.Type == "invoice.paid" {
    // Used to provision services after the trial has ended.
    // The status of the invoice will show up as paid. Store the status in your
    // database to reference when a user accesses your service to avoid hitting rate
    // limits.
    return
  }

  if event.Type == "invoice.payment_failed" {
    // If the payment fails or the customer does not have a valid payment method,
    // an invoice.payment_failed event is sent, the subscription becomes past_due.
    // Use this webhook to notify your user that their payment has
    // failed and to retrieve new card details.
    return
  }

  if event.Type == "customer.subscription.deleted" {
    // handle subscription canceled automatically based
    // upon your subscription settings. Or if the user cancels it. {
    return
  }
}
```

```dotnet
<<setup key>>

[HttpPost("webhook")]
public async Task<IActionResult> Webhook()
{
  var json = await new StreamReader(HttpContext.Request.Body).ReadToEndAsync();
  Event stripeEvent;
  try
  {
    stripeEvent = EventUtility.ConstructEvent(
      json,
      Request.Headers["Stripe-Signature"],
      this.options.Value.WebhookSecret
    );
    Console.WriteLine($"Webhook notification with type: {stripeEvent.Type} found for {stripeEvent.Id}");
  }
  catch (Exception e)
  {
    Console.WriteLine($"Something failed {e}");
    return BadRequest();
  }

  if (stripeEvent.Type == "invoice.paid")
  {
    // Used to provision services after the trial has ended.
    // The status of the invoice will show up as paid. Store the status in your
    // database to reference when a user accesses your service to avoid hitting rate
    // limits.
  }

  if (stripeEvent.Type == "invoice.payment_failed")
  {
    // If the payment fails or the customer does not have a valid payment method,
    // an invoice.payment_failed event is sent, the subscription becomes past_due.
    // Use this webhook to notify your user that their payment has
    // failed and to retrieve new card details.
  }

  if (stripeEvent.Type == "customer.subscription.deleted")
  {
    // handle subscription canceled automatically based
    // upon your subscription settings. Or if the user cancels it.
  }
  return Ok();
}
```

During development, use the Stripe CLI to [observe webhooks and forward them to your application](https://docs.stripe.com/webhooks.md#test-webhook). Run the following in a new terminal while your development app is running:

```bash
stripe listen --forward-to localhost:4242/webhook
```

For production, set up a webhook endpoint URL in the Dashboard, or use the [Webhook Endpoints API](https://docs.stripe.com/api/webhook_endpoints.md).

You’ll listen to a couple of events to complete the remaining steps in this guide. See [Subscription events](https://docs.stripe.com/billing/subscriptions/overview.md#subscription-events) for more details about subscription-specific webhooks.

## Provision access to your service

Now that the subscription is active, give your user access to your service.  To do this, listen to the `customer.subscription.created`, `customer.subscription.updated`, and `customer.subscription.deleted` events.  These events pass a subscription object which contains a `status` field indicating whether the subscription is active, past due, or canceled.  See [the subscription lifecycle](https://docs.stripe.com/billing/subscriptions/overview.md#subscription-lifecycle) for a complete list of statuses.

In your webhook handler:

1. Verify the subscription status.  If it’s `active` then your user has paid for your product.
1. Check the product the customer subscribed to and grant access to your service. Checking the product instead of the price gives you more flexibility if you need to change the pricing or billing interval.
1. Store the `product.id`, `subscription.id` and `subscription.status` in your database along with the `customer.id` you already saved.  Check this record when determining which features to enable for the user in your application.

The state of a subscription might change at any point during its lifetime, even if your application does not directly make any calls to Stripe.  For example, a renewal might fail due to an expired credit card, which puts the subscription into a past due state.  Or, if you implement the [customer portal](https://docs.stripe.com/customer-management.md), a user might cancel their subscription without directly visiting your application.  Implementing your handler correctly keeps your application state in sync with Stripe.

## Cancel the subscription

It’s common to allow customers to cancel their subscriptions. This example adds a cancellation option to the account settings page.

![Sample subscription cancelation interface.](images/billing/subscriptions/fixed-price-subscriptions-guide-account-settings.png)
Account settings with the ability to cancel the subscription


```javascript
function cancelSubscription(subscriptionId) {
  return fetch('/cancel-subscription', {
    method: 'post',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      subscriptionId: subscriptionId,
    }),
  })
    .then(response => {
      return response.json();
    })
    .then(cancelSubscriptionResponse => {
      // Display to the user that the subscription has been canceled.
    });
}
```

On the backend, define the endpoint for your frontend to call.

```ruby
<<setup key>>

post '/cancel-subscription' do
  content_type 'application/json'
  data = JSON.parse request.body.read

  deleted_subscription = Stripe::Subscription.cancel(data['subscriptionId'])

  deleted_subscription.to_json
end
```

```python
<<setup key>>

@app.route('/cancel-subscription', methods=['POST'])
def cancelSubscription():
    data = json.loads(request.data)
    try:
         # Cancel the subscription by deleting it
        deletedSubscription = stripe.Subscription.delete(data['subscriptionId'])
        return jsonify(deletedSubscription)
    except Exception as e:
        return jsonify(error=str(e)), 403
```

```php
<<setup key>>

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
  $body = file_get_contents('php://input');
  $json = json_decode($body);

  $subscription = $stripe->subscriptions->retrieve(
    $json->subscriptionId
  );
  $subscription->delete();

  header('Content-Type: application/json');
  echo json_encode([
    'subscription' => $subscription,
  ]);
}
```

```java
<<setup key>>

post(
      "/cancel-subscription",
      (request, response) -> {
        response.type("application/json");
        // Set the default payment method on the customer
        CancelPostBody postBody = gson.fromJson(
          request.body(),
          CancelPostBody.class
        );

        Subscription subscription = Subscription.retrieve(
          postBody.getSubscriptionId()
        );

        Subscription deletedSubscription = subscription.cancel();
        return deletedSubscription.toJson();
      }
    );
```

```javascript
<<setup key>>

app.post('/cancel-subscription', async (req, res) => {
  // Delete the subscription
  const deletedSubscription = await stripe.subscriptions.del(
    req.body.subscriptionId
  );
  res.send(deletedSubscription);
});
```

```go
<<setup key>>

func handleCancelSubscription(w http.ResponseWriter, r *http.Request) {
  if r.Method != "POST" {
    http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
    return
  }
  var req struct {
    SubscriptionID string `json:"subscriptionId"`
  }
  if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("json.NewDecoder.Decode: %v", err)
    return
  }
  s, err := subscription.Cancel(req.SubscriptionID, nil)
  if err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("subscription.Cancel: %v", err)
    return
  }
  writeJSON(w, s)
}
```

```dotnet
using Newtonsoft.Json;

public class CancelSubscriptionRequest
{
    [JsonProperty("subscriptionId")]
    public string Subscription { get; set; }
}
```

```dotnet
<<setup key>>

[HttpPost("cancel-subscription")]
public ActionResult<Subscription> CancelSubscription([FromBody] CancelSubscriptionRequest req)
{
    var service = new SubscriptionService();
    var subscription = service.Cancel(req.Subscription, null);
    return subscription;
}
```

Your application receives a `customer.subscription.deleted` event.

After the subscription is canceled, update your database to remove the Stripe subscription ID you previously stored, and limit access to your service.

When a subscription is canceled, it can’t be reactivated. Instead, collect updated billing information from your customer, update their default payment method, and create a new subscription with their existing customer record.

## Test your integration

### Test payment methods

Use the following table to test different payment methods and scenarios.

| Payment method    | Scenario                                                                                         | How to test                                                                                                                                                                                                  |
| ----------------- | ------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| BECS Direct Debit | Your customer successfully pays with BECS Direct Debit.                                          | Fill out the form using the account number `900123456` and BSB `000-000`. The confirmed PaymentIntent initially transitions to `processing`, then transitions to the `succeeded` status three minutes later. |
| BECS Direct Debit | Your customer’s payment fails with an `account_closed` error code.                               | Fill out the form using the account number `111111113` and BSB `000-000`.                                                                                                                                    |
| Credit card       | The card payment succeeds and doesn’t require authentication.                                    | Fill out the credit card form using the credit card number `4242 4242 4242 4242` with any expiration, CVC, and postal code.                                                                                  |
| Credit card       | The card payment requires *authentication*.                                                      | Fill out the credit card form using the credit card number `4000 0025 0000 3155` with any expiration, CVC, and postal code.                                                                                  |
| Credit card       | The card is declined with a decline code like `insufficient_funds`.                              | Fill out the credit card form using the credit card number `4000 0000 0000 9995` with any expiration, CVC, and postal code.                                                                                  |
| SEPA Direct Debit | Your customer successfully pays with SEPA Direct Debit.                                          | Fill out the form using the account number `AT321904300235473204`. The confirmed PaymentIntent initially transitions to processing, then transitions to the succeeded status three minutes later.            |
| SEPA Direct Debit | Your customer’s PaymentIntent status transitions from `processing` to `requires_payment_method`. | Fill out the form using the account number `AT861904300235473202`.                                                                                                                                           |

### Monitor events

Set up webhooks to listen to subscription change events, such as upgrades and cancellations. Learn more about [subscription webhooks](https://docs.stripe.com/billing/subscriptions/webhooks.md). You can view events in the [Dashboard](https://dashboard.stripe.com/test/events) or with the [Stripe CLI](https://docs.stripe.com/webhooks.md#test-webhook).

For more details, see [testing your Billing integration](https://docs.stripe.com/billing/testing.md).

## Let customers change their plans

To let your customers change their subscription, collect the price ID of the option they want to change to. Then send the new price ID from the frontend to a backend endpoint. This example also passes the subscription ID, but you can retrieve it from your database for your logged in user.

```javascript
function updateSubscription(priceId, subscriptionId) {
  return fetch('/update-subscription', {
    method: 'post',
    headers: {
      'Content-type': 'application/json',
    },
    body: JSON.stringify({
      subscriptionId: subscriptionId,
      newPriceId: priceId,
    }),
  })
    .then(response => {
      return response.json();
    })
    .then(response => {
      return response;
    });
}
```

On the backend, define the endpoint for your frontend to call, passing the subscription ID and the new price ID. The subscription is now Premium, at 15 USD per month, instead of Basic at 5 USD per month.

```ruby
<<setup key>>

post '/update-subscription' do
  content_type 'application/json'
  data = JSON.parse request.body.read

  subscription = Stripe::Subscription.retrieve(data['subscriptionId'])

  updated_subscription =
    Stripe::Subscription.update(
      data['subscriptionId'],
      cancel_at_period_end: false,
      items: [
        { id: subscription.items.data[0].id, price: 'price_H1NlVtpo6ubk0m' }
      ]
    )

  updated_subscription.to_json
end
```

```python
<<setup key>>

@app.route('/update-subscription', methods=['POST'])
def updateSubscription():
    data = json.loads(request.data)
    try:
        subscription = stripe.Subscription.retrieve(data['subscriptionId'])

        updatedSubscription = stripe.Subscription.modify(
            data['subscriptionId'],
            cancel_at_period_end=False,
            items=[{
                'id': subscription['items']['data'][0].id,
                'price': 'price_H1NlVtpo6ubk0m',
            }]
        )
        return jsonify(updatedSubscription)
    except Exception as e:
        return jsonify(error=str(e)), 403
```

```php
<<setup key>>

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
  $body = file_get_contents('php://input');
  $json = json_decode($body);

  $subscription = $stripe->subscriptions->retrieve($json->subscriptionId);

  $updated_subscription = $stripe->subscriptions->update($json->subscriptionId, [
    'items' => [
      [
        'id' => $subscription->items->data[0]->id,
        'price' => 'price_H1NlVtpo6ubk0m',
      ],
    ],
  ]);

  header('Content-Type: application/json');
  echo json_encode([
    'updatedSubscription' => $updated_subscription,
  ]);
}
```

```java
<<setup key>>

post(
  "/update-subscription",
  (request, response) -> {
    response.type("application/json");
    // Set the default payment method on the customer
    UpdatePostBody postBody = gson.fromJson(
      request.body(),
      UpdatePostBody.class
    );

    Subscription subscription = Subscription.retrieve(
      postBody.getSubscriptionId()
    );

    SubscriptionUpdateParams params = SubscriptionUpdateParams
      .builder()
      .addItem(
        SubscriptionUpdateParams
          .Item.builder()
          .setId(subscription.getItems().getData().get(0).getId())
          .setPrice("price_H1NlVtpo6ubk0m")
          .build()
      )
      .setCancelAtPeriodEnd(false)
      .build();

    subscription.update(params);
    return subscription.toJson();
  }
);
```

```javascript
<<setup key>>

app.post('/update-subscription', async (req, res) => {
  const subscription = await stripe.subscriptions.retrieve(
    req.body.subscriptionId
  );
  const updatedSubscription = await stripe.subscriptions.update(
    req.body.subscriptionId,
    {
      cancel_at_period_end: false,
      items: [
        {
          id: subscription.items.data[0].id,
          price: "price_H1NlVtpo6ubk0m",
        },
      ],
    }
  );

  res.send(updatedSubscription);
});
```

```go
<<setup key>>

func handleUpdateSubscription(w http.ResponseWriter, r *http.Request) {
  if r.Method != "POST" {
    http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
    return
  }

  var req struct {
    SubscriptionID string `json:"subscriptionId"`
    NewPriceID     string `json:"newPriceId"`
  }

  if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("json.NewDecoder.Decode: %v", err)
    return
  }

  s, err := subscription.Get(req.SubscriptionID, nil)
  if err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("subscription.Get: %v", err)
    return
  }

  params := &stripe.SubscriptionParams{
    CancelAtPeriodEnd: stripe.Bool(false),
    Items: []*stripe.SubscriptionItemsParams{{
      ID:    stripe.String(s.Items.Data[0].ID),
      Price: stripe.String("price_H1NlVtpo6ubk0m"),
    }},
  }

  updatedSubscription, err := subscription.Update(req.SubscriptionID, params)

  if err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("subscription.Update: %v", err)
    return
  }

  writeJSON(w, updatedSubscription)
}
```

```dotnet
using Newtonsoft.Json;

public class UpdateSubscriptionRequest
{
    [JsonProperty("subscriptionId")]
    public string Subscription { get; set; }

    [JsonProperty("newPriceId")]
    public string NewPrice { get; set; }
}
```

```dotnet
<<setup key>>

[HttpPost("update-subscription")]
public ActionResult<Subscription> UpdateSubscription([FromBody] UpdateSubscriptionRequest req)
{
    var service = new SubscriptionService();
    var subscription = service.Get(req.Subscription);

    var options = new SubscriptionUpdateOptions
    {
        CancelAtPeriodEnd = false,
        Items = new List<SubscriptionItemOptions>
        {
            new SubscriptionItemOptions
            {
                Id = subscription.Items.Data[0].Id,
                Price = "price_H1NlVtpo6ubk0m",
            }
        }
    };
    var updatedSubscription = service.Update(req.Subscription, options);
    return updatedSubscription;
}
```

Your application receives a `customer.subscription.updated` event.

## Preview a price change

When your customer changes their subscription, there’s often an adjustment to the amount they owe, known as a [proration](https://docs.stripe.com/billing/subscriptions/prorations.md). You can use the [create preview invoice endpoint](https://docs.stripe.com/api/invoices/create_preview.md) to display the adjusted amount to your customers.

On the frontend, pass the create preview invoice details to a backend endpoint.

```javascript
function createPreviewInvoice(
  customerId,
  subscriptionId,
  newPriceId,
  trialEndDate
) {
  return fetch('/create-preview-invoice', {
    method: 'post',
    headers: {
      'Content-type': 'application/json',
    },
    body: JSON.stringify({
      customerId: customerId,
      subscriptionId: subscriptionId,
      newPriceId: newPriceId,
    }),
  })
    .then(response => {
      return response.json();
    })
    .then((invoice) => {
      return invoice;
    });
}
```

On the backend, define the endpoint for your frontend to call.

```ruby
<<setup key>>

post '/create-preview-invoice' do
  content_type 'application/json'
  data = JSON.parse request.body.read

  subscription = Stripe::Subscription.retrieve(data['subscriptionId'])

  invoice =
    Stripe::Invoice.create_preview(
      customer: data['customerId'],
      subscription: data['subscriptionId'],
      subscription_details: {
        items: [
          { id: subscription.items.data[0].id, deleted: true },
          { price: ENV[data['newPriceId']], deleted: false }
        ]
      }
    )

  invoice.to_json
end
```

```python
<<setup key>>

@app.route('/create-preview-invoice', methods=['POST'])
def createPreviewInvoice():
    data = json.loads(request.data)
    try:
        # Retrieve the subscription
        subscription = stripe.Subscription.retrieve(data['subscriptionId'])

        # Retrieve the invoice
        invoice = stripe.Invoice.create_preview(
            customer=data['customerId'],
            subscription=data['subscriptionId'],
            subscription_details={
              "items": [
                  {
                      'id': subscription['items']['data'][0].id,
                      'deleted': True,
                  },
                  {
                      'price': 'price_H1NlVtpo6ubk0m',
                      'deleted': False,
                  }
              ]
            }
        )
        return jsonify(invoice)
    except Exception as e:
        return jsonify(error=str(e)), 403
```

```php
<<setup key>>

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
  $body = file_get_contents('php://input');
  $json = json_decode($body);

  $subscription = $stripe->subscriptions->retrieve($json->subscriptionId);

  $invoice = $stripe->invoices->createPreview([
    'customer' => $json->customerId,
    'subscription' => $json->subscriptionId,
    'subscription_details' => [
      'items' => [
        [
          'id' => $subscription->items->data[0]->id,
          'deleted' => true
        ],
        [
          'price' => $json->newPriceId,
          'deleted' => false
        ],
      ],
    ],
  ]);

  header('Content-Type: application/json');
  echo json_encode([
    'invoice' => $invoice,
  ]);
}
```

```java
<<setup key>>

post(
  "/create-preview-invoice",
  (request, response) -> {
    response.type("application/json");
    PreviewInvoicePostBody postBody = gson.fromJson(
      request.body(),
      PreviewInvoicePostBody.class
    );

    Subscription subscription = Subscription.retrieve(
      postBody.getSubscriptionId()
    );

    InvoiceCreatePreviewParams invoiceParams = InvoiceCreatePreviewParams
      .builder()
      .setCustomer(postBody.getCustomerId())
      .setSubscription(postBody.getSubscriptionId())
      .setSubscriptionDetails(
        InvoiceCreatePreviewParams.SubscriptionDetails.builder()
          .addItem(
            InvoiceCreatePreviewParams.SubscriptionDetails.Item.builder()
              .setId(subscription.getItems().getData().get(0).getId())
              .setDeleted(true)
              .build()
          )
          .addItem(
            InvoiceCreatePreviewParams.SubscriptionDetails.Item.builder()
              .setPrice(dotenv.get(postBody.getNewPriceId().toUpperCase()))
              .build()
          )
          .build()
      )
      .build();

    Invoice invoice = Invoice.createPreview(invoiceParams);

    return invoice.toJson();
  }
);
```

```javascript
<<setup key>>

app.post('/create-preview-invoice', async (req, res) => {
  const subscription = await stripe.subscriptions.retrieve(
    req.body.subscriptionId
  );

  const invoice = await stripe.invoices.createPreview({
    customer: req.body.customerId,
    subscription: req.body.subscriptionId,
    subscription_details: {
      items: [
        {
          id: subscription.items.data[0].id,
          deleted: true,
        },
        {
          // This price ID is the price you want to change the subscription to.
          price: 'price_H1NlVtpo6ubk0m',
          deleted: false,
        },
      ],
    }
  });
  res.send(invoice);
});
```

```go
<<setup key>>

func handleCreatePreviewInvoice(w http.ResponseWriter, r *http.Request) {
  if r.Method != "POST" {
    http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
    return
  }
  var req struct {
    SubscriptionID string `json:"subscriptionId"`
    CustomerID     string `json:"customerId"`
    NewPriceID     string `json:"newPriceId"`
  }

  if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("json.NewDecoder.Decode: %v", err)
    return
  }

  s, err := subscription.Get(req.SubscriptionID, nil)
  if err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("subscription.Get: %v", err)
    return
  }
  params := &stripe.InvoiceCreatePreviewParams{
    Customer:     stripe.String(req.CustomerID),
    Subscription: stripe.String(req.SubscriptionID),
    SubscriptionDetails: &stripe.InvoiceCreatePreviewSubscriptionDetailsParams{
      Items: []*stripe.SubscriptionItemsParams{{
        ID:      stripe.String(s.Items.Data[0].ID),
        Deleted: stripe.Bool(true),
      }, {
        Price:   stripe.String(os.Getenv(req.NewPriceID)),
        Deleted: stripe.Bool(false),
      }},
    },
  }
  in, err := invoice.CreatePreview(params)

  if err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("invoice.CreatePreview: %v", err)
    return
  }

  writeJSON(w, in)
}
```

```dotnet
using Newtonsoft.Json;

public class CreatePreviewInvoiceRequest
{
    [JsonProperty("customerId")]
    public string Customer { get; set; }

    [JsonProperty("subscriptionId")]
    public string Subscription { get; set; }

    [JsonProperty("newPriceId")]
    public string NewPrice { get; set; }
}
```

```dotnet
<<setup key>>

[HttpPost("create-preview-invoice")]
public ActionResult<Invoice> CreatePreviewInvoice([FromBody] CreatePreviewInvoiceRequest req)
{
    var service = new SubscriptionService();
    var subscription = service.Get(req.Subscription);

    var invoiceService = new InvoiceService();
    var options = new InvoiceCreatePreviewOptions
    {
        Customer = req.Customer,
        Subscription = req.Subscription,
        SubscriptionDetails = new InvoiceSubscriptionDetailsOptions
        {
            Items = new List<InvoiceSubscriptionItemOptions>
            {
                new InvoiceSubscriptionItemOptions
                {
                    Id = subscription.Items.Data[0].Id,
                    Deleted = true,
                },
                new InvoiceSubscriptionItemOptions
                {
                    Price = Environment.GetEnvironmentVariable(req.NewPrice),
                    Deleted = false,
                },
            },
        },
    };
    Invoice previewInvoice = invoiceService.CreatePreview(options);
    return previewInvoice;
}
```

## Display the customer payment method

Displaying the brand and last four digits of your customer’s card can help them know which card is being charged, or if they need to update their payment method.

On the frontend, send the payment method ID to a backend endpoint that retrieves the payment method details.

```javascript
function retrieveCustomerPaymentMethod(paymentMethodId) {
  return fetch('/retrieve-customer-payment-method', {
    method: 'post',
    headers: {
      'Content-type': 'application/json',
    },
    body: JSON.stringify({
      paymentMethodId: paymentMethodId,
    }),
  })
    .then((response) => {
      return response.json();
    })
    .then((response) => {
      return response;
    });
}
```

On the backend, define the endpoint for your frontend to call.

```ruby
<<setup key>>

post '/retrieve-customer-payment-method' do
  content_type 'application/json'
  data = JSON.parse request.body.read

  payment_method = Stripe::PaymentMethod.retrieve(data['paymentMethodId'])

  payment_method.to_json
end
```

```python
<<setup key>>

@app.route('/retrieve-customer-payment-method', methods=['POST'])
def retrieveCustomerPaymentMethod():
    data = json.loads(request.data)
    try:
        paymentMethod = stripe.PaymentMethod.retrieve(
            data['paymentMethodId'],
        )
        return jsonify(paymentMethod)
    except Exception as e:
        return jsonify(error=str(e)), 403
```

```php
<<setup key>>

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
  $body = file_get_contents('php://input');
  $json = json_decode($body);

  $payment_method = $stripe->paymentMethods->retrieve($json->paymentMethodId);

  header('Content-Type: application/json');
  echo json_encode([
    'paymentMethod' => $payment_method,
  ]);
}
```

```java
<<setup key>>

post(
  "/retrieve-customer-payment-method",
  (request, response) -> {
    response.type("application/json");
    // Set the default payment method on the customer
    PaymentMethodBody paymentMethodBody = gson.fromJson(
      request.body(),
      PaymentMethodBody.class
    );

    PaymentMethod paymentMethod = PaymentMethod.retrieve(
      paymentMethodBody.getPaymentMethodId()
    );
    return paymentMethod.toJson();
  }
);
```

```javascript
<<setup key>>

app.post('/retrieve-customer-payment-method', async (req, res) => {
  const paymentMethod = await stripe.paymentMethods.retrieve(
    req.body.paymentMethodId
  );

  res.send(paymentMethod);
});
```

```go
<<setup key>>

func handleRetrieveCustomerPaymentMethod(w http.ResponseWriter, r *http.Request) {
  if r.Method != "POST" {
    http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
    return
  }
  var req struct {
    PaymentMethodID string `json:"paymentMethodId"`
  }
  if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("json.NewDecoder.Decode: %v", err)
    return
  }

  pm, err := paymentmethod.Get(req.PaymentMethodID, nil)
  if err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("paymentmethod.Get: %v", err)
    return
  }

  writeJSON(w, pm)
}
```

```dotnet
using Newtonsoft.Json;

public class RetrieveCustomerPaymentMethodRequest
{
    [JsonProperty("paymentMethodId")]
    public string PaymentMethod { get; set; }
}
```

```dotnet
<<setup key>>

[HttpPost("retrieve-customer-payment-method")]
public ActionResult<PaymentMethod> RetrieveCustomerPaymentMethod([FromBody] RetrieveCustomerPaymentMethodRequest req)
{
    var service = new PaymentMethodService();
    var paymentMethod = service.Get(req.PaymentMethod);
    return paymentMethod;
}
```

Example response:

```json
{
  "id": "pm_1GcbHY2eZvKYlo2CoqlVxo42",
  "object": "payment_method",
  "billing_details": {
    "address": {
      "city": null,
      "country": null,
      "line1": null,
      "line2": null,
      "postal_code": null,
      "state": null
    },
    "email": null,
    "name": null,
    "phone": null
  },
  "card": {
    "brand": "visa",
    "checks": {
      "address_line1_check": null,
      "address_postal_code_check": null,
      "cvc_check": "pass"
    },
    "country": "US",
    "exp_month": 8,
    "exp_year": 2021,
    "fingerprint": "Xt5EWLLDS7FJjR1c",
    "funding": "credit",
    "generated_from": null,
    "last4": "4242",
    "three_d_secure_usage": {
      "supported": true
    },
    "wallet": null
  },
  "created": 1588010536,
  "customer": "cus_HAxB7dVQxhoKLh",
  "livemode": false,
  "metadata": {},
  "type": "card"
}
```

We recommend that you save the `paymentMethod.id` and `last4` in your database, for example, `paymentMethod.id` as `stripeCustomerPaymentMethodId` in your `users` collection or table. You can optionally store `exp_month`, `exp_year`, `fingerprint`, `billing_details` as needed. This is to limit the number of calls you make to Stripe, for performance efficiency and to avoid possible rate limiting.

## Disclose Stripe to your customers 

Stripe collects information on customer interactions with Elements to provide services to you, prevent fraud, and improve its services. This includes using cookies and IP addresses to identify which Elements a customer saw during a single checkout session. You’re responsible for disclosing and obtaining all rights and consents necessary for Stripe to use data in these ways. For more information, visit our [privacy center](https://stripe.com/legal/privacy-center#as-a-business-user-what-notice-do-i-provide-to-my-end-customers-about-stripe).

# iOS

> This is a iOS for when platform is ios. View the original doc at https://docs.stripe.com/billing/subscriptions/build-subscriptions?platform=ios.

Customize with the [Appearance API](https://docs.stripe.com/elements/appearance-api.md).

Use this guide to learn how to sell fixed-price *subscriptions*. You’ll use the [Mobile Payment Element](https://docs.stripe.com/payments/accept-a-payment.md?platform=ios) to create a custom payment form that you embed in your app.

If you’re selling digital products or services that are consumed within your app (for example, subscriptions, in-game currencies, game levels, access to premium content, or unlocking a full version), you must use Apple’s in-app purchase APIs. This rule has some exceptions, including one-to-one personal services and [apps based in specific regions](https://support.stripe.com/questions/changes-to-mobile-app-store-rules). See the [App Store review guidelines](https://developer.apple.com/app-store/review/guidelines/#payments) for more information.

## Build your subscription 

This guide shows you how to:

- Model your business by building a product catalog.
- Create a registration process to add customers.
- Create subscriptions and collect payment information.
- Test and monitor the status of payments and subscriptions.
- Let customers change their plan or cancel the subscription.

## How to model it on Stripe

[Subscriptions](https://docs.stripe.com/api/subscriptions.md) simplify your billing by automatically creating *Invoices* and [PaymentIntents](https://docs.stripe.com/api/payment_intents.md) for you.  To create and activate a subscription, you need to first create a *Product* to model what is being sold, and a *Price* which determines the interval and amount to charge. You also need a [Customer](https://docs.stripe.com/api/customers.md) to store *PaymentMethods* used to make each recurring payment.

### API object definitions

| Resource                                                                      | Definition                                                                                                                                                                                                                                                                                                                                                                                                    |
| ----------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [Entitlement](https://docs.stripe.com/api/entitlements/active-entitlement.md) | Represents a customer’s access to a feature included in a service product that they subscribe to. When you create a subscription for a customer’s recurring purchase of a product, an active entitlement is automatically created for each feature associated with that product. When a customer accesses your services, use their active entitlements to enable the features included in their subscription. |
| [Feature](https://docs.stripe.com/api/entitlements/feature.md)                | Represents a function or ability that your customers can access when they subscribe to a service product. You can include features in a product by creating ProductFeatures.                                                                                                                                                                                                                                  |
| [Invoice](https://docs.stripe.com/api/invoices.md)                            | A statement of amounts a customer owes that tracks payment statuses from draft through paid or otherwise finalized. Subscriptions automatically generate invoices.                                                                                                                                                                                                                                            |
| [PaymentIntent](https://docs.stripe.com/api/payment_intents.md)               | A way to build dynamic payment flows. A PaymentIntent tracks the lifecycle of a customer checkout flow and triggers additional authentication steps when required by regulatory mandates, custom Radar fraud rules, or redirect-based payment methods. Invoices automatically create PaymentIntents.                                                                                                          |
| [PaymentMethod](https://docs.stripe.com/api/payment_methods.md)               | A customer’s payment methods that they use to pay for your products. For example, you can store a credit card on a Customer object and use it to make recurring payments for that customer. Typically used with the Payment Intents or Setup Intents APIs.                                                                                                                                                    |
| [Price](https://docs.stripe.com/api/prices.md)                                | Defines the unit price, currency, and billing cycle for a product.                                                                                                                                                                                                                                                                                                                                            |
| [Product](https://docs.stripe.com/api/products.md)                            | A good or service that your business sells. A service product can include one or more features.                                                                                                                                                                                                                                                                                                               |
| [ProductFeature](https://docs.stripe.com/api/product-feature.md)              | Represents a single feature’s inclusion in a single product. Each product is associated with a ProductFeature for each feature that it includes, and each feature is associated with a ProductFeature for each product that includes it.                                                                                                                                                                      |
| [Subscription](https://docs.stripe.com/api/subscriptions.md)                  | Represents a customer’s scheduled recurring purchase of a product. Use a subscription to collect payments and provide repeated delivery of or continuous access to a product.                                                                                                                                                                                                                                 |

Here’s an example of how products, features, and entitlements work together. Imagine that you want to set up a subscription service that offers two tiers: a standard product with basic functionality, and an advanced product that adds extended functionality.

1. You create two features: `basic_features` and `extended_features`.
1. You create two products: `standard_product` and `advanced_product`.
1. For the standard product, you create one ProductFeature that associates `basic_features` with `standard_product`.
1. For the advanced product, you create two ProductFeatures: one that associates `basic_features` with `advanced_product` and one that associates `extended_features` with `advanced_product`.

A customer, `first_customer`, subscribes to the standard product. When you create the subscription, Stripe automatically creates an Entitlement that associates `first_customer` with `basic_features`.

Another customer, `second_customer`, subscribes to the advanced product. When you create the Subscription, Stripe automatically creates two Entitlements: one that associates `second_customer` with `basic_features`, and one that associates `second_customer` with `extended_features`.

You can determine which features to provision for a customer by [retrieving their active entitlements or listening to the Active Entitlement Summary event](https://docs.stripe.com/billing/entitlements.md#entitlements). You don’t have to retrieve their subscriptions, products, and features.

## Set up Stripe

And then install the Stripe CLI. The CLI provides webhook testing and you can run it to make API calls to Stripe.  This guide shows how to use the CLI to set up a pricing model in a later section.

```bash
\# Install Homebrew to run this command: https://brew.sh/
brew install stripe/stripe-cli/stripe

# Connect the CLI to your dashboard
stripe login
```

```bash
\# 1. Download the latest `mac-os` tar.gz file of your cpu architecture type from https://github.com/stripe/stripe-cli/releases/latest

# 2. Tar the downloaded file
tar -xvf stripe_[X.X.X]_mac-os_[ARCH_TYPE].tar.gz

# Optionally, install the binary in a location where you can execute it globally (for example, `/usr/local/bin`).

# Connect the CLI to your dashboard
stripe login
```

To install the Stripe CLI on Debian and Ubuntu-based distributions:

```bash
brew install stripe/stripe-cli/stripe

# Connect the CLI to your dashboard
stripe login
```

On April 5th, 2024, we changed Stripe CLI’s GPG key to install the Stripe CLI through apt. If you configured the public key before April 5th, you’ll encounter this error:

```
W: An error occurred during the signature verification. The repository is not updated and the previous index files will be used. GPG error: https://packages.stripe.dev/stripe-cli-debian-local stable InRelease: The following signatures were invalid: EXPKEYSIG DEEBD57F917C83E3 Stripe <security@stripe.com>
W: Failed to fetch https://packages.stripe.dev/stripe-cli-debian-local/dists/stable/InRelease  The following signatures were invalid: EXPKEYSIG DEEBD57F917C83E3 Stripe <security@stripe.com>
W: Some index files failed to download. They have been ignored, or old ones used instead
```

To resolve this error, refresh Stripe’s GPG key by following step 1.

To install the Stripe CLI on Debian and Ubuntu-based distributions:

```bash
\# 1. Add Stripe CLI's GPG key to the apt sources keyring:
curl -s https://packages.stripe.dev/api/security/keypair/stripe-cli-gpg/public | gpg --dearmor | sudo tee /usr/share/keyrings/stripe.gpg

# 2. Add CLI's apt repository to the apt sources list:
echo "deb [signed-by=/usr/share/keyrings/stripe.gpg] https://packages.stripe.dev/stripe-cli-debian-local stable main" | sudo tee -a /etc/apt/sources.list.d/stripe.list

# 3. Update the package list
sudo apt update

# 4. Install the CLI
sudo apt install stripe

# 5. Connect the CLI to your dashboard
stripe login
```

```bash
\# 1. Add CLI's yum repository to the yum sources list:
echo -e "[Stripe]\nname=stripe\nbaseurl=https://packages.stripe.dev/stripe-cli-rpm-local/\nenabled=1\ngpgcheck=0" >> /etc/yum.repos.d/stripe.repo

# 2. Install the CLI
sudo yum install stripe
```

```bash
\# Download the latest `linux` tar.gz file from <https://github.com/stripe/stripe-cli/releases/latest>

# Unzip the file:
tar -xvf stripe_X.X.X_linux_x86_64.tar.gz

# Move `./stripe` to your execution path.

# Connect the CLI to your dashboard
stripe login
```

```bash
\# 1. Download the latest `windows` zip file from
# https://github.com/stripe/stripe-cli/releases/latest

# 2. Unzip the `stripe_X.X.X_windows_x86_64.zip` file

# 3. Run the unzipped `.exe` file

# Connect the CLI to your dashboard
stripe login
```

```bash
\# See https://scoop.sh

scoop bucket add stripe https://github.com/stripe/scoop-stripe-cli.git

scoop install stripe
```

For additional install options, see [Get started with the Stripe CLI](https://docs.stripe.com/stripe-cli.md).

## Create the pricing model

## Create the customer

Stripe needs a *customer* for each subscription.  In your application frontend, collect any necessary information from your users and pass it to the backend.

If you need to collect address details, the Address Element enables you to collect a shipping or billing address for your customers. For more information on the Address Element, visit the [Address Element](https://docs.stripe.com/elements/address-element.md) page.

On the server, create the Stripe customer object.

```dotnet
StripeConfiguration.ApiKey = "<<secret key>>";

var options = new CustomerCreateOptions
{
    Email = "{{CUSTOMER_EMAIL}}",
    Name = "{{CUSTOMER_NAME}}",
    Shipping = new ShippingOptions
    {
        Address = new AddressOptions
        {
            City = "Brothers",
            Country = "US",
            Line1 = "27 Fredrick Ave",
            PostalCode = "97712",
            State = "CA",
        },
        Name = "{{CUSTOMER_NAME}}",
    },
    Address = new AddressOptions
    {
        City = "Brothers",
        Country = "US",
        Line1 = "27 Fredrick Ave",
        PostalCode = "97712",
        State = "CA",
    },
};
var service = new CustomerService();
Customer customer = service.Create(options);
```

```go
stripe.Key = "<<secret key>>"

params := &stripe.CustomerParams{
  Email: stripe.String("{{CUSTOMER_EMAIL}}"),
  Name: stripe.String("{{CUSTOMER_NAME}}"),
  Shipping: &stripe.CustomerShippingParams{
    Address: &stripe.AddressParams{
      City: stripe.String("Brothers"),
      Country: stripe.String("US"),
      Line1: stripe.String("27 Fredrick Ave"),
      PostalCode: stripe.String("97712"),
      State: stripe.String("CA"),
    },
    Name: stripe.String("{{CUSTOMER_NAME}}"),
  },
  Address: &stripe.AddressParams{
    City: stripe.String("Brothers"),
    Country: stripe.String("US"),
    Line1: stripe.String("27 Fredrick Ave"),
    PostalCode: stripe.String("97712"),
    State: stripe.String("CA"),
  },
};
result, err := customer.New(params);
```

```java
Stripe.apiKey = "<<secret key>>";

CustomerCreateParams params =
  CustomerCreateParams.builder()
    .setEmail("{{CUSTOMER_EMAIL}}")
    .setName("{{CUSTOMER_NAME}}")
    .setShipping(
      CustomerCreateParams.Shipping.builder()
        .setAddress(
          CustomerCreateParams.Shipping.Address.builder()
            .setCity("Brothers")
            .setCountry("US")
            .setLine1("27 Fredrick Ave")
            .setPostalCode("97712")
            .setState("CA")
            .build()
        )
        .setName("{{CUSTOMER_NAME}}")
        .build()
    )
    .setAddress(
      CustomerCreateParams.Address.builder()
        .setCity("Brothers")
        .setCountry("US")
        .setLine1("27 Fredrick Ave")
        .setPostalCode("97712")
        .setState("CA")
        .build()
    )
    .build();

Customer customer = Customer.create(params);
```

```node
const stripe = require('stripe')('<<secret key>>');

const customer = await stripe.customers.create({
  email: '{{CUSTOMER_EMAIL}}',
  name: '{{CUSTOMER_NAME}}',
  shipping: {
    address: {
      city: 'Brothers',
      country: 'US',
      line1: '27 Fredrick Ave',
      postal_code: '97712',
      state: 'CA',
    },
    name: '{{CUSTOMER_NAME}}',
  },
  address: {
    city: 'Brothers',
    country: 'US',
    line1: '27 Fredrick Ave',
    postal_code: '97712',
    state: 'CA',
  },
});
```

```python
import stripe
stripe.api_key = "<<secret key>>"

customer = stripe.Customer.create(
  email="{{CUSTOMER_EMAIL}}",
  name="{{CUSTOMER_NAME}}",
  shipping={
    "address": {
      "city": "Brothers",
      "country": "US",
      "line1": "27 Fredrick Ave",
      "postal_code": "97712",
      "state": "CA",
    },
    "name": "{{CUSTOMER_NAME}}",
  },
  address={
    "city": "Brothers",
    "country": "US",
    "line1": "27 Fredrick Ave",
    "postal_code": "97712",
    "state": "CA",
  },
)
```

```php
$stripe = new \Stripe\StripeClient('<<secret key>>');

$customer = $stripe->customers->create([
  'email' => '{{CUSTOMER_EMAIL}}',
  'name' => '{{CUSTOMER_NAME}}',
  'shipping' => [
    'address' => [
      'city' => 'Brothers',
      'country' => 'US',
      'line1' => '27 Fredrick Ave',
      'postal_code' => '97712',
      'state' => 'CA',
    ],
    'name' => '{{CUSTOMER_NAME}}',
  ],
  'address' => [
    'city' => 'Brothers',
    'country' => 'US',
    'line1' => '27 Fredrick Ave',
    'postal_code' => '97712',
    'state' => 'CA',
  ],
]);
```

```ruby
Stripe.api_key = '<<secret key>>'

customer = Stripe::Customer.create({
  email: '{{CUSTOMER_EMAIL}}',
  name: '{{CUSTOMER_NAME}}',
  shipping: {
    address: {
      city: 'Brothers',
      country: 'US',
      line1: '27 Fredrick Ave',
      postal_code: '97712',
      state: 'CA',
    },
    name: '{{CUSTOMER_NAME}}',
  },
  address: {
    city: 'Brothers',
    country: 'US',
    line1: '27 Fredrick Ave',
    postal_code: '97712',
    state: 'CA',
  },
})
```

## Create the subscription

If you want to render the Payment Element without first creating a subscription, see [Collect payment details before creating an Intent](https://docs.stripe.com/payments/accept-a-payment-deferred.md?type=subscription).

Let your new customer choose a plan and then create the subscription—in this guide, they choose between Basic and Premium.

In your app, pass the selected price ID and the ID of the customer record to the backend.

On the backend, create the subscription with status `incomplete` using `payment_behavior=default_incomplete`. Then return the `client_secret` from the subscription’s first [payment intent](https://docs.stripe.com/payments/payment-intents.md) to the frontend to complete payment by expanding the[`confirmation_secret`](https://docs.stripe.com/api/invoices/object.md#invoice_object-confirmation_secret) on the latest invoice of the subscription.

Set [save_default_payment_method](https://docs.stripe.com/api/subscriptions/object.md#subscription_object-payment_settings-save_default_payment_method) to `on_subscription` to save the payment method as the default for a subscription when a payment succeeds. Saving a default payment method increases the success rate of future subscription payments.

```ruby
<<setup key>>

post '/create-subscription' do
  content_type 'application/json'
  data = JSON.parse(request.body.read)
  customer_id = cookies[:customer]
  price_id = data['priceId']

  # Create the subscription. Note we're expanding the Subscription's
  # latest invoice and that invoice's confirmation_secret
  # so we can pass it to the front end to confirm the payment
  subscription = Stripe::Subscription.create(
    customer: customer_id,
    items: [{
      price: price_id,
    }],
    payment_behavior: 'default_incomplete',
    payment_settings: {save_default_payment_method: 'on_subscription'},
    expand: ['latest_invoice.confirmation_secret']
  )

  { subscriptionId: subscription.id, clientSecret: subscription.latest_invoice.confirmation_secret.client_secret }.to_json
end
```

```python
<<setup key>>

@app.route('/create-subscription', methods=['POST'])
def create_subscription():
    data = json.loads(request.data)
    customer_id = data['customerId']
    price_id = data['priceId']

    try:
        # Create the subscription. Note we're expanding the Subscription's
        # latest invoice and that invoice's confirmation_secret
        # so we can pass it to the front end to confirm the payment
        subscription = stripe.Subscription.create(
            customer=customer_id,
            items=[{
                'price': price_id,
            }],
            payment_behavior='default_incomplete',
            payment_settings={'save_default_payment_method': 'on_subscription'},
            expand=['latest_invoice.confirmation_secret'],
        )
        return jsonify(subscriptionId=subscription.id, clientSecret=subscription.latest_invoice.confirmation_secret.client_secret)

    except Exception as e:
        return jsonify(error={'message': e.user_message}), 400
```

```php
<<setup key>>

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    // Get the request body and decode it as JSON.
    $body = file_get_contents('php://input');
    $json = json_decode($body);

    // Get the customer ID from the cookie and the price ID from the JSON data.
    $customer_id = $_COOKIE['customer'];
    $price_id = $json->priceId;

    // Create the subscription with the customer ID, price ID, and necessary options.
    $subscription = $stripe->subscriptions->create([
        'customer' => $customer_id,
        'items' => [[
            'price' => $price_id,
        ]],
        'payment_behavior' => 'default_incomplete',
        'payment_settings' => ['save_default_payment_method' => 'on_subscription'],
        'expand' => ['latest_invoice.confirmation_secret'],
    ]);

    // Return the subscription ID and client secret as a JSON response.
    header('Content-Type: application/json');
    echo json_encode([
        'subscriptionId' => $subscription->id,
        'clientSecret' => $subscription->latest_invoice->confirmation_secret->client_secret,
    ]);
}
```

```java
<<setup key>>

post(
  "/create-subscription",
  (request, response) -> {
    response.type("application/json");
    String customerId = request.cookie("customer");
    CreateSubscriptionRequest postBody = gson.fromJson(
      request.body(),
      CreateSubscriptionRequest.class
    );
    String priceId = postBody.getPriceId();

    // Automatically save the payment method to the subscription
    // when the first payment is successful.
    SubscriptionCreateParams.PaymentSettings paymentSettings =
      SubscriptionCreateParams.PaymentSettings
        .builder()
        .setSaveDefaultPaymentMethod(SaveDefaultPaymentMethod.ON_SUBSCRIPTION)
        .build();

    // Create the subscription. Note we're expanding the Subscription's
    // latest invoice and that invoice's confirmation_secret
    // so we can pass it to the front end to confirm the payment
    SubscriptionCreateParams subCreateParams = SubscriptionCreateParams
      .builder()
      .setCustomer(customerId)
      .addItem(
        SubscriptionCreateParams
          .Item.builder()
          .setPrice(priceId)
          .build()
      )
      .setPaymentSettings(paymentSettings)
      .setPaymentBehavior(SubscriptionCreateParams.PaymentBehavior.DEFAULT_INCOMPLETE)
      .addAllExpand(Arrays.asList("latest_invoice.confirmation_secret"))
      .build();

    Subscription subscription = Subscription.create(subCreateParams);

    Map<String, Object> responseData = new HashMap<>();
    responseData.put("subscriptionId", subscription.getId());
    responseData.put("clientSecret", subscription.getLatestInvoiceObject().getConfirmationSecret().getClientSecret());
    return StripeObject.PRETTY_PRINT_GSON.toJson(responseData);
  }
);
```

```javascript
<<setup key>>

app.post('/create-subscription', async (req, res) => {
  const customerId = req.cookies['customer'];
  const priceId = req.body.priceId;

  try {
    // Create the subscription. Note we're expanding the Subscription's
    // latest invoice and that invoice's confirmation_secret
    // so we can pass it to the front end to confirm the payment
    const subscription = await stripe.subscriptions.create({
      customer: customerId,
      items: [{
        price: priceId,
      }],
      payment_behavior: 'default_incomplete',
      payment_settings: { save_default_payment_method: 'on_subscription' },
      expand: ['latest_invoice.confirmation_secret'],
    });

    res.send({
      subscriptionId: subscription.id,
      clientSecret: subscription.latest_invoice.confirmation_secret.client_secret,
    });
  } catch (error) {
    return res.status(400).send({ error: { message: error.message } });
  }
});
```

```go
<<setup key>>

func handleCreateSubscription(w http.ResponseWriter, r *http.Request) {
    if r.Method != "POST" {
        http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
        return
    }

    var req struct {
        PriceID string `json:"priceId"`
    }

    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        writeJSON(w, nil, err)
        log.Printf("json.NewDecoder.Decode: %v", err)
        return
    }

    cookie, _ := r.Cookie("customer")
    customerID := cookie.Value

    // Automatically save the payment method to the subscription
    // when the first payment is successful.
    paymentSettings := &stripe.SubscriptionPaymentSettingsParams{
		    SaveDefaultPaymentMethod: stripe.String("on_subscription"),
  	}

    // Create the subscription. Note we're expanding the Subscription's
    // latest invoice and that invoice's confirmation_secret
    // so we can pass it to the front end to confirm the payment
    subscriptionParams := &stripe.SubscriptionParams{
        Customer: stripe.String(customerID),
        Items: []*stripe.SubscriptionItemsParams{
            {
                Price: stripe.String(req.PriceID),
            },
        },
        PaymentSettings: paymentSettings,
        PaymentBehavior: stripe.String("default_incomplete"),
    }
    subscriptionParams.AddExpand("latest_invoice.confirmation_secret")
    s, err := subscription.New(subscriptionParams)

    if err != nil {
        writeJSON(w, nil, err)
        log.Printf("subscription.New: %v", err)
        return
    }

    writeJSON(w, struct {
        SubscriptionID string `json:"subscriptionId"`
        ClientSecret string `json:"clientSecret"`
    }{
        SubscriptionID: s.ID,
        ClientSecret: s.LatestInvoice.ConfirmationSecret.ClientSecret,
    }, nil)
}
```

```dotnet
<<setup key>>

[HttpPost("create-subscription")]
public ActionResult<SubscriptionCreateResponse> CreateSubscription([FromBody] CreateSubscriptionRequest req)
{
    var customerId = HttpContext.Request.Cookies["customer"];

    // Automatically save the payment method to the subscription
    // when the first payment is successful.
    var paymentSettings = new SubscriptionPaymentSettingsOptions {
        SaveDefaultPaymentMethod = "on_subscription",
    };

    // Create the subscription. Note we're expanding the Subscription's
    // latest invoice and that invoice's confirmation_secret
    // so we can pass it to the front end to confirm the payment
    var subscriptionOptions = new SubscriptionCreateOptions
    {
        Customer = customerId,
        Items = new List<SubscriptionItemOptions>
        {
            new SubscriptionItemOptions
            {
                Price = req.PriceId,
            },
        },
        PaymentSettings = paymentSettings,
        PaymentBehavior = "default_incomplete",
    };
    subscriptionOptions.AddExpand("latest_invoice.confirmation_secret");
    var subscriptionService = new SubscriptionService();
    try
    {
        Subscription subscription = subscriptionService.Create(subscriptionOptions);

        return new SubscriptionCreateResponse
        {
          SubscriptionId = subscription.Id,
          ClientSecret = subscription.LatestInvoice.ConfirmationSecret.ClientSecret,
        };
    }
    catch (StripeException e)
    {
        Console.WriteLine($"Failed to create subscription.{e}");
        return BadRequest();
    }
}
```

If you’re using a *multi-currency Price*, use the [currency](https://docs.stripe.com/api/subscriptions/create.md#create_subscription-currency) parameter to tell the Subscription which of the Price’s currencies to use. (If you omit the `currency` parameter, then the Subscription uses the Price’s default currency.)

At this point the Subscription is `inactive` and awaiting payment. Here’s an example response. The minimum fields to store are highlighted, but store whatever your application frequently accesses.

```json
{
  "id": "sub_JgRjFjhKbtD2qz",
  "object": "subscription",
  "application_fee_percent": null,
  "automatic_tax": {
    "disabled_reason": null,
    "enabled": false,
    "liability": "null"
  },
  "billing_cycle_anchor": 1623873347,
  "billing_cycle_anchor_config": null,
  "cancel_at": null,
  "cancel_at_period_end": false,
  "canceled_at": null,
  "cancellation_details": {
    comment: null,
    feedback: null,
    reason: null
  },
  "collection_method": "charge_automatically",
  "created": 1623873347,
  "currency": "usd
  "customer": "cus_CMqDWO2xODTZqt",
  "days_until_due": null,
  "default_payment_method": null,
  "default_source": null,
  "default_tax_rates": [

  ],
  "discounts": [],
  "ended_at": null,
  "invoice_customer_balance_settings": {
    "account_tax_ids": null,
    issuer: {
      type: "self"
    }
  },
  "items": {
    "object": "list",
    "data": [
      {
        "id": "si_JgRjmS4Ur1khEx",
        "object": "subscription_item",
        "created": 1623873347,
        "current_period_end": 1626465347,
        "current_period_start": 1623873347,
        discounts: [],
        "metadata": {
        },
        "plan": {
          "id": "price_1J32RfGPZ1iASj5zHHp57z7C",
          "object": "plan",
          "active": true,
          "amount": 2000,
          "amount_decimal": "2000",
          "billing_scheme": "per_unit",
          "created": 1623864151,
          "currency": "usd",
          "interval": "month",
          "interval_count": 1,
          "livemode": false,
          "metadata": {
          },
          "nickname": null,
          "product": "prod_JgPF5xnq7qBun3",
          "tiers": null,
          "tiers_mode": null,
          "transform_usage": null,
          "trial_period_days": null,
          "usage_type": "licensed"
        },
        "price": {
          "id": "price_1J32RfGPZ1iASj5zHHp57z7C",
          "object": "price",
          "active": true,
          "billing_scheme": "per_unit",
          "created": 1623864151,
          "currency": "usd",
          "livemode": false,
          "lookup_key": null,
          "metadata": {
          },
          "nickname": null,
          "product": "prod_JgPF5xnq7qBun3",
          "recurring": {
            "interval": "month",
            "interval_count": 1,
            "trial_period_days": null,
            "usage_type": "licensed"
          },
          "tiers_mode": null,
          "transform_quantity": null,
          "type": "recurring",
          "unit_amount": 2000,
          "unit_amount_decimal": "2000"
        },
        "quantity": 1,
        "subscription": "sub_JgRjFjhKbtD2qz",
        "tax_rates": [

        ]
      }
    ],
    "has_more": false,
    "total_count": 1,
    "url": "/v1/subscription_items?subscription=sub_JgRjFjhKbtD2qz"
  },
  "latest_invoice": {
    "id": "in_1J34pzGPZ1iASj5zB87qdBNZ",
    "object": "invoice",
    "account_country": "US",
    "account_name": "Angelina's Store",
    "account_tax_ids": null,
    "amount_due": 2000,
    "amount_overpaid": 0,
    "amount_paid": 0,
    "amount_remaining": 2000,
    "amount_shipping": 0,
    "attempt_count": 0,
    "attempted": false,
    "auto_advance": false,
    "automatic_tax": {
      "disabled_reason": null,
      "enabled": false,
      liability: null,
      "status": null
    },
    "automatically_finalizes_at": null,
    "billing_reason": "subscription_update",
    "collection_method": "charge_automatically",
    "created": 1623873347,
    "currency": "usd",
    "custom_fields": null,
    "customer": "cus_CMqDWO2xODTZqt",
    "customer_address": null,
    "customer_email": "angelina@stripe.com",
    "customer_name": null,
    "customer_phone": null,
    "customer_shipping": {
      "address": {
        "city": "",
        "country": "US",
        "line1": "Berry",
        "line2": "",
        "postal_code": "",
        "state": ""
      },
      "name": "",
      "phone": null
    },
    "customer_tax_exempt": "none",
    "customer_tax_ids": [

    ],
    "default_payment_method": null,
    "default_source": null,
    "default_tax_rates": [

    ],
    "description": null,
    "discounts": [],
    "due_date": null,
    "effective_at": "1623873347
    "ending_balance": 0,
    "footer": null,
    "from_invoice": null,
    "hosted_invoice_url": "https://invoice.stripe.com/i/acct_1By64KGPZ1iASj5z/invst_JgRjzIOILGeq2MKC9T0KtyXnD5udsLp",
    "invoice_pdf": "https://pay.stripe.com/invoice/acct_1By64KGPZ1iASj5z/invst_JgRjzIOILGeq2MKC9T0KtyXnD5udsLp/pdf",
    "last_finalization_error": null,
    "latest_revision": null,
    "lines": {
      "object": "list",
      "data": [
        {
          "id": "il_1N2CjMBwKQ696a5NeOawRQP2",
          "object": "line_item",
          "amount": 2000,
          "currency": "usd",
          "description": "1 × Gold Special (at $20.00 / month)",
          "discount_amounts": [

          ],
          "discountable": true,
          "discounts": [

          ],
          "invoice": "in_1J34pzGPZ1iASj5zB87qdBNZ",
          "livemode": false,
          "metadata": {
          },
          "parent": {
            "invoice_item_details": null,
            "subscription_item_details":
            {
              "invoice_item": null
            "proration": false
            "proration_details":
            {
              "credited_items": null
            }
            subscription:
            "sub_JgRjFjhKbtD2qz"
            subscription_item:
              "si_JgRjmS4Ur1khEx"
            }
            type: "subscription_item_details"
          },
          "period": {
            "end": 1626465347,
            "start": 1623873347
          },
          "plan": {
            "id": "price_1J32RfGPZ1iASj5zHHp57z7C",
            "object": "plan",
            "active": true,
            "amount": 2000,
            "amount_decimal": "2000",
            "billing_scheme": "per_unit",
            "created": 1623864151,
            "currency": "usd",
            "interval": "month",
            "interval_count": 1,
            "livemode": false,
            "metadata": {
            },
            "nickname": null,
            "product": "prod_JgPF5xnq7qBun3",
            "tiers": null,
            "tiers_mode": null,
            "transform_usage": null,
            "trial_period_days": null,
            "usage_type": "licensed"
          },
          "price": {
            "id": "price_1J32RfGPZ1iASj5zHHp57z7C",
            "object": "price",
            "active": true,
            "billing_scheme": "per_unit",
            "created": 1623864151,
            "currency": "usd",
            "livemode": false,
            "lookup_key": null,
            "metadata": {
            },
            "nickname": null,
            "product": "prod_JgPF5xnq7qBun3",
            "recurring": {
              "interval": "month",
              "interval_count": 1,
              "trial_period_days": null,
              "usage_type": "licensed"
            },
            "tiers_mode": null,
            "transform_quantity": null,
            "type": "recurring",
            "unit_amount": 2000,
            "unit_amount_decimal": "2000"
          },
          "quantity": 1,
          "taxes": [],
        }
      ],
      "has_more": false,
      "total_count": 1,
      "url": "/v1/invoices/in_1J34pzGPZ1iASj5zB87qdBNZ/lines"
    },
    "livemode": false,
    "metadata": {
    },
    "next_payment_attempt": null,
    "number": "C008FC2-0354",
    "on_behalf_of": null,
    "parent": {
      "quote_details": null,
      "subscription_details": {
        "metadata": {},
        "pause_collection": null,
        "subscription": "sub_JgRjFjhKbtD2qz",
      }
    }
    "payment_intent": {
      "id": "pi_1J34pzGPZ1iASj5zI2nOAaE6",
      "object": "payment_intent",
      "allowed_source_types": [
        "card"
      ],
      "amount": 2000,
      "amount_capturable": 0,
      "amount_received": 0,
      "application": null,
      "application_fee_amount": null,
      "canceled_at": null,
      "cancellation_reason": null,
      "capture_method": "automatic",
      "charges": {
        "object": "list",
        "data": [

        ],
        "has_more": false,
        "total_count": 0,
        "url": "/v1/charges?payment_intent=pi_1J34pzGPZ1iASj5zI2nOAaE6"
      },
      "client_secret": "pi_1J34pzGPZ1iASj5zI2nOAaE6_secret_l7FN6ldFfXiFmJEumenJ2y2wu",
      "confirmation_method": "automatic",
      "created": 1623873347,
      "currency": "usd",
      "customer": "cus_CMqDWO2xODTZqt",
      "description": "Subscription creation",
      "invoice": "in_1J34pzGPZ1iASj5zB87qdBNZ",
      "last_payment_error": null,
      "livemode": false,
      "metadata": {
      },
      "next_action": null,
      "next_source_action": null,
      "on_behalf_of": null,
      "payment_method": null,
      "payment_method_options": {
        "card": {
          "installments": null,
          "network": null,
          "request_three_d_secure": "automatic"
        }
      },
      "payment_method_types": [
        "card"
      ],
      "receipt_email": null,
      "review": null,
      "setup_future_usage": "off_session",
      "shipping": null,
      "source": "card_1By6iQGPZ1iASj5z7ijKBnXJ",
      "statement_descriptor": null,
      "statement_descriptor_suffix": null,
      "status": "requires_confirmation",
      "transfer_data": null,
      "transfer_group": null
    },
    "payment_settings": {
      "payment_method_options": null,
      "payment_method_types": null,
      "save_default_payment_method": "on_subscription"
    },
    "period_end": 1623873347,
    "period_start": 1623873347,
    "post_payment_credit_notes_amount": 0,
    "pre_payment_credit_notes_amount": 0,
    "receipt_number": null,
    "starting_balance": 0,
    "statement_descriptor": null,
    "status": "open",
    "status_transitions": {
      "finalized_at": 1623873347,
      "marked_uncollectible_at": null,
      "paid_at": null,
      "voided_at": null
    },
    "subscription": "sub_JgRjFjhKbtD2qz",
    "subtotal": 2000,
    "tax": null,
    "tax_percent": null,
    "total": 2000,
    "total_discount_amounts": [],
    "total_tax_amounts": [],
    "transfer_data": null,
    "webhooks_delivered_at": 1623873347
  },
  "livemode": false,
  "metadata": {
  },
  "next_pending_invoice_item_invoice": null,
  "pause_collection": null,
  "pending_invoice_item_interval": null,
  "pending_setup_intent": null,
  "pending_update": null,
  "plan": {
    "id": "price_1J32RfGPZ1iASj5zHHp57z7C",
    "object": "plan",
    "active": true,
    "amount": 2000,
    "amount_decimal": "2000",
    "billing_scheme": "per_unit",
    "created": 1623864151,
    "currency": "usd",
    "interval": "month",
    "interval_count": 1,
    "livemode": false,
    "metadata": {
    },
    "nickname": null,
    "product": "prod_JgPF5xnq7qBun3",
    "tiers": null,
    "tiers_mode": null,
    "transform_usage": null,
    "trial_period_days": null,
    "usage_type": "licensed"
  },
  "quantity": 1,
  "schedule": null,
  "start": 1623873347,
  "start_date": 1623873347,
  "status": "incomplete",
  "tax_percent": null,
  "transfer_data": null,
  "trial_end": null,
  "trial_start": null
}
```

## Collect payment information

Use the [Mobile Payment Element](https://docs.stripe.com/payments/elements/mobile-payment-element.md) to collect payment details and activate the subscription. You can customize Elements to match the look and feel of your application.

The Mobile Payment Element securely collects all necessary payment details for a wide variety of payments methods. Learn about the [supported payment methods](https://docs.stripe.com/payments/payment-methods/payment-method-support.md#product-support) for Mobile Payment Element and Subscriptions.

### Add the Payment Element to your app

This step shows one way to get started, but you can use any [in-app payments integration](https://docs.stripe.com/payments/mobile/integration.md).

Initialize and present the Mobile Payment Element using the PaymentSheet class.

The Mobile Payment Element renders a sheet that allows your customer to select a payment method. The form automatically collects all necessary payments details for the payment method that they select.

Setting `allowsDelayedPaymentMethods` to true allows [delayed notification](https://docs.stripe.com/payments/payment-methods.md#payment-notification) payment methods like US bank accounts. For these payment methods, the final payment status isn’t known when the `PaymentSheet` completes, and instead succeeds or fails later. If you support these types of payment methods, inform the customer their order is confirmed and only fulfill their order (for example, ship their product) when the payment is successful.

You can customize the Payment Element to match the design of your app by using the [`appearance` property](https://docs.stripe.com/elements/appearance-api.md?platform=ios) your `PaymentSheet.Configuration` object.

### Confirm payment 

The Mobile Payment Element creates a PaymentMethod and confirms the incomplete Subscription’s first PaymentIntent, causing a charge to be made. If *Strong Customer Authentication* (SCA) is required for the payment, the Payment Element handles the authentication process before confirming the PaymentIntent.

## Listen for webhooks

To complete the integration, you need to process *webhooks* sent by Stripe. These are events triggered whenever state inside of Stripe changes, such as subscriptions creating new invoices. In your application, set up an HTTP handler to accept a POST request containing the webhook event, and verify the signature of the event:

```ruby
<<setup key>>

post '/webhook' do
  # You can use webhooks to receive information about asynchronous payment events.
  # For more about our webhook events check out https://stripe.com/docs/webhooks.
  webhook_secret = ENV['STRIPE_WEBHOOK_SECRET']
  payload = request.body.read
  if !webhook_secret.empty?
    # Retrieve the event by verifying the signature using the raw body and secret if webhook signing is configured.
    sig_header = request.env['HTTP_STRIPE_SIGNATURE']
    event = nil

    begin
      event = Stripe::Webhook.construct_event(
        payload, sig_header, webhook_secret
      )
    rescue JSON::ParserError => e
      # Invalid payload
      status 400
      return
    rescue Stripe::SignatureVerificationError => e
      # Invalid signature
      puts '⚠️  Webhook signature verification failed.'
      status 400
      return
    end
  else
    data = JSON.parse(payload, symbolize_names: true)
    event = Stripe::Event.construct_from(data)
  end
  # Get the type of webhook event sent - used to check the status of PaymentIntents.
  event_type = event['type']
  data = event['data']
  data_object = data['object']

  if event_type == 'invoice.paid'
    # Used to provision services after the trial has ended.
    # The status of the invoice will show up as paid. Store the status in your
    # database to reference when a user accesses your service to avoid hitting rate
    # limits.
    # puts data_object
  end

  if event_type == 'invoice.payment_failed'
    # If the payment fails or the customer does not have a valid payment method,
    # an invoice.payment_failed event is sent, the subscription becomes past_due.
    # Use this webhook to notify your user that their payment has
    # failed and to retrieve new card details.
    # puts data_object
  end

  if event_type == 'customer.subscription.deleted'
    # handle subscription canceled automatically based
    # upon your subscription settings. Or if the user cancels it.
    # puts data_object
  end

  content_type 'application/json'
  { status: 'success' }.to_json
end
```

```python
<<setup key>>

@app.route('/webhook', methods=['POST'])
def webhook_received():
  # You can use webhooks to receive information about asynchronous payment events.
  # For more about our webhook events check out https://stripe.com/docs/webhooks.
  webhook_secret = os.getenv('STRIPE_WEBHOOK_SECRET')
  request_data = json.loads(request.data)

  if webhook_secret:
    # Retrieve the event by verifying the signature using the raw body and secret if webhook signing is configured.
    signature = request.headers.get('stripe-signature')
    try:
      event = stripe.Webhook.construct_event(
        payload=request.data, sig_header=signature, secret=webhook_secret)
      data = event['data']
    except Exception as e:
      return e
    # Get the type of webhook event sent - used to check the status of PaymentIntents.
    event_type = event['type']
  else:
    data = request_data['data']
    event_type = request_data['type']

  data_object = data['object']

  if event_type == 'invoice.paid':
    # Used to provision services after the trial has ended.
    # The status of the invoice will show up as paid. Store the status in your
    # database to reference when a user accesses your service to avoid hitting rate
    # limits.
    print(data)

  if event_type == 'invoice.payment_failed':
    # If the payment fails or the customer does not have a valid payment method,
    # an invoice.payment_failed event is sent, the subscription becomes past_due.
    # Use this webhook to notify your user that their payment has
    # failed and to retrieve new card details.
    print(data)

  if event_type == 'customer.subscription.deleted':
    # handle subscription canceled automatically based
    # upon your subscription settings. Or if the user cancels it.
    print(data)

  return jsonify({'status': 'success'})
```

```php
<<setup key>>

$event = null;
$payload = @file_get_contents('php://input');
$sig_header = $_SERVER['HTTP_STRIPE_SIGNATURE'];
$webhook_secret = '{{STRIPE_WEBHOOK_SECRET}}';
try {
  $event = \Stripe\Webhook::constructEvent(
    $payload, $sig_header, $webhook_secret
  );
} catch(\UnexpectedValueException $e) {
  // Invalid payload
  http_response_code(400);
  exit();
} catch(\Stripe\Exception\SignatureVerificationException $e) {
  // Invalid signature
  http_response_code(400);
  exit();
}

// Handle the event
// Review important events for Billing webhooks
// https://stripe.com/docs/billing/webhooks
// Remove comment to see the various objects sent for this sample
switch ($event->type) {
  case 'invoice.paid':
    // The status of the invoice will show up as paid. Store the status in your
    // database to reference when a user accesses your service to avoid hitting rate
    // limits.
    break;
  case 'invoice.payment_failed':
    // If the payment fails or the customer does not have a valid payment method,
    // an invoice.payment_failed event is sent, the subscription becomes past_due.
    // Use this webhook to notify your user that their payment has
    // failed and to retrieve new card details.
    break;
  case 'customer.subscription.deleted':
    // handle subscription canceled automatically based
    // upon your subscription settings. Or if the user
    // cancels it.
    break;
  // ... handle other event types
  default:
    // Unhandled event type
}

http_response_code(200);
```

```java
<<setup key>>

post(
  "/webhook",
  (request, response) -> {
    String payload = request.body();
    String sigHeader = request.headers("Stripe-Signature");
    String endpointSecret = dotenv.get("STRIPE_WEBHOOK_SECRET");
    Event event = null;

    try {
      event = Webhook.constructEvent(payload, sigHeader, endpointSecret);
    } catch (SignatureVerificationException e) {
      // Invalid signature
      response.status(400);
      return "";
    }

    // Deserialize the nested object inside the event
    EventDataObjectDeserializer dataObjectDeserializer = event.getDataObjectDeserializer();
    StripeObject stripeObject = null;
    if (dataObjectDeserializer.getObject().isPresent()) {
      stripeObject = dataObjectDeserializer.getObject().get();
    } else {
      // Deserialization failed, probably due to an API version mismatch.
      // Refer to the Javadoc documentation on `EventDataObjectDeserializer` for
      // instructions on how to handle this case, or return an error here.
    }

    switch (event.getType()) {
      case "invoice.paid":
        // Used to provision services after the trial has ended.
        // The status of the invoice will show up as paid. Store the status in your
        // database to reference when a user accesses your service to avoid hitting rate
        // limits.
        break;
      case "invoice.payment_failed":
        // If the payment fails or the customer does not have a valid payment method,
        // an invoice.payment_failed event is sent, the subscription becomes past_due.
        // Use this webhook to notify your user that their payment has
        // failed and to retrieve new card details.
        break;
      case "customer.subscription.deleted":
        // handle subscription canceled automatically based
        // upon your subscription settings. Or if the user
        // cancels it.
        break;
      default:
      // Unhandled event type
    }

    response.status(200);
    return "";
  }
);
```

```javascript
<<setup key>>

app.post(
  '/webhook',
  bodyParser.raw({ type: 'application/json' }),
  async (req, res) => {
    // Retrieve the event by verifying the signature using the raw body and secret.
    let event;

    try {
      event = stripe.webhooks.constructEvent(
        req.body,
        req.headers['stripe-signature'],
        process.env.STRIPE_WEBHOOK_SECRET
      );
    } catch (err) {
      console.log(err);
      console.log(`⚠️  Webhook signature verification failed.`);
      console.log(
        `⚠️  Check the env file and enter the correct webhook secret.`
      );
      return res.sendStatus(400);
    }
    // Extract the object from the event.
    const dataObject = event.data.object;

    // Handle the event
    // Review important events for Billing webhooks
    // https://stripe.com/docs/billing/webhooks
    // Remove comment to see the various objects sent for this sample
    switch (event.type) {
      case 'invoice.paid':
        // Used to provision services after the trial has ended.
        // The status of the invoice will show up as paid. Store the status in your
        // database to reference when a user accesses your service to avoid hitting rate limits.
        break;
      case 'invoice.payment_failed':
        // If the payment fails or the customer does not have a valid payment method,
        //  an invoice.payment_failed event is sent, the subscription becomes past_due.
        // Use this webhook to notify your user that their payment has
        // failed and to retrieve new card details.
        break;
      case 'customer.subscription.deleted':
        if (event.request != null) {
          // handle a subscription canceled by your request
          // from above.
        } else {
          // handle subscription canceled automatically based
          // upon your subscription settings.
        }
        break;
      default:
      // Unexpected event type
    }
    res.sendStatus(200);
  }
);
```

```go
<<setup key>>

func handleWebhook(w http.ResponseWriter, r *http.Request) {
  if r.Method != "POST" {
    http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
    return
  }
  b, err := ioutil.ReadAll(r.Body)
  if err != nil {
    http.Error(w, err.Error(), http.StatusBadRequest)
    log.Printf("ioutil.ReadAll: %v", err)
    return
  }

  event, err := webhook.ConstructEvent(b, r.Header.Get("Stripe-Signature"), os.Getenv("STRIPE_WEBHOOK_SECRET"))
  if err != nil {
    http.Error(w, err.Error(), http.StatusBadRequest)
    log.Printf("webhook.ConstructEvent: %v", err)
    return
  }

  if event.Type == "invoice.paid" {
    // Used to provision services after the trial has ended.
    // The status of the invoice will show up as paid. Store the status in your
    // database to reference when a user accesses your service to avoid hitting rate
    // limits.
    return
  }

  if event.Type == "invoice.payment_failed" {
    // If the payment fails or the customer does not have a valid payment method,
    // an invoice.payment_failed event is sent, the subscription becomes past_due.
    // Use this webhook to notify your user that their payment has
    // failed and to retrieve new card details.
    return
  }

  if event.Type == "customer.subscription.deleted" {
    // handle subscription canceled automatically based
    // upon your subscription settings. Or if the user cancels it. {
    return
  }
}
```

```dotnet
<<setup key>>

[HttpPost("webhook")]
public async Task<IActionResult> Webhook()
{
  var json = await new StreamReader(HttpContext.Request.Body).ReadToEndAsync();
  Event stripeEvent;
  try
  {
    stripeEvent = EventUtility.ConstructEvent(
      json,
      Request.Headers["Stripe-Signature"],
      this.options.Value.WebhookSecret
    );
    Console.WriteLine($"Webhook notification with type: {stripeEvent.Type} found for {stripeEvent.Id}");
  }
  catch (Exception e)
  {
    Console.WriteLine($"Something failed {e}");
    return BadRequest();
  }

  if (stripeEvent.Type == "invoice.paid")
  {
    // Used to provision services after the trial has ended.
    // The status of the invoice will show up as paid. Store the status in your
    // database to reference when a user accesses your service to avoid hitting rate
    // limits.
  }

  if (stripeEvent.Type == "invoice.payment_failed")
  {
    // If the payment fails or the customer does not have a valid payment method,
    // an invoice.payment_failed event is sent, the subscription becomes past_due.
    // Use this webhook to notify your user that their payment has
    // failed and to retrieve new card details.
  }

  if (stripeEvent.Type == "customer.subscription.deleted")
  {
    // handle subscription canceled automatically based
    // upon your subscription settings. Or if the user cancels it.
  }
  return Ok();
}
```

During development, use the Stripe CLI to [observe webhooks and forward them to your application](https://docs.stripe.com/webhooks.md#test-webhook). Run the following in a new terminal while your development app is running:

```bash
stripe listen --forward-to localhost:4242/webhook
```

For production, set up a webhook endpoint URL in the Dashboard, or use the [Webhook Endpoints API](https://docs.stripe.com/api/webhook_endpoints.md).

You’ll listen to a couple of events to complete the remaining steps in this guide. See [Subscription events](https://docs.stripe.com/billing/subscriptions/overview.md#subscription-events) for more details about subscription-specific webhooks.

## Provision access to your service

Now that the subscription is active, give your user access to your service.  To do this, listen to the `customer.subscription.created`, `customer.subscription.updated`, and `customer.subscription.deleted` events.  These events pass a subscription object which contains a `status` field indicating whether the subscription is active, past due, or canceled.  See [the subscription lifecycle](https://docs.stripe.com/billing/subscriptions/overview.md#subscription-lifecycle) for a complete list of statuses.

In your webhook handler:

1. Verify the subscription status.  If it’s `active` then your user has paid for your product.
1. Check the product the customer subscribed to and grant access to your service. Checking the product instead of the price gives you more flexibility if you need to change the pricing or billing interval.
1. Store the `product.id`, `subscription.id` and `subscription.status` in your database along with the `customer.id` you already saved.  Check this record when determining which features to enable for the user in your application.

The state of a subscription might change at any point during its lifetime, even if your application does not directly make any calls to Stripe.  For example, a renewal might fail due to an expired credit card, which puts the subscription into a past due state.  Or, if you implement the [customer portal](https://docs.stripe.com/customer-management.md), a user might cancel their subscription without directly visiting your application.  Implementing your handler correctly keeps your application state in sync with Stripe.

## Cancel the subscription

It’s common to allow customers to cancel their subscriptions. This example adds a cancellation option to the account settings page.

The example collects the subscription ID on the frontend, but your application can get this information from your database for your logged in user.

![Sample subscription cancelation interface.](images/billing/subscriptions/fixed-price-subscriptions-guide-account-settings.png)
Account settings with the ability to cancel the subscription


On the backend, define the endpoint for your app to call.

```ruby
<<setup key>>

post '/cancel-subscription' do
  content_type 'application/json'
  data = JSON.parse request.body.read

  deleted_subscription = Stripe::Subscription.cancel(data['subscriptionId'])

  deleted_subscription.to_json
end
```

```python
<<setup key>>

@app.route('/cancel-subscription', methods=['POST'])
def cancelSubscription():
    data = json.loads(request.data)
    try:
         # Cancel the subscription by deleting it
        deletedSubscription = stripe.Subscription.delete(data['subscriptionId'])
        return jsonify(deletedSubscription)
    except Exception as e:
        return jsonify(error=str(e)), 403
```

```php
<<setup key>>

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
  $body = file_get_contents('php://input');
  $json = json_decode($body);

  $subscription = $stripe->subscriptions->retrieve(
    $json->subscriptionId
  );
  $subscription->delete();

  header('Content-Type: application/json');
  echo json_encode([
    'subscription' => $subscription,
  ]);
}
```

```java
<<setup key>>

post(
      "/cancel-subscription",
      (request, response) -> {
        response.type("application/json");
        // Set the default payment method on the customer
        CancelPostBody postBody = gson.fromJson(
          request.body(),
          CancelPostBody.class
        );

        Subscription subscription = Subscription.retrieve(
          postBody.getSubscriptionId()
        );

        Subscription deletedSubscription = subscription.cancel();
        return deletedSubscription.toJson();
      }
    );
```

```javascript
<<setup key>>

app.post('/cancel-subscription', async (req, res) => {
  // Delete the subscription
  const deletedSubscription = await stripe.subscriptions.del(
    req.body.subscriptionId
  );
  res.send(deletedSubscription);
});
```

```go
<<setup key>>

func handleCancelSubscription(w http.ResponseWriter, r *http.Request) {
  if r.Method != "POST" {
    http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
    return
  }
  var req struct {
    SubscriptionID string `json:"subscriptionId"`
  }
  if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("json.NewDecoder.Decode: %v", err)
    return
  }
  s, err := subscription.Cancel(req.SubscriptionID, nil)
  if err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("subscription.Cancel: %v", err)
    return
  }
  writeJSON(w, s)
}
```

```dotnet
using Newtonsoft.Json;

public class CancelSubscriptionRequest
{
    [JsonProperty("subscriptionId")]
    public string Subscription { get; set; }
}
```

```dotnet
<<setup key>>

[HttpPost("cancel-subscription")]
public ActionResult<Subscription> CancelSubscription([FromBody] CancelSubscriptionRequest req)
{
    var service = new SubscriptionService();
    var subscription = service.Cancel(req.Subscription, null);
    return subscription;
}
```

Your backend receives a `customer.subscription.deleted` event.

After the subscription is canceled, update your database to remove the Stripe subscription ID you previously stored, and limit access to your service.

When a subscription is canceled, it can’t be reactivated. Instead, collect updated billing information from your customer, update their default payment method, and create a new subscription with their existing customer record.

## Test your integration

### Test payment methods

Use the following table to test different payment methods and scenarios.

| Payment method    | Scenario                                                                                         | How to test                                                                                                                                                                                                  |
| ----------------- | ------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| BECS Direct Debit | Your customer successfully pays with BECS Direct Debit.                                          | Fill out the form using the account number `900123456` and BSB `000-000`. The confirmed PaymentIntent initially transitions to `processing`, then transitions to the `succeeded` status three minutes later. |
| BECS Direct Debit | Your customer’s payment fails with an `account_closed` error code.                               | Fill out the form using the account number `111111113` and BSB `000-000`.                                                                                                                                    |
| Credit card       | The card payment succeeds and doesn’t require authentication.                                    | Fill out the credit card form using the credit card number `4242 4242 4242 4242` with any expiration, CVC, and postal code.                                                                                  |
| Credit card       | The card payment requires *authentication*.                                                      | Fill out the credit card form using the credit card number `4000 0025 0000 3155` with any expiration, CVC, and postal code.                                                                                  |
| Credit card       | The card is declined with a decline code like `insufficient_funds`.                              | Fill out the credit card form using the credit card number `4000 0000 0000 9995` with any expiration, CVC, and postal code.                                                                                  |
| SEPA Direct Debit | Your customer successfully pays with SEPA Direct Debit.                                          | Fill out the form using the account number `AT321904300235473204`. The confirmed PaymentIntent initially transitions to processing, then transitions to the succeeded status three minutes later.            |
| SEPA Direct Debit | Your customer’s PaymentIntent status transitions from `processing` to `requires_payment_method`. | Fill out the form using the account number `AT861904300235473202`.                                                                                                                                           |

### Monitor events

Set up webhooks to listen to subscription change events, such as upgrades and cancellations. Learn more about [subscription webhooks](https://docs.stripe.com/billing/subscriptions/webhooks.md). You can view events in the [Dashboard](https://dashboard.stripe.com/test/events) or with the [Stripe CLI](https://docs.stripe.com/webhooks.md#test-webhook).

For more details, see [testing your Billing integration](https://docs.stripe.com/billing/testing.md).

## Let customers change their plans

To let your customers change their subscription, collect the price ID of the option they want to change to. Then send the new price ID from the app to a backend endpoint. This example also passes the subscription ID, but you can retrieve it from your database for your logged in user.

On the backend, define the endpoint for your frontend to call, passing the subscription ID and the new price ID. The subscription is now Premium, at 15 USD per month, instead of Basic at 5 USD per month.

```ruby
<<setup key>>

post '/update-subscription' do
  content_type 'application/json'
  data = JSON.parse request.body.read

  subscription = Stripe::Subscription.retrieve(data['subscriptionId'])

  updated_subscription =
    Stripe::Subscription.update(
      data['subscriptionId'],
      cancel_at_period_end: false,
      items: [
        { id: subscription.items.data[0].id, price: 'price_H1NlVtpo6ubk0m' }
      ]
    )

  updated_subscription.to_json
end
```

```python
<<setup key>>

@app.route('/update-subscription', methods=['POST'])
def updateSubscription():
    data = json.loads(request.data)
    try:
        subscription = stripe.Subscription.retrieve(data['subscriptionId'])

        updatedSubscription = stripe.Subscription.modify(
            data['subscriptionId'],
            cancel_at_period_end=False,
            items=[{
                'id': subscription['items']['data'][0].id,
                'price': 'price_H1NlVtpo6ubk0m',
            }]
        )
        return jsonify(updatedSubscription)
    except Exception as e:
        return jsonify(error=str(e)), 403
```

```php
<<setup key>>

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
  $body = file_get_contents('php://input');
  $json = json_decode($body);

  $subscription = $stripe->subscriptions->retrieve($json->subscriptionId);

  $updated_subscription = $stripe->subscriptions->update($json->subscriptionId, [
    'items' => [
      [
        'id' => $subscription->items->data[0]->id,
        'price' => 'price_H1NlVtpo6ubk0m',
      ],
    ],
  ]);

  header('Content-Type: application/json');
  echo json_encode([
    'updatedSubscription' => $updated_subscription,
  ]);
}
```

```java
<<setup key>>

post(
  "/update-subscription",
  (request, response) -> {
    response.type("application/json");
    // Set the default payment method on the customer
    UpdatePostBody postBody = gson.fromJson(
      request.body(),
      UpdatePostBody.class
    );

    Subscription subscription = Subscription.retrieve(
      postBody.getSubscriptionId()
    );

    SubscriptionUpdateParams params = SubscriptionUpdateParams
      .builder()
      .addItem(
        SubscriptionUpdateParams
          .Item.builder()
          .setId(subscription.getItems().getData().get(0).getId())
          .setPrice("price_H1NlVtpo6ubk0m")
          .build()
      )
      .setCancelAtPeriodEnd(false)
      .build();

    subscription.update(params);
    return subscription.toJson();
  }
);
```

```javascript
<<setup key>>

app.post('/update-subscription', async (req, res) => {
  const subscription = await stripe.subscriptions.retrieve(
    req.body.subscriptionId
  );
  const updatedSubscription = await stripe.subscriptions.update(
    req.body.subscriptionId,
    {
      cancel_at_period_end: false,
      items: [
        {
          id: subscription.items.data[0].id,
          price: "price_H1NlVtpo6ubk0m",
        },
      ],
    }
  );

  res.send(updatedSubscription);
});
```

```go
<<setup key>>

func handleUpdateSubscription(w http.ResponseWriter, r *http.Request) {
  if r.Method != "POST" {
    http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
    return
  }

  var req struct {
    SubscriptionID string `json:"subscriptionId"`
    NewPriceID     string `json:"newPriceId"`
  }

  if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("json.NewDecoder.Decode: %v", err)
    return
  }

  s, err := subscription.Get(req.SubscriptionID, nil)
  if err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("subscription.Get: %v", err)
    return
  }

  params := &stripe.SubscriptionParams{
    CancelAtPeriodEnd: stripe.Bool(false),
    Items: []*stripe.SubscriptionItemsParams{{
      ID:    stripe.String(s.Items.Data[0].ID),
      Price: stripe.String("price_H1NlVtpo6ubk0m"),
    }},
  }

  updatedSubscription, err := subscription.Update(req.SubscriptionID, params)

  if err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("subscription.Update: %v", err)
    return
  }

  writeJSON(w, updatedSubscription)
}
```

```dotnet
using Newtonsoft.Json;

public class UpdateSubscriptionRequest
{
    [JsonProperty("subscriptionId")]
    public string Subscription { get; set; }

    [JsonProperty("newPriceId")]
    public string NewPrice { get; set; }
}
```

```dotnet
<<setup key>>

[HttpPost("update-subscription")]
public ActionResult<Subscription> UpdateSubscription([FromBody] UpdateSubscriptionRequest req)
{
    var service = new SubscriptionService();
    var subscription = service.Get(req.Subscription);

    var options = new SubscriptionUpdateOptions
    {
        CancelAtPeriodEnd = false,
        Items = new List<SubscriptionItemOptions>
        {
            new SubscriptionItemOptions
            {
                Id = subscription.Items.Data[0].Id,
                Price = "price_H1NlVtpo6ubk0m",
            }
        }
    };
    var updatedSubscription = service.Update(req.Subscription, options);
    return updatedSubscription;
}
```

Your application receives a `customer.subscription.updated` event.

## Preview a price change

When your customer changes their subscription, there’s often an adjustment to the amount they owe, known as a [proration](https://docs.stripe.com/billing/subscriptions/prorations.md). You can use the [create preview invoice endpoint](https://docs.stripe.com/api/invoices/create_preview.md) to display the adjusted amount to your customers.

From the app, pass the preview invoice details to a backend endpoint.

On the backend, define the endpoint for your frontend to call.

```ruby
<<setup key>>

post '/create-preview-invoice' do
  content_type 'application/json'
  data = JSON.parse request.body.read

  subscription = Stripe::Subscription.retrieve(data['subscriptionId'])

  invoice =
    Stripe::Invoice.create_preview(
      customer: data['customerId'],
      subscription: data['subscriptionId'],
      subscription_details: {
        items: [
          { id: subscription.items.data[0].id, deleted: true },
          { price: ENV[data['newPriceId']], deleted: false }
        ]
      }
    )

  invoice.to_json
end
```

```python
<<setup key>>

@app.route('/create-preview-invoice', methods=['POST'])
def createPreviewInvoice():
    data = json.loads(request.data)
    try:
        # Retrieve the subscription
        subscription = stripe.Subscription.retrieve(data['subscriptionId'])

        # Retrieve the invoice
        invoice = stripe.Invoice.create_preview(
            customer=data['customerId'],
            subscription=data['subscriptionId'],
            subscription_details={
              "items": [
                  {
                      'id': subscription['items']['data'][0].id,
                      'deleted': True,
                  },
                  {
                      'price': 'price_H1NlVtpo6ubk0m',
                      'deleted': False,
                  }
              ]
            }
        )
        return jsonify(invoice)
    except Exception as e:
        return jsonify(error=str(e)), 403
```

```php
<<setup key>>

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
  $body = file_get_contents('php://input');
  $json = json_decode($body);

  $subscription = $stripe->subscriptions->retrieve($json->subscriptionId);

  $invoice = $stripe->invoices->createPreview([
    'customer' => $json->customerId,
    'subscription' => $json->subscriptionId,
    'subscription_details' => [
      'items' => [
        [
          'id' => $subscription->items->data[0]->id,
          'deleted' => true
        ],
        [
          'price' => $json->newPriceId,
          'deleted' => false
        ],
      ],
    ],
  ]);

  header('Content-Type: application/json');
  echo json_encode([
    'invoice' => $invoice,
  ]);
}
```

```java
<<setup key>>

post(
  "/create-preview-invoice",
  (request, response) -> {
    response.type("application/json");
    PreviewInvoicePostBody postBody = gson.fromJson(
      request.body(),
      PreviewInvoicePostBody.class
    );

    Subscription subscription = Subscription.retrieve(
      postBody.getSubscriptionId()
    );

    InvoiceCreatePreviewParams invoiceParams = InvoiceCreatePreviewParams
      .builder()
      .setCustomer(postBody.getCustomerId())
      .setSubscription(postBody.getSubscriptionId())
      .setSubscriptionDetails(
        InvoiceCreatePreviewParams.SubscriptionDetails.builder()
          .addItem(
            InvoiceCreatePreviewParams.SubscriptionDetails.Item.builder()
              .setId(subscription.getItems().getData().get(0).getId())
              .setDeleted(true)
              .build()
          )
          .addItem(
            InvoiceCreatePreviewParams.SubscriptionDetails.Item.builder()
              .setPrice(dotenv.get(postBody.getNewPriceId().toUpperCase()))
              .build()
          )
          .build()
      )
      .build();

    Invoice invoice = Invoice.createPreview(invoiceParams);

    return invoice.toJson();
  }
);
```

```javascript
<<setup key>>

app.post('/create-preview-invoice', async (req, res) => {
  const subscription = await stripe.subscriptions.retrieve(
    req.body.subscriptionId
  );

  const invoice = await stripe.invoices.createPreview({
    customer: req.body.customerId,
    subscription: req.body.subscriptionId,
    subscription_details: {
      items: [
        {
          id: subscription.items.data[0].id,
          deleted: true,
        },
        {
          // This price ID is the price you want to change the subscription to.
          price: 'price_H1NlVtpo6ubk0m',
          deleted: false,
        },
      ],
    }
  });
  res.send(invoice);
});
```

```go
<<setup key>>

func handleCreatePreviewInvoice(w http.ResponseWriter, r *http.Request) {
  if r.Method != "POST" {
    http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
    return
  }
  var req struct {
    SubscriptionID string `json:"subscriptionId"`
    CustomerID     string `json:"customerId"`
    NewPriceID     string `json:"newPriceId"`
  }

  if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("json.NewDecoder.Decode: %v", err)
    return
  }

  s, err := subscription.Get(req.SubscriptionID, nil)
  if err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("subscription.Get: %v", err)
    return
  }
  params := &stripe.InvoiceCreatePreviewParams{
    Customer:     stripe.String(req.CustomerID),
    Subscription: stripe.String(req.SubscriptionID),
    SubscriptionDetails: &stripe.InvoiceCreatePreviewSubscriptionDetailsParams{
      Items: []*stripe.SubscriptionItemsParams{{
        ID:      stripe.String(s.Items.Data[0].ID),
        Deleted: stripe.Bool(true),
      }, {
        Price:   stripe.String(os.Getenv(req.NewPriceID)),
        Deleted: stripe.Bool(false),
      }},
    },
  }
  in, err := invoice.CreatePreview(params)

  if err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("invoice.CreatePreview: %v", err)
    return
  }

  writeJSON(w, in)
}
```

```dotnet
using Newtonsoft.Json;

public class CreatePreviewInvoiceRequest
{
    [JsonProperty("customerId")]
    public string Customer { get; set; }

    [JsonProperty("subscriptionId")]
    public string Subscription { get; set; }

    [JsonProperty("newPriceId")]
    public string NewPrice { get; set; }
}
```

```dotnet
<<setup key>>

[HttpPost("create-preview-invoice")]
public ActionResult<Invoice> CreatePreviewInvoice([FromBody] CreatePreviewInvoiceRequest req)
{
    var service = new SubscriptionService();
    var subscription = service.Get(req.Subscription);

    var invoiceService = new InvoiceService();
    var options = new InvoiceCreatePreviewOptions
    {
        Customer = req.Customer,
        Subscription = req.Subscription,
        SubscriptionDetails = new InvoiceSubscriptionDetailsOptions
        {
            Items = new List<InvoiceSubscriptionItemOptions>
            {
                new InvoiceSubscriptionItemOptions
                {
                    Id = subscription.Items.Data[0].Id,
                    Deleted = true,
                },
                new InvoiceSubscriptionItemOptions
                {
                    Price = Environment.GetEnvironmentVariable(req.NewPrice),
                    Deleted = false,
                },
            },
        },
    };
    Invoice previewInvoice = invoiceService.CreatePreview(options);
    return previewInvoice;
}
```

## Display the customer payment method

Displaying the brand and last four digits of your customer’s card can help them know which card is being charged, or if they need to update their payment method.

On the front end, send the payment method ID to a back-end endpoint that retrieves the payment method details.

On the back end, define the endpoint for your app to call.

```ruby
<<setup key>>

post '/retrieve-customer-payment-method' do
  content_type 'application/json'
  data = JSON.parse request.body.read

  payment_method = Stripe::PaymentMethod.retrieve(data['paymentMethodId'])

  payment_method.to_json
end
```

```python
<<setup key>>

@app.route('/retrieve-customer-payment-method', methods=['POST'])
def retrieveCustomerPaymentMethod():
    data = json.loads(request.data)
    try:
        paymentMethod = stripe.PaymentMethod.retrieve(
            data['paymentMethodId'],
        )
        return jsonify(paymentMethod)
    except Exception as e:
        return jsonify(error=str(e)), 403
```

```php
<<setup key>>

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
  $body = file_get_contents('php://input');
  $json = json_decode($body);

  $payment_method = $stripe->paymentMethods->retrieve($json->paymentMethodId);

  header('Content-Type: application/json');
  echo json_encode([
    'paymentMethod' => $payment_method,
  ]);
}
```

```java
<<setup key>>

post(
  "/retrieve-customer-payment-method",
  (request, response) -> {
    response.type("application/json");
    // Set the default payment method on the customer
    PaymentMethodBody paymentMethodBody = gson.fromJson(
      request.body(),
      PaymentMethodBody.class
    );

    PaymentMethod paymentMethod = PaymentMethod.retrieve(
      paymentMethodBody.getPaymentMethodId()
    );
    return paymentMethod.toJson();
  }
);
```

```javascript
<<setup key>>

app.post('/retrieve-customer-payment-method', async (req, res) => {
  const paymentMethod = await stripe.paymentMethods.retrieve(
    req.body.paymentMethodId
  );

  res.send(paymentMethod);
});
```

```go
<<setup key>>

func handleRetrieveCustomerPaymentMethod(w http.ResponseWriter, r *http.Request) {
  if r.Method != "POST" {
    http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
    return
  }
  var req struct {
    PaymentMethodID string `json:"paymentMethodId"`
  }
  if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("json.NewDecoder.Decode: %v", err)
    return
  }

  pm, err := paymentmethod.Get(req.PaymentMethodID, nil)
  if err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("paymentmethod.Get: %v", err)
    return
  }

  writeJSON(w, pm)
}
```

```dotnet
using Newtonsoft.Json;

public class RetrieveCustomerPaymentMethodRequest
{
    [JsonProperty("paymentMethodId")]
    public string PaymentMethod { get; set; }
}
```

```dotnet
<<setup key>>

[HttpPost("retrieve-customer-payment-method")]
public ActionResult<PaymentMethod> RetrieveCustomerPaymentMethod([FromBody] RetrieveCustomerPaymentMethodRequest req)
{
    var service = new PaymentMethodService();
    var paymentMethod = service.Get(req.PaymentMethod);
    return paymentMethod;
}
```

Example response:

```json
{
  "id": "pm_1GcbHY2eZvKYlo2CoqlVxo42",
  "object": "payment_method",
  "billing_details": {
    "address": {
      "city": null,
      "country": null,
      "line1": null,
      "line2": null,
      "postal_code": null,
      "state": null
    },
    "email": null,
    "name": null,
    "phone": null
  },
  "card": {
    "brand": "visa",
    "checks": {
      "address_line1_check": null,
      "address_postal_code_check": null,
      "cvc_check": "pass"
    },
    "country": "US",
    "exp_month": 8,
    "exp_year": 2021,
    "fingerprint": "Xt5EWLLDS7FJjR1c",
    "funding": "credit",
    "generated_from": null,
    "last4": "4242",
    "three_d_secure_usage": {
      "supported": true
    },
    "wallet": null
  },
  "created": 1588010536,
  "customer": "cus_HAxB7dVQxhoKLh",
  "livemode": false,
  "metadata": {},
  "type": "card"
}
```

We recommend that you save the `paymentMethod.id` and `last4` in your database, for example, `paymentMethod.id` as `stripeCustomerPaymentMethodId` in your `users` collection or table. You can optionally store `exp_month`, `exp_year`, `fingerprint`, `billing_details` as needed. This is to limit the number of calls you make to Stripe—for both performance efficiency and to avoid possible rate limiting.

## Disclose Stripe to your customers 

Stripe collects information on customer interactions with Elements to provide services to you, prevent fraud, and improve its services. This includes using cookies and IP addresses to identify which Elements a customer saw during a single checkout session. You’re responsible for disclosing and obtaining all rights and consents necessary for Stripe to use data in these ways. For more information, visit our [privacy center](https://stripe.com/legal/privacy-center#as-a-business-user-what-notice-do-i-provide-to-my-end-customers-about-stripe).

# Android

> This is a Android for when platform is android. View the original doc at https://docs.stripe.com/billing/subscriptions/build-subscriptions?platform=android.

Customize with the [Appearance API](https://docs.stripe.com/elements/appearance-api.md).

Use this guide to learn how to sell fixed-price *subscriptions*. You’ll use the [Mobile Payment Element](https://docs.stripe.com/payments/accept-a-payment.md?platform=ios) to create a custom payment form that you embed in your app.

If you’re selling digital products or services that are consumed within your app (for example, subscriptions, in-game currencies, game levels, access to premium content, or unlocking a full version), you must use Apple’s in-app purchase APIs. This rule has some exceptions, including one-to-one personal services and [apps based in specific regions](https://support.stripe.com/questions/changes-to-mobile-app-store-rules). See the [App Store review guidelines](https://developer.apple.com/app-store/review/guidelines/#payments) for more information.

## Build your subscription 

This guide shows you how to:

- Model your business by building a product catalog.
- Create a registration process to add customers.
- Create subscriptions and collect payment information.
- Test and monitor the status of payments and subscriptions.
- Let customers change their plan or cancel the subscription.

## How to model it on Stripe

[Subscriptions](https://docs.stripe.com/api/subscriptions.md) simplify your billing by automatically creating *Invoices* and [PaymentIntents](https://docs.stripe.com/api/payment_intents.md) for you.  To create and activate a subscription, you need to first create a *Product* to model what is being sold, and a *Price* which determines the interval and amount to charge. You also need a [Customer](https://docs.stripe.com/api/customers.md) to store *PaymentMethods* used to make each recurring payment.

### API object definitions

| Resource                                                                      | Definition                                                                                                                                                                                                                                                                                                                                                                                                    |
| ----------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [Entitlement](https://docs.stripe.com/api/entitlements/active-entitlement.md) | Represents a customer’s access to a feature included in a service product that they subscribe to. When you create a subscription for a customer’s recurring purchase of a product, an active entitlement is automatically created for each feature associated with that product. When a customer accesses your services, use their active entitlements to enable the features included in their subscription. |
| [Feature](https://docs.stripe.com/api/entitlements/feature.md)                | Represents a function or ability that your customers can access when they subscribe to a service product. You can include features in a product by creating ProductFeatures.                                                                                                                                                                                                                                  |
| [Invoice](https://docs.stripe.com/api/invoices.md)                            | A statement of amounts a customer owes that tracks payment statuses from draft through paid or otherwise finalized. Subscriptions automatically generate invoices.                                                                                                                                                                                                                                            |
| [PaymentIntent](https://docs.stripe.com/api/payment_intents.md)               | A way to build dynamic payment flows. A PaymentIntent tracks the lifecycle of a customer checkout flow and triggers additional authentication steps when required by regulatory mandates, custom Radar fraud rules, or redirect-based payment methods. Invoices automatically create PaymentIntents.                                                                                                          |
| [PaymentMethod](https://docs.stripe.com/api/payment_methods.md)               | A customer’s payment methods that they use to pay for your products. For example, you can store a credit card on a Customer object and use it to make recurring payments for that customer. Typically used with the Payment Intents or Setup Intents APIs.                                                                                                                                                    |
| [Price](https://docs.stripe.com/api/prices.md)                                | Defines the unit price, currency, and billing cycle for a product.                                                                                                                                                                                                                                                                                                                                            |
| [Product](https://docs.stripe.com/api/products.md)                            | A good or service that your business sells. A service product can include one or more features.                                                                                                                                                                                                                                                                                                               |
| [ProductFeature](https://docs.stripe.com/api/product-feature.md)              | Represents a single feature’s inclusion in a single product. Each product is associated with a ProductFeature for each feature that it includes, and each feature is associated with a ProductFeature for each product that includes it.                                                                                                                                                                      |
| [Subscription](https://docs.stripe.com/api/subscriptions.md)                  | Represents a customer’s scheduled recurring purchase of a product. Use a subscription to collect payments and provide repeated delivery of or continuous access to a product.                                                                                                                                                                                                                                 |

Here’s an example of how products, features, and entitlements work together. Imagine that you want to set up a subscription service that offers two tiers: a standard product with basic functionality, and an advanced product that adds extended functionality.

1. You create two features: `basic_features` and `extended_features`.
1. You create two products: `standard_product` and `advanced_product`.
1. For the standard product, you create one ProductFeature that associates `basic_features` with `standard_product`.
1. For the advanced product, you create two ProductFeatures: one that associates `basic_features` with `advanced_product` and one that associates `extended_features` with `advanced_product`.

A customer, `first_customer`, subscribes to the standard product. When you create the subscription, Stripe automatically creates an Entitlement that associates `first_customer` with `basic_features`.

Another customer, `second_customer`, subscribes to the advanced product. When you create the Subscription, Stripe automatically creates two Entitlements: one that associates `second_customer` with `basic_features`, and one that associates `second_customer` with `extended_features`.

You can determine which features to provision for a customer by [retrieving their active entitlements or listening to the Active Entitlement Summary event](https://docs.stripe.com/billing/entitlements.md#entitlements). You don’t have to retrieve their subscriptions, products, and features.

## Set up Stripe

And then install the Stripe CLI. The CLI provides webhook testing and you can run it to make API calls to Stripe.  This guide shows how to use the CLI to set up a pricing model in a later section.

```bash
\# Install Homebrew to run this command: https://brew.sh/
brew install stripe/stripe-cli/stripe

# Connect the CLI to your dashboard
stripe login
```

```bash
\# 1. Download the latest `mac-os` tar.gz file of your cpu architecture type from https://github.com/stripe/stripe-cli/releases/latest

# 2. Tar the downloaded file
tar -xvf stripe_[X.X.X]_mac-os_[ARCH_TYPE].tar.gz

# Optionally, install the binary in a location where you can execute it globally (for example, `/usr/local/bin`).

# Connect the CLI to your dashboard
stripe login
```

To install the Stripe CLI on Debian and Ubuntu-based distributions:

```bash
brew install stripe/stripe-cli/stripe

# Connect the CLI to your dashboard
stripe login
```

On April 5th, 2024, we changed Stripe CLI’s GPG key to install the Stripe CLI through apt. If you configured the public key before April 5th, you’ll encounter this error:

```
W: An error occurred during the signature verification. The repository is not updated and the previous index files will be used. GPG error: https://packages.stripe.dev/stripe-cli-debian-local stable InRelease: The following signatures were invalid: EXPKEYSIG DEEBD57F917C83E3 Stripe <security@stripe.com>
W: Failed to fetch https://packages.stripe.dev/stripe-cli-debian-local/dists/stable/InRelease  The following signatures were invalid: EXPKEYSIG DEEBD57F917C83E3 Stripe <security@stripe.com>
W: Some index files failed to download. They have been ignored, or old ones used instead
```

To resolve this error, refresh Stripe’s GPG key by following step 1.

To install the Stripe CLI on Debian and Ubuntu-based distributions:

```bash
\# 1. Add Stripe CLI's GPG key to the apt sources keyring:
curl -s https://packages.stripe.dev/api/security/keypair/stripe-cli-gpg/public | gpg --dearmor | sudo tee /usr/share/keyrings/stripe.gpg

# 2. Add CLI's apt repository to the apt sources list:
echo "deb [signed-by=/usr/share/keyrings/stripe.gpg] https://packages.stripe.dev/stripe-cli-debian-local stable main" | sudo tee -a /etc/apt/sources.list.d/stripe.list

# 3. Update the package list
sudo apt update

# 4. Install the CLI
sudo apt install stripe

# 5. Connect the CLI to your dashboard
stripe login
```

```bash
\# 1. Add CLI's yum repository to the yum sources list:
echo -e "[Stripe]\nname=stripe\nbaseurl=https://packages.stripe.dev/stripe-cli-rpm-local/\nenabled=1\ngpgcheck=0" >> /etc/yum.repos.d/stripe.repo

# 2. Install the CLI
sudo yum install stripe
```

```bash
\# Download the latest `linux` tar.gz file from <https://github.com/stripe/stripe-cli/releases/latest>

# Unzip the file:
tar -xvf stripe_X.X.X_linux_x86_64.tar.gz

# Move `./stripe` to your execution path.

# Connect the CLI to your dashboard
stripe login
```

```bash
\# 1. Download the latest `windows` zip file from
# https://github.com/stripe/stripe-cli/releases/latest

# 2. Unzip the `stripe_X.X.X_windows_x86_64.zip` file

# 3. Run the unzipped `.exe` file

# Connect the CLI to your dashboard
stripe login
```

```bash
\# See https://scoop.sh

scoop bucket add stripe https://github.com/stripe/scoop-stripe-cli.git

scoop install stripe
```

For additional install options, see [Get started with the Stripe CLI](https://docs.stripe.com/stripe-cli.md).

## Create the pricing model

## Create the customer

Stripe needs a *customer* for each subscription.  In your application frontend, collect any necessary information from your users and pass it to the backend.

If you need to collect address details, the Address Element enables you to collect a shipping or billing address for your customers. For more information on the Address Element, visit the [Address Element](https://docs.stripe.com/elements/address-element.md) page.

On the server, create the Stripe customer object.

```dotnet
StripeConfiguration.ApiKey = "<<secret key>>";

var options = new CustomerCreateOptions
{
    Email = "{{CUSTOMER_EMAIL}}",
    Name = "{{CUSTOMER_NAME}}",
    Shipping = new ShippingOptions
    {
        Address = new AddressOptions
        {
            City = "Brothers",
            Country = "US",
            Line1 = "27 Fredrick Ave",
            PostalCode = "97712",
            State = "CA",
        },
        Name = "{{CUSTOMER_NAME}}",
    },
    Address = new AddressOptions
    {
        City = "Brothers",
        Country = "US",
        Line1 = "27 Fredrick Ave",
        PostalCode = "97712",
        State = "CA",
    },
};
var service = new CustomerService();
Customer customer = service.Create(options);
```

```go
stripe.Key = "<<secret key>>"

params := &stripe.CustomerParams{
  Email: stripe.String("{{CUSTOMER_EMAIL}}"),
  Name: stripe.String("{{CUSTOMER_NAME}}"),
  Shipping: &stripe.CustomerShippingParams{
    Address: &stripe.AddressParams{
      City: stripe.String("Brothers"),
      Country: stripe.String("US"),
      Line1: stripe.String("27 Fredrick Ave"),
      PostalCode: stripe.String("97712"),
      State: stripe.String("CA"),
    },
    Name: stripe.String("{{CUSTOMER_NAME}}"),
  },
  Address: &stripe.AddressParams{
    City: stripe.String("Brothers"),
    Country: stripe.String("US"),
    Line1: stripe.String("27 Fredrick Ave"),
    PostalCode: stripe.String("97712"),
    State: stripe.String("CA"),
  },
};
result, err := customer.New(params);
```

```java
Stripe.apiKey = "<<secret key>>";

CustomerCreateParams params =
  CustomerCreateParams.builder()
    .setEmail("{{CUSTOMER_EMAIL}}")
    .setName("{{CUSTOMER_NAME}}")
    .setShipping(
      CustomerCreateParams.Shipping.builder()
        .setAddress(
          CustomerCreateParams.Shipping.Address.builder()
            .setCity("Brothers")
            .setCountry("US")
            .setLine1("27 Fredrick Ave")
            .setPostalCode("97712")
            .setState("CA")
            .build()
        )
        .setName("{{CUSTOMER_NAME}}")
        .build()
    )
    .setAddress(
      CustomerCreateParams.Address.builder()
        .setCity("Brothers")
        .setCountry("US")
        .setLine1("27 Fredrick Ave")
        .setPostalCode("97712")
        .setState("CA")
        .build()
    )
    .build();

Customer customer = Customer.create(params);
```

```node
const stripe = require('stripe')('<<secret key>>');

const customer = await stripe.customers.create({
  email: '{{CUSTOMER_EMAIL}}',
  name: '{{CUSTOMER_NAME}}',
  shipping: {
    address: {
      city: 'Brothers',
      country: 'US',
      line1: '27 Fredrick Ave',
      postal_code: '97712',
      state: 'CA',
    },
    name: '{{CUSTOMER_NAME}}',
  },
  address: {
    city: 'Brothers',
    country: 'US',
    line1: '27 Fredrick Ave',
    postal_code: '97712',
    state: 'CA',
  },
});
```

```python
import stripe
stripe.api_key = "<<secret key>>"

customer = stripe.Customer.create(
  email="{{CUSTOMER_EMAIL}}",
  name="{{CUSTOMER_NAME}}",
  shipping={
    "address": {
      "city": "Brothers",
      "country": "US",
      "line1": "27 Fredrick Ave",
      "postal_code": "97712",
      "state": "CA",
    },
    "name": "{{CUSTOMER_NAME}}",
  },
  address={
    "city": "Brothers",
    "country": "US",
    "line1": "27 Fredrick Ave",
    "postal_code": "97712",
    "state": "CA",
  },
)
```

```php
$stripe = new \Stripe\StripeClient('<<secret key>>');

$customer = $stripe->customers->create([
  'email' => '{{CUSTOMER_EMAIL}}',
  'name' => '{{CUSTOMER_NAME}}',
  'shipping' => [
    'address' => [
      'city' => 'Brothers',
      'country' => 'US',
      'line1' => '27 Fredrick Ave',
      'postal_code' => '97712',
      'state' => 'CA',
    ],
    'name' => '{{CUSTOMER_NAME}}',
  ],
  'address' => [
    'city' => 'Brothers',
    'country' => 'US',
    'line1' => '27 Fredrick Ave',
    'postal_code' => '97712',
    'state' => 'CA',
  ],
]);
```

```ruby
Stripe.api_key = '<<secret key>>'

customer = Stripe::Customer.create({
  email: '{{CUSTOMER_EMAIL}}',
  name: '{{CUSTOMER_NAME}}',
  shipping: {
    address: {
      city: 'Brothers',
      country: 'US',
      line1: '27 Fredrick Ave',
      postal_code: '97712',
      state: 'CA',
    },
    name: '{{CUSTOMER_NAME}}',
  },
  address: {
    city: 'Brothers',
    country: 'US',
    line1: '27 Fredrick Ave',
    postal_code: '97712',
    state: 'CA',
  },
})
```

## Create the subscription

If you want to render the Payment Element without first creating a subscription, see [Collect payment details before creating an Intent](https://docs.stripe.com/payments/accept-a-payment-deferred.md?type=subscription).

Let your new customer choose a plan and then create the subscription—in this guide, they choose between Basic and Premium.

In your app, pass the selected price ID and the ID of the customer record to the backend.

On the backend, create the subscription with status `incomplete` using `payment_behavior=default_incomplete`. Then return the `client_secret` from the subscription’s first [payment intent](https://docs.stripe.com/payments/payment-intents.md) to the frontend to complete payment by expanding the[`confirmation_secret`](https://docs.stripe.com/api/invoices/object.md#invoice_object-confirmation_secret) on the latest invoice of the subscription.

Set [save_default_payment_method](https://docs.stripe.com/api/subscriptions/object.md#subscription_object-payment_settings-save_default_payment_method) to `on_subscription` to save the payment method as the default for a subscription when a payment succeeds. Saving a default payment method increases the success rate of future subscription payments.

```ruby
<<setup key>>

post '/create-subscription' do
  content_type 'application/json'
  data = JSON.parse(request.body.read)
  customer_id = cookies[:customer]
  price_id = data['priceId']

  # Create the subscription. Note we're expanding the Subscription's
  # latest invoice and that invoice's confirmation_secret
  # so we can pass it to the front end to confirm the payment
  subscription = Stripe::Subscription.create(
    customer: customer_id,
    items: [{
      price: price_id,
    }],
    payment_behavior: 'default_incomplete',
    payment_settings: {save_default_payment_method: 'on_subscription'},
    expand: ['latest_invoice.confirmation_secret']
  )

  { subscriptionId: subscription.id, clientSecret: subscription.latest_invoice.confirmation_secret.client_secret }.to_json
end
```

```python
<<setup key>>

@app.route('/create-subscription', methods=['POST'])
def create_subscription():
    data = json.loads(request.data)
    customer_id = data['customerId']
    price_id = data['priceId']

    try:
        # Create the subscription. Note we're expanding the Subscription's
        # latest invoice and that invoice's confirmation_secret
        # so we can pass it to the front end to confirm the payment
        subscription = stripe.Subscription.create(
            customer=customer_id,
            items=[{
                'price': price_id,
            }],
            payment_behavior='default_incomplete',
            payment_settings={'save_default_payment_method': 'on_subscription'},
            expand=['latest_invoice.confirmation_secret'],
        )
        return jsonify(subscriptionId=subscription.id, clientSecret=subscription.latest_invoice.confirmation_secret.client_secret)

    except Exception as e:
        return jsonify(error={'message': e.user_message}), 400
```

```php
<<setup key>>

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    // Get the request body and decode it as JSON.
    $body = file_get_contents('php://input');
    $json = json_decode($body);

    // Get the customer ID from the cookie and the price ID from the JSON data.
    $customer_id = $_COOKIE['customer'];
    $price_id = $json->priceId;

    // Create the subscription with the customer ID, price ID, and necessary options.
    $subscription = $stripe->subscriptions->create([
        'customer' => $customer_id,
        'items' => [[
            'price' => $price_id,
        ]],
        'payment_behavior' => 'default_incomplete',
        'payment_settings' => ['save_default_payment_method' => 'on_subscription'],
        'expand' => ['latest_invoice.confirmation_secret'],
    ]);

    // Return the subscription ID and client secret as a JSON response.
    header('Content-Type: application/json');
    echo json_encode([
        'subscriptionId' => $subscription->id,
        'clientSecret' => $subscription->latest_invoice->confirmation_secret->client_secret,
    ]);
}
```

```java
<<setup key>>

post(
  "/create-subscription",
  (request, response) -> {
    response.type("application/json");
    String customerId = request.cookie("customer");
    CreateSubscriptionRequest postBody = gson.fromJson(
      request.body(),
      CreateSubscriptionRequest.class
    );
    String priceId = postBody.getPriceId();

    // Automatically save the payment method to the subscription
    // when the first payment is successful.
    SubscriptionCreateParams.PaymentSettings paymentSettings =
      SubscriptionCreateParams.PaymentSettings
        .builder()
        .setSaveDefaultPaymentMethod(SaveDefaultPaymentMethod.ON_SUBSCRIPTION)
        .build();

    // Create the subscription. Note we're expanding the Subscription's
    // latest invoice and that invoice's confirmation_secret
    // so we can pass it to the front end to confirm the payment
    SubscriptionCreateParams subCreateParams = SubscriptionCreateParams
      .builder()
      .setCustomer(customerId)
      .addItem(
        SubscriptionCreateParams
          .Item.builder()
          .setPrice(priceId)
          .build()
      )
      .setPaymentSettings(paymentSettings)
      .setPaymentBehavior(SubscriptionCreateParams.PaymentBehavior.DEFAULT_INCOMPLETE)
      .addAllExpand(Arrays.asList("latest_invoice.confirmation_secret"))
      .build();

    Subscription subscription = Subscription.create(subCreateParams);

    Map<String, Object> responseData = new HashMap<>();
    responseData.put("subscriptionId", subscription.getId());
    responseData.put("clientSecret", subscription.getLatestInvoiceObject().getConfirmationSecret().getClientSecret());
    return StripeObject.PRETTY_PRINT_GSON.toJson(responseData);
  }
);
```

```javascript
<<setup key>>

app.post('/create-subscription', async (req, res) => {
  const customerId = req.cookies['customer'];
  const priceId = req.body.priceId;

  try {
    // Create the subscription. Note we're expanding the Subscription's
    // latest invoice and that invoice's confirmation_secret
    // so we can pass it to the front end to confirm the payment
    const subscription = await stripe.subscriptions.create({
      customer: customerId,
      items: [{
        price: priceId,
      }],
      payment_behavior: 'default_incomplete',
      payment_settings: { save_default_payment_method: 'on_subscription' },
      expand: ['latest_invoice.confirmation_secret'],
    });

    res.send({
      subscriptionId: subscription.id,
      clientSecret: subscription.latest_invoice.confirmation_secret.client_secret,
    });
  } catch (error) {
    return res.status(400).send({ error: { message: error.message } });
  }
});
```

```go
<<setup key>>

func handleCreateSubscription(w http.ResponseWriter, r *http.Request) {
    if r.Method != "POST" {
        http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
        return
    }

    var req struct {
        PriceID string `json:"priceId"`
    }

    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        writeJSON(w, nil, err)
        log.Printf("json.NewDecoder.Decode: %v", err)
        return
    }

    cookie, _ := r.Cookie("customer")
    customerID := cookie.Value

    // Automatically save the payment method to the subscription
    // when the first payment is successful.
    paymentSettings := &stripe.SubscriptionPaymentSettingsParams{
		    SaveDefaultPaymentMethod: stripe.String("on_subscription"),
  	}

    // Create the subscription. Note we're expanding the Subscription's
    // latest invoice and that invoice's confirmation_secret
    // so we can pass it to the front end to confirm the payment
    subscriptionParams := &stripe.SubscriptionParams{
        Customer: stripe.String(customerID),
        Items: []*stripe.SubscriptionItemsParams{
            {
                Price: stripe.String(req.PriceID),
            },
        },
        PaymentSettings: paymentSettings,
        PaymentBehavior: stripe.String("default_incomplete"),
    }
    subscriptionParams.AddExpand("latest_invoice.confirmation_secret")
    s, err := subscription.New(subscriptionParams)

    if err != nil {
        writeJSON(w, nil, err)
        log.Printf("subscription.New: %v", err)
        return
    }

    writeJSON(w, struct {
        SubscriptionID string `json:"subscriptionId"`
        ClientSecret string `json:"clientSecret"`
    }{
        SubscriptionID: s.ID,
        ClientSecret: s.LatestInvoice.ConfirmationSecret.ClientSecret,
    }, nil)
}
```

```dotnet
<<setup key>>

[HttpPost("create-subscription")]
public ActionResult<SubscriptionCreateResponse> CreateSubscription([FromBody] CreateSubscriptionRequest req)
{
    var customerId = HttpContext.Request.Cookies["customer"];

    // Automatically save the payment method to the subscription
    // when the first payment is successful.
    var paymentSettings = new SubscriptionPaymentSettingsOptions {
        SaveDefaultPaymentMethod = "on_subscription",
    };

    // Create the subscription. Note we're expanding the Subscription's
    // latest invoice and that invoice's confirmation_secret
    // so we can pass it to the front end to confirm the payment
    var subscriptionOptions = new SubscriptionCreateOptions
    {
        Customer = customerId,
        Items = new List<SubscriptionItemOptions>
        {
            new SubscriptionItemOptions
            {
                Price = req.PriceId,
            },
        },
        PaymentSettings = paymentSettings,
        PaymentBehavior = "default_incomplete",
    };
    subscriptionOptions.AddExpand("latest_invoice.confirmation_secret");
    var subscriptionService = new SubscriptionService();
    try
    {
        Subscription subscription = subscriptionService.Create(subscriptionOptions);

        return new SubscriptionCreateResponse
        {
          SubscriptionId = subscription.Id,
          ClientSecret = subscription.LatestInvoice.ConfirmationSecret.ClientSecret,
        };
    }
    catch (StripeException e)
    {
        Console.WriteLine($"Failed to create subscription.{e}");
        return BadRequest();
    }
}
```

If you’re using a *multi-currency Price*, use the [currency](https://docs.stripe.com/api/subscriptions/create.md#create_subscription-currency) parameter to tell the Subscription which of the Price’s currencies to use. (If you omit the `currency` parameter, then the Subscription uses the Price’s default currency.)

At this point the Subscription is `inactive` and awaiting payment. Here’s an example response. The minimum fields to store are highlighted, but store whatever your application frequently accesses.

```json
{
  "id": "sub_JgRjFjhKbtD2qz",
  "object": "subscription",
  "application_fee_percent": null,
  "automatic_tax": {
    "disabled_reason": null,
    "enabled": false,
    "liability": "null"
  },
  "billing_cycle_anchor": 1623873347,
  "billing_cycle_anchor_config": null,
  "cancel_at": null,
  "cancel_at_period_end": false,
  "canceled_at": null,
  "cancellation_details": {
    comment: null,
    feedback: null,
    reason: null
  },
  "collection_method": "charge_automatically",
  "created": 1623873347,
  "currency": "usd
  "customer": "cus_CMqDWO2xODTZqt",
  "days_until_due": null,
  "default_payment_method": null,
  "default_source": null,
  "default_tax_rates": [

  ],
  "discounts": [],
  "ended_at": null,
  "invoice_customer_balance_settings": {
    "account_tax_ids": null,
    issuer: {
      type: "self"
    }
  },
  "items": {
    "object": "list",
    "data": [
      {
        "id": "si_JgRjmS4Ur1khEx",
        "object": "subscription_item",
        "created": 1623873347,
        "current_period_end": 1626465347,
        "current_period_start": 1623873347,
        discounts: [],
        "metadata": {
        },
        "plan": {
          "id": "price_1J32RfGPZ1iASj5zHHp57z7C",
          "object": "plan",
          "active": true,
          "amount": 2000,
          "amount_decimal": "2000",
          "billing_scheme": "per_unit",
          "created": 1623864151,
          "currency": "usd",
          "interval": "month",
          "interval_count": 1,
          "livemode": false,
          "metadata": {
          },
          "nickname": null,
          "product": "prod_JgPF5xnq7qBun3",
          "tiers": null,
          "tiers_mode": null,
          "transform_usage": null,
          "trial_period_days": null,
          "usage_type": "licensed"
        },
        "price": {
          "id": "price_1J32RfGPZ1iASj5zHHp57z7C",
          "object": "price",
          "active": true,
          "billing_scheme": "per_unit",
          "created": 1623864151,
          "currency": "usd",
          "livemode": false,
          "lookup_key": null,
          "metadata": {
          },
          "nickname": null,
          "product": "prod_JgPF5xnq7qBun3",
          "recurring": {
            "interval": "month",
            "interval_count": 1,
            "trial_period_days": null,
            "usage_type": "licensed"
          },
          "tiers_mode": null,
          "transform_quantity": null,
          "type": "recurring",
          "unit_amount": 2000,
          "unit_amount_decimal": "2000"
        },
        "quantity": 1,
        "subscription": "sub_JgRjFjhKbtD2qz",
        "tax_rates": [

        ]
      }
    ],
    "has_more": false,
    "total_count": 1,
    "url": "/v1/subscription_items?subscription=sub_JgRjFjhKbtD2qz"
  },
  "latest_invoice": {
    "id": "in_1J34pzGPZ1iASj5zB87qdBNZ",
    "object": "invoice",
    "account_country": "US",
    "account_name": "Angelina's Store",
    "account_tax_ids": null,
    "amount_due": 2000,
    "amount_overpaid": 0,
    "amount_paid": 0,
    "amount_remaining": 2000,
    "amount_shipping": 0,
    "attempt_count": 0,
    "attempted": false,
    "auto_advance": false,
    "automatic_tax": {
      "disabled_reason": null,
      "enabled": false,
      liability: null,
      "status": null
    },
    "automatically_finalizes_at": null,
    "billing_reason": "subscription_update",
    "collection_method": "charge_automatically",
    "created": 1623873347,
    "currency": "usd",
    "custom_fields": null,
    "customer": "cus_CMqDWO2xODTZqt",
    "customer_address": null,
    "customer_email": "angelina@stripe.com",
    "customer_name": null,
    "customer_phone": null,
    "customer_shipping": {
      "address": {
        "city": "",
        "country": "US",
        "line1": "Berry",
        "line2": "",
        "postal_code": "",
        "state": ""
      },
      "name": "",
      "phone": null
    },
    "customer_tax_exempt": "none",
    "customer_tax_ids": [

    ],
    "default_payment_method": null,
    "default_source": null,
    "default_tax_rates": [

    ],
    "description": null,
    "discounts": [],
    "due_date": null,
    "effective_at": "1623873347
    "ending_balance": 0,
    "footer": null,
    "from_invoice": null,
    "hosted_invoice_url": "https://invoice.stripe.com/i/acct_1By64KGPZ1iASj5z/invst_JgRjzIOILGeq2MKC9T0KtyXnD5udsLp",
    "invoice_pdf": "https://pay.stripe.com/invoice/acct_1By64KGPZ1iASj5z/invst_JgRjzIOILGeq2MKC9T0KtyXnD5udsLp/pdf",
    "last_finalization_error": null,
    "latest_revision": null,
    "lines": {
      "object": "list",
      "data": [
        {
          "id": "il_1N2CjMBwKQ696a5NeOawRQP2",
          "object": "line_item",
          "amount": 2000,
          "currency": "usd",
          "description": "1 × Gold Special (at $20.00 / month)",
          "discount_amounts": [

          ],
          "discountable": true,
          "discounts": [

          ],
          "invoice": "in_1J34pzGPZ1iASj5zB87qdBNZ",
          "livemode": false,
          "metadata": {
          },
          "parent": {
            "invoice_item_details": null,
            "subscription_item_details":
            {
              "invoice_item": null
            "proration": false
            "proration_details":
            {
              "credited_items": null
            }
            subscription:
            "sub_JgRjFjhKbtD2qz"
            subscription_item:
              "si_JgRjmS4Ur1khEx"
            }
            type: "subscription_item_details"
          },
          "period": {
            "end": 1626465347,
            "start": 1623873347
          },
          "plan": {
            "id": "price_1J32RfGPZ1iASj5zHHp57z7C",
            "object": "plan",
            "active": true,
            "amount": 2000,
            "amount_decimal": "2000",
            "billing_scheme": "per_unit",
            "created": 1623864151,
            "currency": "usd",
            "interval": "month",
            "interval_count": 1,
            "livemode": false,
            "metadata": {
            },
            "nickname": null,
            "product": "prod_JgPF5xnq7qBun3",
            "tiers": null,
            "tiers_mode": null,
            "transform_usage": null,
            "trial_period_days": null,
            "usage_type": "licensed"
          },
          "price": {
            "id": "price_1J32RfGPZ1iASj5zHHp57z7C",
            "object": "price",
            "active": true,
            "billing_scheme": "per_unit",
            "created": 1623864151,
            "currency": "usd",
            "livemode": false,
            "lookup_key": null,
            "metadata": {
            },
            "nickname": null,
            "product": "prod_JgPF5xnq7qBun3",
            "recurring": {
              "interval": "month",
              "interval_count": 1,
              "trial_period_days": null,
              "usage_type": "licensed"
            },
            "tiers_mode": null,
            "transform_quantity": null,
            "type": "recurring",
            "unit_amount": 2000,
            "unit_amount_decimal": "2000"
          },
          "quantity": 1,
          "taxes": [],
        }
      ],
      "has_more": false,
      "total_count": 1,
      "url": "/v1/invoices/in_1J34pzGPZ1iASj5zB87qdBNZ/lines"
    },
    "livemode": false,
    "metadata": {
    },
    "next_payment_attempt": null,
    "number": "C008FC2-0354",
    "on_behalf_of": null,
    "parent": {
      "quote_details": null,
      "subscription_details": {
        "metadata": {},
        "pause_collection": null,
        "subscription": "sub_JgRjFjhKbtD2qz",
      }
    }
    "payment_intent": {
      "id": "pi_1J34pzGPZ1iASj5zI2nOAaE6",
      "object": "payment_intent",
      "allowed_source_types": [
        "card"
      ],
      "amount": 2000,
      "amount_capturable": 0,
      "amount_received": 0,
      "application": null,
      "application_fee_amount": null,
      "canceled_at": null,
      "cancellation_reason": null,
      "capture_method": "automatic",
      "charges": {
        "object": "list",
        "data": [

        ],
        "has_more": false,
        "total_count": 0,
        "url": "/v1/charges?payment_intent=pi_1J34pzGPZ1iASj5zI2nOAaE6"
      },
      "client_secret": "pi_1J34pzGPZ1iASj5zI2nOAaE6_secret_l7FN6ldFfXiFmJEumenJ2y2wu",
      "confirmation_method": "automatic",
      "created": 1623873347,
      "currency": "usd",
      "customer": "cus_CMqDWO2xODTZqt",
      "description": "Subscription creation",
      "invoice": "in_1J34pzGPZ1iASj5zB87qdBNZ",
      "last_payment_error": null,
      "livemode": false,
      "metadata": {
      },
      "next_action": null,
      "next_source_action": null,
      "on_behalf_of": null,
      "payment_method": null,
      "payment_method_options": {
        "card": {
          "installments": null,
          "network": null,
          "request_three_d_secure": "automatic"
        }
      },
      "payment_method_types": [
        "card"
      ],
      "receipt_email": null,
      "review": null,
      "setup_future_usage": "off_session",
      "shipping": null,
      "source": "card_1By6iQGPZ1iASj5z7ijKBnXJ",
      "statement_descriptor": null,
      "statement_descriptor_suffix": null,
      "status": "requires_confirmation",
      "transfer_data": null,
      "transfer_group": null
    },
    "payment_settings": {
      "payment_method_options": null,
      "payment_method_types": null,
      "save_default_payment_method": "on_subscription"
    },
    "period_end": 1623873347,
    "period_start": 1623873347,
    "post_payment_credit_notes_amount": 0,
    "pre_payment_credit_notes_amount": 0,
    "receipt_number": null,
    "starting_balance": 0,
    "statement_descriptor": null,
    "status": "open",
    "status_transitions": {
      "finalized_at": 1623873347,
      "marked_uncollectible_at": null,
      "paid_at": null,
      "voided_at": null
    },
    "subscription": "sub_JgRjFjhKbtD2qz",
    "subtotal": 2000,
    "tax": null,
    "tax_percent": null,
    "total": 2000,
    "total_discount_amounts": [],
    "total_tax_amounts": [],
    "transfer_data": null,
    "webhooks_delivered_at": 1623873347
  },
  "livemode": false,
  "metadata": {
  },
  "next_pending_invoice_item_invoice": null,
  "pause_collection": null,
  "pending_invoice_item_interval": null,
  "pending_setup_intent": null,
  "pending_update": null,
  "plan": {
    "id": "price_1J32RfGPZ1iASj5zHHp57z7C",
    "object": "plan",
    "active": true,
    "amount": 2000,
    "amount_decimal": "2000",
    "billing_scheme": "per_unit",
    "created": 1623864151,
    "currency": "usd",
    "interval": "month",
    "interval_count": 1,
    "livemode": false,
    "metadata": {
    },
    "nickname": null,
    "product": "prod_JgPF5xnq7qBun3",
    "tiers": null,
    "tiers_mode": null,
    "transform_usage": null,
    "trial_period_days": null,
    "usage_type": "licensed"
  },
  "quantity": 1,
  "schedule": null,
  "start": 1623873347,
  "start_date": 1623873347,
  "status": "incomplete",
  "tax_percent": null,
  "transfer_data": null,
  "trial_end": null,
  "trial_start": null
}
```

## Collect payment information

Use the [Mobile Payment Element](https://docs.stripe.com/payments/elements/mobile-payment-element.md) to collect payment details and activate the subscription. You can customize Elements to match the look and feel of your application.

The Mobile Payment Element securely collects all necessary payment details for a wide variety of payments methods. Learn about the [supported payment methods](https://docs.stripe.com/payments/payment-methods/payment-method-support.md#product-support) for Mobile Payment Element and Subscriptions.

### Add the Payment Element to your app

This step shows one way to get started, but you can use any [in-app payments integration](https://docs.stripe.com/payments/mobile/integration.md).

Initialize and present the Mobile Payment Element using the PaymentSheet class.

The Mobile Payment Element renders a sheet that allows your customer to select a payment method. The form automatically collects all necessary payments details for the payment method that they select.

Setting `allowsDelayedPaymentMethods` to true allows [delayed notification](https://docs.stripe.com/payments/payment-methods.md#payment-notification) payment methods like US bank accounts. For these payment methods, the final payment status isn’t known when the `PaymentSheet` completes, and instead succeeds or fails later. If you support these types of payment methods, inform the customer their order is confirmed and only fulfill their order (for example, ship their product) when the payment is successful.

You can customize the Payment Element to match the design of your app by using the [`appearance` property](https://docs.stripe.com/elements/appearance-api.md?platform=ios) your `PaymentSheet.Configuration` object.

### Confirm payment 

The Mobile Payment Element creates a PaymentMethod and confirms the incomplete Subscription’s first PaymentIntent, causing a charge to be made. If *Strong Customer Authentication* (SCA) is required for the payment, the Payment Element handles the authentication process before confirming the PaymentIntent.

## Listen for webhooks

To complete the integration, you need to process *webhooks* sent by Stripe. These are events triggered whenever state inside of Stripe changes, such as subscriptions creating new invoices. In your application, set up an HTTP handler to accept a POST request containing the webhook event, and verify the signature of the event:

```ruby
<<setup key>>

post '/webhook' do
  # You can use webhooks to receive information about asynchronous payment events.
  # For more about our webhook events check out https://stripe.com/docs/webhooks.
  webhook_secret = ENV['STRIPE_WEBHOOK_SECRET']
  payload = request.body.read
  if !webhook_secret.empty?
    # Retrieve the event by verifying the signature using the raw body and secret if webhook signing is configured.
    sig_header = request.env['HTTP_STRIPE_SIGNATURE']
    event = nil

    begin
      event = Stripe::Webhook.construct_event(
        payload, sig_header, webhook_secret
      )
    rescue JSON::ParserError => e
      # Invalid payload
      status 400
      return
    rescue Stripe::SignatureVerificationError => e
      # Invalid signature
      puts '⚠️  Webhook signature verification failed.'
      status 400
      return
    end
  else
    data = JSON.parse(payload, symbolize_names: true)
    event = Stripe::Event.construct_from(data)
  end
  # Get the type of webhook event sent - used to check the status of PaymentIntents.
  event_type = event['type']
  data = event['data']
  data_object = data['object']

  if event_type == 'invoice.paid'
    # Used to provision services after the trial has ended.
    # The status of the invoice will show up as paid. Store the status in your
    # database to reference when a user accesses your service to avoid hitting rate
    # limits.
    # puts data_object
  end

  if event_type == 'invoice.payment_failed'
    # If the payment fails or the customer does not have a valid payment method,
    # an invoice.payment_failed event is sent, the subscription becomes past_due.
    # Use this webhook to notify your user that their payment has
    # failed and to retrieve new card details.
    # puts data_object
  end

  if event_type == 'customer.subscription.deleted'
    # handle subscription canceled automatically based
    # upon your subscription settings. Or if the user cancels it.
    # puts data_object
  end

  content_type 'application/json'
  { status: 'success' }.to_json
end
```

```python
<<setup key>>

@app.route('/webhook', methods=['POST'])
def webhook_received():
  # You can use webhooks to receive information about asynchronous payment events.
  # For more about our webhook events check out https://stripe.com/docs/webhooks.
  webhook_secret = os.getenv('STRIPE_WEBHOOK_SECRET')
  request_data = json.loads(request.data)

  if webhook_secret:
    # Retrieve the event by verifying the signature using the raw body and secret if webhook signing is configured.
    signature = request.headers.get('stripe-signature')
    try:
      event = stripe.Webhook.construct_event(
        payload=request.data, sig_header=signature, secret=webhook_secret)
      data = event['data']
    except Exception as e:
      return e
    # Get the type of webhook event sent - used to check the status of PaymentIntents.
    event_type = event['type']
  else:
    data = request_data['data']
    event_type = request_data['type']

  data_object = data['object']

  if event_type == 'invoice.paid':
    # Used to provision services after the trial has ended.
    # The status of the invoice will show up as paid. Store the status in your
    # database to reference when a user accesses your service to avoid hitting rate
    # limits.
    print(data)

  if event_type == 'invoice.payment_failed':
    # If the payment fails or the customer does not have a valid payment method,
    # an invoice.payment_failed event is sent, the subscription becomes past_due.
    # Use this webhook to notify your user that their payment has
    # failed and to retrieve new card details.
    print(data)

  if event_type == 'customer.subscription.deleted':
    # handle subscription canceled automatically based
    # upon your subscription settings. Or if the user cancels it.
    print(data)

  return jsonify({'status': 'success'})
```

```php
<<setup key>>

$event = null;
$payload = @file_get_contents('php://input');
$sig_header = $_SERVER['HTTP_STRIPE_SIGNATURE'];
$webhook_secret = '{{STRIPE_WEBHOOK_SECRET}}';
try {
  $event = \Stripe\Webhook::constructEvent(
    $payload, $sig_header, $webhook_secret
  );
} catch(\UnexpectedValueException $e) {
  // Invalid payload
  http_response_code(400);
  exit();
} catch(\Stripe\Exception\SignatureVerificationException $e) {
  // Invalid signature
  http_response_code(400);
  exit();
}

// Handle the event
// Review important events for Billing webhooks
// https://stripe.com/docs/billing/webhooks
// Remove comment to see the various objects sent for this sample
switch ($event->type) {
  case 'invoice.paid':
    // The status of the invoice will show up as paid. Store the status in your
    // database to reference when a user accesses your service to avoid hitting rate
    // limits.
    break;
  case 'invoice.payment_failed':
    // If the payment fails or the customer does not have a valid payment method,
    // an invoice.payment_failed event is sent, the subscription becomes past_due.
    // Use this webhook to notify your user that their payment has
    // failed and to retrieve new card details.
    break;
  case 'customer.subscription.deleted':
    // handle subscription canceled automatically based
    // upon your subscription settings. Or if the user
    // cancels it.
    break;
  // ... handle other event types
  default:
    // Unhandled event type
}

http_response_code(200);
```

```java
<<setup key>>

post(
  "/webhook",
  (request, response) -> {
    String payload = request.body();
    String sigHeader = request.headers("Stripe-Signature");
    String endpointSecret = dotenv.get("STRIPE_WEBHOOK_SECRET");
    Event event = null;

    try {
      event = Webhook.constructEvent(payload, sigHeader, endpointSecret);
    } catch (SignatureVerificationException e) {
      // Invalid signature
      response.status(400);
      return "";
    }

    // Deserialize the nested object inside the event
    EventDataObjectDeserializer dataObjectDeserializer = event.getDataObjectDeserializer();
    StripeObject stripeObject = null;
    if (dataObjectDeserializer.getObject().isPresent()) {
      stripeObject = dataObjectDeserializer.getObject().get();
    } else {
      // Deserialization failed, probably due to an API version mismatch.
      // Refer to the Javadoc documentation on `EventDataObjectDeserializer` for
      // instructions on how to handle this case, or return an error here.
    }

    switch (event.getType()) {
      case "invoice.paid":
        // Used to provision services after the trial has ended.
        // The status of the invoice will show up as paid. Store the status in your
        // database to reference when a user accesses your service to avoid hitting rate
        // limits.
        break;
      case "invoice.payment_failed":
        // If the payment fails or the customer does not have a valid payment method,
        // an invoice.payment_failed event is sent, the subscription becomes past_due.
        // Use this webhook to notify your user that their payment has
        // failed and to retrieve new card details.
        break;
      case "customer.subscription.deleted":
        // handle subscription canceled automatically based
        // upon your subscription settings. Or if the user
        // cancels it.
        break;
      default:
      // Unhandled event type
    }

    response.status(200);
    return "";
  }
);
```

```javascript
<<setup key>>

app.post(
  '/webhook',
  bodyParser.raw({ type: 'application/json' }),
  async (req, res) => {
    // Retrieve the event by verifying the signature using the raw body and secret.
    let event;

    try {
      event = stripe.webhooks.constructEvent(
        req.body,
        req.headers['stripe-signature'],
        process.env.STRIPE_WEBHOOK_SECRET
      );
    } catch (err) {
      console.log(err);
      console.log(`⚠️  Webhook signature verification failed.`);
      console.log(
        `⚠️  Check the env file and enter the correct webhook secret.`
      );
      return res.sendStatus(400);
    }
    // Extract the object from the event.
    const dataObject = event.data.object;

    // Handle the event
    // Review important events for Billing webhooks
    // https://stripe.com/docs/billing/webhooks
    // Remove comment to see the various objects sent for this sample
    switch (event.type) {
      case 'invoice.paid':
        // Used to provision services after the trial has ended.
        // The status of the invoice will show up as paid. Store the status in your
        // database to reference when a user accesses your service to avoid hitting rate limits.
        break;
      case 'invoice.payment_failed':
        // If the payment fails or the customer does not have a valid payment method,
        //  an invoice.payment_failed event is sent, the subscription becomes past_due.
        // Use this webhook to notify your user that their payment has
        // failed and to retrieve new card details.
        break;
      case 'customer.subscription.deleted':
        if (event.request != null) {
          // handle a subscription canceled by your request
          // from above.
        } else {
          // handle subscription canceled automatically based
          // upon your subscription settings.
        }
        break;
      default:
      // Unexpected event type
    }
    res.sendStatus(200);
  }
);
```

```go
<<setup key>>

func handleWebhook(w http.ResponseWriter, r *http.Request) {
  if r.Method != "POST" {
    http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
    return
  }
  b, err := ioutil.ReadAll(r.Body)
  if err != nil {
    http.Error(w, err.Error(), http.StatusBadRequest)
    log.Printf("ioutil.ReadAll: %v", err)
    return
  }

  event, err := webhook.ConstructEvent(b, r.Header.Get("Stripe-Signature"), os.Getenv("STRIPE_WEBHOOK_SECRET"))
  if err != nil {
    http.Error(w, err.Error(), http.StatusBadRequest)
    log.Printf("webhook.ConstructEvent: %v", err)
    return
  }

  if event.Type == "invoice.paid" {
    // Used to provision services after the trial has ended.
    // The status of the invoice will show up as paid. Store the status in your
    // database to reference when a user accesses your service to avoid hitting rate
    // limits.
    return
  }

  if event.Type == "invoice.payment_failed" {
    // If the payment fails or the customer does not have a valid payment method,
    // an invoice.payment_failed event is sent, the subscription becomes past_due.
    // Use this webhook to notify your user that their payment has
    // failed and to retrieve new card details.
    return
  }

  if event.Type == "customer.subscription.deleted" {
    // handle subscription canceled automatically based
    // upon your subscription settings. Or if the user cancels it. {
    return
  }
}
```

```dotnet
<<setup key>>

[HttpPost("webhook")]
public async Task<IActionResult> Webhook()
{
  var json = await new StreamReader(HttpContext.Request.Body).ReadToEndAsync();
  Event stripeEvent;
  try
  {
    stripeEvent = EventUtility.ConstructEvent(
      json,
      Request.Headers["Stripe-Signature"],
      this.options.Value.WebhookSecret
    );
    Console.WriteLine($"Webhook notification with type: {stripeEvent.Type} found for {stripeEvent.Id}");
  }
  catch (Exception e)
  {
    Console.WriteLine($"Something failed {e}");
    return BadRequest();
  }

  if (stripeEvent.Type == "invoice.paid")
  {
    // Used to provision services after the trial has ended.
    // The status of the invoice will show up as paid. Store the status in your
    // database to reference when a user accesses your service to avoid hitting rate
    // limits.
  }

  if (stripeEvent.Type == "invoice.payment_failed")
  {
    // If the payment fails or the customer does not have a valid payment method,
    // an invoice.payment_failed event is sent, the subscription becomes past_due.
    // Use this webhook to notify your user that their payment has
    // failed and to retrieve new card details.
  }

  if (stripeEvent.Type == "customer.subscription.deleted")
  {
    // handle subscription canceled automatically based
    // upon your subscription settings. Or if the user cancels it.
  }
  return Ok();
}
```

During development, use the Stripe CLI to [observe webhooks and forward them to your application](https://docs.stripe.com/webhooks.md#test-webhook). Run the following in a new terminal while your development app is running:

```bash
stripe listen --forward-to localhost:4242/webhook
```

For production, set up a webhook endpoint URL in the Dashboard, or use the [Webhook Endpoints API](https://docs.stripe.com/api/webhook_endpoints.md).

You’ll listen to a couple of events to complete the remaining steps in this guide. See [Subscription events](https://docs.stripe.com/billing/subscriptions/overview.md#subscription-events) for more details about subscription-specific webhooks.

## Provision access to your service

Now that the subscription is active, give your user access to your service.  To do this, listen to the `customer.subscription.created`, `customer.subscription.updated`, and `customer.subscription.deleted` events.  These events pass a subscription object which contains a `status` field indicating whether the subscription is active, past due, or canceled.  See [the subscription lifecycle](https://docs.stripe.com/billing/subscriptions/overview.md#subscription-lifecycle) for a complete list of statuses.

In your webhook handler:

1. Verify the subscription status.  If it’s `active` then your user has paid for your product.
1. Check the product the customer subscribed to and grant access to your service. Checking the product instead of the price gives you more flexibility if you need to change the pricing or billing interval.
1. Store the `product.id`, `subscription.id` and `subscription.status` in your database along with the `customer.id` you already saved.  Check this record when determining which features to enable for the user in your application.

The state of a subscription might change at any point during its lifetime, even if your application does not directly make any calls to Stripe.  For example, a renewal might fail due to an expired credit card, which puts the subscription into a past due state.  Or, if you implement the [customer portal](https://docs.stripe.com/customer-management.md), a user might cancel their subscription without directly visiting your application.  Implementing your handler correctly keeps your application state in sync with Stripe.

## Cancel the subscription

It’s common to allow customers to cancel their subscriptions. This example adds a cancellation option to the account settings page.

The example collects the subscription ID on the frontend, but your application can get this information from your database for your logged in user.

![Sample subscription cancelation interface.](images/billing/subscriptions/fixed-price-subscriptions-guide-account-settings.png)
Account settings with the ability to cancel the subscription


On the backend, define the endpoint for your app to call.

```ruby
<<setup key>>

post '/cancel-subscription' do
  content_type 'application/json'
  data = JSON.parse request.body.read

  deleted_subscription = Stripe::Subscription.cancel(data['subscriptionId'])

  deleted_subscription.to_json
end
```

```python
<<setup key>>

@app.route('/cancel-subscription', methods=['POST'])
def cancelSubscription():
    data = json.loads(request.data)
    try:
         # Cancel the subscription by deleting it
        deletedSubscription = stripe.Subscription.delete(data['subscriptionId'])
        return jsonify(deletedSubscription)
    except Exception as e:
        return jsonify(error=str(e)), 403
```

```php
<<setup key>>

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
  $body = file_get_contents('php://input');
  $json = json_decode($body);

  $subscription = $stripe->subscriptions->retrieve(
    $json->subscriptionId
  );
  $subscription->delete();

  header('Content-Type: application/json');
  echo json_encode([
    'subscription' => $subscription,
  ]);
}
```

```java
<<setup key>>

post(
      "/cancel-subscription",
      (request, response) -> {
        response.type("application/json");
        // Set the default payment method on the customer
        CancelPostBody postBody = gson.fromJson(
          request.body(),
          CancelPostBody.class
        );

        Subscription subscription = Subscription.retrieve(
          postBody.getSubscriptionId()
        );

        Subscription deletedSubscription = subscription.cancel();
        return deletedSubscription.toJson();
      }
    );
```

```javascript
<<setup key>>

app.post('/cancel-subscription', async (req, res) => {
  // Delete the subscription
  const deletedSubscription = await stripe.subscriptions.del(
    req.body.subscriptionId
  );
  res.send(deletedSubscription);
});
```

```go
<<setup key>>

func handleCancelSubscription(w http.ResponseWriter, r *http.Request) {
  if r.Method != "POST" {
    http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
    return
  }
  var req struct {
    SubscriptionID string `json:"subscriptionId"`
  }
  if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("json.NewDecoder.Decode: %v", err)
    return
  }
  s, err := subscription.Cancel(req.SubscriptionID, nil)
  if err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("subscription.Cancel: %v", err)
    return
  }
  writeJSON(w, s)
}
```

```dotnet
using Newtonsoft.Json;

public class CancelSubscriptionRequest
{
    [JsonProperty("subscriptionId")]
    public string Subscription { get; set; }
}
```

```dotnet
<<setup key>>

[HttpPost("cancel-subscription")]
public ActionResult<Subscription> CancelSubscription([FromBody] CancelSubscriptionRequest req)
{
    var service = new SubscriptionService();
    var subscription = service.Cancel(req.Subscription, null);
    return subscription;
}
```

Your backend receives a `customer.subscription.deleted` event.

After the subscription is canceled, update your database to remove the Stripe subscription ID you previously stored, and limit access to your service.

When a subscription is canceled, it can’t be reactivated. Instead, collect updated billing information from your customer, update their default payment method, and create a new subscription with their existing customer record.

## Test your integration

### Test payment methods

Use the following table to test different payment methods and scenarios.

| Payment method    | Scenario                                                                                         | How to test                                                                                                                                                                                                  |
| ----------------- | ------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| BECS Direct Debit | Your customer successfully pays with BECS Direct Debit.                                          | Fill out the form using the account number `900123456` and BSB `000-000`. The confirmed PaymentIntent initially transitions to `processing`, then transitions to the `succeeded` status three minutes later. |
| BECS Direct Debit | Your customer’s payment fails with an `account_closed` error code.                               | Fill out the form using the account number `111111113` and BSB `000-000`.                                                                                                                                    |
| Credit card       | The card payment succeeds and doesn’t require authentication.                                    | Fill out the credit card form using the credit card number `4242 4242 4242 4242` with any expiration, CVC, and postal code.                                                                                  |
| Credit card       | The card payment requires *authentication*.                                                      | Fill out the credit card form using the credit card number `4000 0025 0000 3155` with any expiration, CVC, and postal code.                                                                                  |
| Credit card       | The card is declined with a decline code like `insufficient_funds`.                              | Fill out the credit card form using the credit card number `4000 0000 0000 9995` with any expiration, CVC, and postal code.                                                                                  |
| SEPA Direct Debit | Your customer successfully pays with SEPA Direct Debit.                                          | Fill out the form using the account number `AT321904300235473204`. The confirmed PaymentIntent initially transitions to processing, then transitions to the succeeded status three minutes later.            |
| SEPA Direct Debit | Your customer’s PaymentIntent status transitions from `processing` to `requires_payment_method`. | Fill out the form using the account number `AT861904300235473202`.                                                                                                                                           |

### Monitor events

Set up webhooks to listen to subscription change events, such as upgrades and cancellations. Learn more about [subscription webhooks](https://docs.stripe.com/billing/subscriptions/webhooks.md). You can view events in the [Dashboard](https://dashboard.stripe.com/test/events) or with the [Stripe CLI](https://docs.stripe.com/webhooks.md#test-webhook).

For more details, see [testing your Billing integration](https://docs.stripe.com/billing/testing.md).

## Let customers change their plans

To let your customers change their subscription, collect the price ID of the option they want to change to. Then send the new price ID from the app to a backend endpoint. This example also passes the subscription ID, but you can retrieve it from your database for your logged in user.

On the backend, define the endpoint for your frontend to call, passing the subscription ID and the new price ID. The subscription is now Premium, at 15 USD per month, instead of Basic at 5 USD per month.

```ruby
<<setup key>>

post '/update-subscription' do
  content_type 'application/json'
  data = JSON.parse request.body.read

  subscription = Stripe::Subscription.retrieve(data['subscriptionId'])

  updated_subscription =
    Stripe::Subscription.update(
      data['subscriptionId'],
      cancel_at_period_end: false,
      items: [
        { id: subscription.items.data[0].id, price: 'price_H1NlVtpo6ubk0m' }
      ]
    )

  updated_subscription.to_json
end
```

```python
<<setup key>>

@app.route('/update-subscription', methods=['POST'])
def updateSubscription():
    data = json.loads(request.data)
    try:
        subscription = stripe.Subscription.retrieve(data['subscriptionId'])

        updatedSubscription = stripe.Subscription.modify(
            data['subscriptionId'],
            cancel_at_period_end=False,
            items=[{
                'id': subscription['items']['data'][0].id,
                'price': 'price_H1NlVtpo6ubk0m',
            }]
        )
        return jsonify(updatedSubscription)
    except Exception as e:
        return jsonify(error=str(e)), 403
```

```php
<<setup key>>

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
  $body = file_get_contents('php://input');
  $json = json_decode($body);

  $subscription = $stripe->subscriptions->retrieve($json->subscriptionId);

  $updated_subscription = $stripe->subscriptions->update($json->subscriptionId, [
    'items' => [
      [
        'id' => $subscription->items->data[0]->id,
        'price' => 'price_H1NlVtpo6ubk0m',
      ],
    ],
  ]);

  header('Content-Type: application/json');
  echo json_encode([
    'updatedSubscription' => $updated_subscription,
  ]);
}
```

```java
<<setup key>>

post(
  "/update-subscription",
  (request, response) -> {
    response.type("application/json");
    // Set the default payment method on the customer
    UpdatePostBody postBody = gson.fromJson(
      request.body(),
      UpdatePostBody.class
    );

    Subscription subscription = Subscription.retrieve(
      postBody.getSubscriptionId()
    );

    SubscriptionUpdateParams params = SubscriptionUpdateParams
      .builder()
      .addItem(
        SubscriptionUpdateParams
          .Item.builder()
          .setId(subscription.getItems().getData().get(0).getId())
          .setPrice("price_H1NlVtpo6ubk0m")
          .build()
      )
      .setCancelAtPeriodEnd(false)
      .build();

    subscription.update(params);
    return subscription.toJson();
  }
);
```

```javascript
<<setup key>>

app.post('/update-subscription', async (req, res) => {
  const subscription = await stripe.subscriptions.retrieve(
    req.body.subscriptionId
  );
  const updatedSubscription = await stripe.subscriptions.update(
    req.body.subscriptionId,
    {
      cancel_at_period_end: false,
      items: [
        {
          id: subscription.items.data[0].id,
          price: "price_H1NlVtpo6ubk0m",
        },
      ],
    }
  );

  res.send(updatedSubscription);
});
```

```go
<<setup key>>

func handleUpdateSubscription(w http.ResponseWriter, r *http.Request) {
  if r.Method != "POST" {
    http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
    return
  }

  var req struct {
    SubscriptionID string `json:"subscriptionId"`
    NewPriceID     string `json:"newPriceId"`
  }

  if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("json.NewDecoder.Decode: %v", err)
    return
  }

  s, err := subscription.Get(req.SubscriptionID, nil)
  if err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("subscription.Get: %v", err)
    return
  }

  params := &stripe.SubscriptionParams{
    CancelAtPeriodEnd: stripe.Bool(false),
    Items: []*stripe.SubscriptionItemsParams{{
      ID:    stripe.String(s.Items.Data[0].ID),
      Price: stripe.String("price_H1NlVtpo6ubk0m"),
    }},
  }

  updatedSubscription, err := subscription.Update(req.SubscriptionID, params)

  if err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("subscription.Update: %v", err)
    return
  }

  writeJSON(w, updatedSubscription)
}
```

```dotnet
using Newtonsoft.Json;

public class UpdateSubscriptionRequest
{
    [JsonProperty("subscriptionId")]
    public string Subscription { get; set; }

    [JsonProperty("newPriceId")]
    public string NewPrice { get; set; }
}
```

```dotnet
<<setup key>>

[HttpPost("update-subscription")]
public ActionResult<Subscription> UpdateSubscription([FromBody] UpdateSubscriptionRequest req)
{
    var service = new SubscriptionService();
    var subscription = service.Get(req.Subscription);

    var options = new SubscriptionUpdateOptions
    {
        CancelAtPeriodEnd = false,
        Items = new List<SubscriptionItemOptions>
        {
            new SubscriptionItemOptions
            {
                Id = subscription.Items.Data[0].Id,
                Price = "price_H1NlVtpo6ubk0m",
            }
        }
    };
    var updatedSubscription = service.Update(req.Subscription, options);
    return updatedSubscription;
}
```

Your application receives a `customer.subscription.updated` event.

## Preview a price change

When your customer changes their subscription, there’s often an adjustment to the amount they owe, known as a [proration](https://docs.stripe.com/billing/subscriptions/prorations.md). You can use the [create preview invoice endpoint](https://docs.stripe.com/api/invoices/create_preview.md) to display the adjusted amount to your customers.

From the app, pass the preview invoice details to a backend endpoint.

On the backend, define the endpoint for your frontend to call.

```ruby
<<setup key>>

post '/create-preview-invoice' do
  content_type 'application/json'
  data = JSON.parse request.body.read

  subscription = Stripe::Subscription.retrieve(data['subscriptionId'])

  invoice =
    Stripe::Invoice.create_preview(
      customer: data['customerId'],
      subscription: data['subscriptionId'],
      subscription_details: {
        items: [
          { id: subscription.items.data[0].id, deleted: true },
          { price: ENV[data['newPriceId']], deleted: false }
        ]
      }
    )

  invoice.to_json
end
```

```python
<<setup key>>

@app.route('/create-preview-invoice', methods=['POST'])
def createPreviewInvoice():
    data = json.loads(request.data)
    try:
        # Retrieve the subscription
        subscription = stripe.Subscription.retrieve(data['subscriptionId'])

        # Retrieve the invoice
        invoice = stripe.Invoice.create_preview(
            customer=data['customerId'],
            subscription=data['subscriptionId'],
            subscription_details={
              "items": [
                  {
                      'id': subscription['items']['data'][0].id,
                      'deleted': True,
                  },
                  {
                      'price': 'price_H1NlVtpo6ubk0m',
                      'deleted': False,
                  }
              ]
            }
        )
        return jsonify(invoice)
    except Exception as e:
        return jsonify(error=str(e)), 403
```

```php
<<setup key>>

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
  $body = file_get_contents('php://input');
  $json = json_decode($body);

  $subscription = $stripe->subscriptions->retrieve($json->subscriptionId);

  $invoice = $stripe->invoices->createPreview([
    'customer' => $json->customerId,
    'subscription' => $json->subscriptionId,
    'subscription_details' => [
      'items' => [
        [
          'id' => $subscription->items->data[0]->id,
          'deleted' => true
        ],
        [
          'price' => $json->newPriceId,
          'deleted' => false
        ],
      ],
    ],
  ]);

  header('Content-Type: application/json');
  echo json_encode([
    'invoice' => $invoice,
  ]);
}
```

```java
<<setup key>>

post(
  "/create-preview-invoice",
  (request, response) -> {
    response.type("application/json");
    PreviewInvoicePostBody postBody = gson.fromJson(
      request.body(),
      PreviewInvoicePostBody.class
    );

    Subscription subscription = Subscription.retrieve(
      postBody.getSubscriptionId()
    );

    InvoiceCreatePreviewParams invoiceParams = InvoiceCreatePreviewParams
      .builder()
      .setCustomer(postBody.getCustomerId())
      .setSubscription(postBody.getSubscriptionId())
      .setSubscriptionDetails(
        InvoiceCreatePreviewParams.SubscriptionDetails.builder()
          .addItem(
            InvoiceCreatePreviewParams.SubscriptionDetails.Item.builder()
              .setId(subscription.getItems().getData().get(0).getId())
              .setDeleted(true)
              .build()
          )
          .addItem(
            InvoiceCreatePreviewParams.SubscriptionDetails.Item.builder()
              .setPrice(dotenv.get(postBody.getNewPriceId().toUpperCase()))
              .build()
          )
          .build()
      )
      .build();

    Invoice invoice = Invoice.createPreview(invoiceParams);

    return invoice.toJson();
  }
);
```

```javascript
<<setup key>>

app.post('/create-preview-invoice', async (req, res) => {
  const subscription = await stripe.subscriptions.retrieve(
    req.body.subscriptionId
  );

  const invoice = await stripe.invoices.createPreview({
    customer: req.body.customerId,
    subscription: req.body.subscriptionId,
    subscription_details: {
      items: [
        {
          id: subscription.items.data[0].id,
          deleted: true,
        },
        {
          // This price ID is the price you want to change the subscription to.
          price: 'price_H1NlVtpo6ubk0m',
          deleted: false,
        },
      ],
    }
  });
  res.send(invoice);
});
```

```go
<<setup key>>

func handleCreatePreviewInvoice(w http.ResponseWriter, r *http.Request) {
  if r.Method != "POST" {
    http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
    return
  }
  var req struct {
    SubscriptionID string `json:"subscriptionId"`
    CustomerID     string `json:"customerId"`
    NewPriceID     string `json:"newPriceId"`
  }

  if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("json.NewDecoder.Decode: %v", err)
    return
  }

  s, err := subscription.Get(req.SubscriptionID, nil)
  if err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("subscription.Get: %v", err)
    return
  }
  params := &stripe.InvoiceCreatePreviewParams{
    Customer:     stripe.String(req.CustomerID),
    Subscription: stripe.String(req.SubscriptionID),
    SubscriptionDetails: &stripe.InvoiceCreatePreviewSubscriptionDetailsParams{
      Items: []*stripe.SubscriptionItemsParams{{
        ID:      stripe.String(s.Items.Data[0].ID),
        Deleted: stripe.Bool(true),
      }, {
        Price:   stripe.String(os.Getenv(req.NewPriceID)),
        Deleted: stripe.Bool(false),
      }},
    },
  }
  in, err := invoice.CreatePreview(params)

  if err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("invoice.CreatePreview: %v", err)
    return
  }

  writeJSON(w, in)
}
```

```dotnet
using Newtonsoft.Json;

public class CreatePreviewInvoiceRequest
{
    [JsonProperty("customerId")]
    public string Customer { get; set; }

    [JsonProperty("subscriptionId")]
    public string Subscription { get; set; }

    [JsonProperty("newPriceId")]
    public string NewPrice { get; set; }
}
```

```dotnet
<<setup key>>

[HttpPost("create-preview-invoice")]
public ActionResult<Invoice> CreatePreviewInvoice([FromBody] CreatePreviewInvoiceRequest req)
{
    var service = new SubscriptionService();
    var subscription = service.Get(req.Subscription);

    var invoiceService = new InvoiceService();
    var options = new InvoiceCreatePreviewOptions
    {
        Customer = req.Customer,
        Subscription = req.Subscription,
        SubscriptionDetails = new InvoiceSubscriptionDetailsOptions
        {
            Items = new List<InvoiceSubscriptionItemOptions>
            {
                new InvoiceSubscriptionItemOptions
                {
                    Id = subscription.Items.Data[0].Id,
                    Deleted = true,
                },
                new InvoiceSubscriptionItemOptions
                {
                    Price = Environment.GetEnvironmentVariable(req.NewPrice),
                    Deleted = false,
                },
            },
        },
    };
    Invoice previewInvoice = invoiceService.CreatePreview(options);
    return previewInvoice;
}
```

## Display the customer payment method

Displaying the brand and last four digits of your customer’s card can help them know which card is being charged, or if they need to update their payment method.

On the front end, send the payment method ID to a back-end endpoint that retrieves the payment method details.

On the back end, define the endpoint for your app to call.

```ruby
<<setup key>>

post '/retrieve-customer-payment-method' do
  content_type 'application/json'
  data = JSON.parse request.body.read

  payment_method = Stripe::PaymentMethod.retrieve(data['paymentMethodId'])

  payment_method.to_json
end
```

```python
<<setup key>>

@app.route('/retrieve-customer-payment-method', methods=['POST'])
def retrieveCustomerPaymentMethod():
    data = json.loads(request.data)
    try:
        paymentMethod = stripe.PaymentMethod.retrieve(
            data['paymentMethodId'],
        )
        return jsonify(paymentMethod)
    except Exception as e:
        return jsonify(error=str(e)), 403
```

```php
<<setup key>>

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
  $body = file_get_contents('php://input');
  $json = json_decode($body);

  $payment_method = $stripe->paymentMethods->retrieve($json->paymentMethodId);

  header('Content-Type: application/json');
  echo json_encode([
    'paymentMethod' => $payment_method,
  ]);
}
```

```java
<<setup key>>

post(
  "/retrieve-customer-payment-method",
  (request, response) -> {
    response.type("application/json");
    // Set the default payment method on the customer
    PaymentMethodBody paymentMethodBody = gson.fromJson(
      request.body(),
      PaymentMethodBody.class
    );

    PaymentMethod paymentMethod = PaymentMethod.retrieve(
      paymentMethodBody.getPaymentMethodId()
    );
    return paymentMethod.toJson();
  }
);
```

```javascript
<<setup key>>

app.post('/retrieve-customer-payment-method', async (req, res) => {
  const paymentMethod = await stripe.paymentMethods.retrieve(
    req.body.paymentMethodId
  );

  res.send(paymentMethod);
});
```

```go
<<setup key>>

func handleRetrieveCustomerPaymentMethod(w http.ResponseWriter, r *http.Request) {
  if r.Method != "POST" {
    http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
    return
  }
  var req struct {
    PaymentMethodID string `json:"paymentMethodId"`
  }
  if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("json.NewDecoder.Decode: %v", err)
    return
  }

  pm, err := paymentmethod.Get(req.PaymentMethodID, nil)
  if err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("paymentmethod.Get: %v", err)
    return
  }

  writeJSON(w, pm)
}
```

```dotnet
using Newtonsoft.Json;

public class RetrieveCustomerPaymentMethodRequest
{
    [JsonProperty("paymentMethodId")]
    public string PaymentMethod { get; set; }
}
```

```dotnet
<<setup key>>

[HttpPost("retrieve-customer-payment-method")]
public ActionResult<PaymentMethod> RetrieveCustomerPaymentMethod([FromBody] RetrieveCustomerPaymentMethodRequest req)
{
    var service = new PaymentMethodService();
    var paymentMethod = service.Get(req.PaymentMethod);
    return paymentMethod;
}
```

Example response:

```json
{
  "id": "pm_1GcbHY2eZvKYlo2CoqlVxo42",
  "object": "payment_method",
  "billing_details": {
    "address": {
      "city": null,
      "country": null,
      "line1": null,
      "line2": null,
      "postal_code": null,
      "state": null
    },
    "email": null,
    "name": null,
    "phone": null
  },
  "card": {
    "brand": "visa",
    "checks": {
      "address_line1_check": null,
      "address_postal_code_check": null,
      "cvc_check": "pass"
    },
    "country": "US",
    "exp_month": 8,
    "exp_year": 2021,
    "fingerprint": "Xt5EWLLDS7FJjR1c",
    "funding": "credit",
    "generated_from": null,
    "last4": "4242",
    "three_d_secure_usage": {
      "supported": true
    },
    "wallet": null
  },
  "created": 1588010536,
  "customer": "cus_HAxB7dVQxhoKLh",
  "livemode": false,
  "metadata": {},
  "type": "card"
}
```

We recommend that you save the `paymentMethod.id` and `last4` in your database, for example, `paymentMethod.id` as `stripeCustomerPaymentMethodId` in your `users` collection or table. You can optionally store `exp_month`, `exp_year`, `fingerprint`, `billing_details` as needed. This is to limit the number of calls you make to Stripe—for both performance efficiency and to avoid possible rate limiting.

## Disclose Stripe to your customers 

Stripe collects information on customer interactions with Elements to provide services to you, prevent fraud, and improve its services. This includes using cookies and IP addresses to identify which Elements a customer saw during a single checkout session. You’re responsible for disclosing and obtaining all rights and consents necessary for Stripe to use data in these ways. For more information, visit our [privacy center](https://stripe.com/legal/privacy-center#as-a-business-user-what-notice-do-i-provide-to-my-end-customers-about-stripe).

# React Native

> This is a React Native for when platform is react-native. View the original doc at https://docs.stripe.com/billing/subscriptions/build-subscriptions?platform=react-native.

Customize with the [Appearance API](https://docs.stripe.com/elements/appearance-api.md).

Use this guide to learn how to sell fixed-price *subscriptions*. You’ll use the [Mobile Payment Element](https://docs.stripe.com/payments/accept-a-payment.md?platform=ios) to create a custom payment form that you embed in your app.

If you’re selling digital products or services that are consumed within your app (for example, subscriptions, in-game currencies, game levels, access to premium content, or unlocking a full version), you must use Apple’s in-app purchase APIs. This rule has some exceptions, including one-to-one personal services and [apps based in specific regions](https://support.stripe.com/questions/changes-to-mobile-app-store-rules). See the [App Store review guidelines](https://developer.apple.com/app-store/review/guidelines/#payments) for more information.

## Build your subscription 

This guide shows you how to:

- Model your business by building a product catalog.
- Create a registration process to add customers.
- Create subscriptions and collect payment information.
- Test and monitor the status of payments and subscriptions.
- Let customers change their plan or cancel the subscription.

## How to model it on Stripe

[Subscriptions](https://docs.stripe.com/api/subscriptions.md) simplify your billing by automatically creating *Invoices* and [PaymentIntents](https://docs.stripe.com/api/payment_intents.md) for you.  To create and activate a subscription, you need to first create a *Product* to model what is being sold, and a *Price* which determines the interval and amount to charge. You also need a [Customer](https://docs.stripe.com/api/customers.md) to store *PaymentMethods* used to make each recurring payment.

### API object definitions

| Resource                                                                      | Definition                                                                                                                                                                                                                                                                                                                                                                                                    |
| ----------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [Entitlement](https://docs.stripe.com/api/entitlements/active-entitlement.md) | Represents a customer’s access to a feature included in a service product that they subscribe to. When you create a subscription for a customer’s recurring purchase of a product, an active entitlement is automatically created for each feature associated with that product. When a customer accesses your services, use their active entitlements to enable the features included in their subscription. |
| [Feature](https://docs.stripe.com/api/entitlements/feature.md)                | Represents a function or ability that your customers can access when they subscribe to a service product. You can include features in a product by creating ProductFeatures.                                                                                                                                                                                                                                  |
| [Invoice](https://docs.stripe.com/api/invoices.md)                            | A statement of amounts a customer owes that tracks payment statuses from draft through paid or otherwise finalized. Subscriptions automatically generate invoices.                                                                                                                                                                                                                                            |
| [PaymentIntent](https://docs.stripe.com/api/payment_intents.md)               | A way to build dynamic payment flows. A PaymentIntent tracks the lifecycle of a customer checkout flow and triggers additional authentication steps when required by regulatory mandates, custom Radar fraud rules, or redirect-based payment methods. Invoices automatically create PaymentIntents.                                                                                                          |
| [PaymentMethod](https://docs.stripe.com/api/payment_methods.md)               | A customer’s payment methods that they use to pay for your products. For example, you can store a credit card on a Customer object and use it to make recurring payments for that customer. Typically used with the Payment Intents or Setup Intents APIs.                                                                                                                                                    |
| [Price](https://docs.stripe.com/api/prices.md)                                | Defines the unit price, currency, and billing cycle for a product.                                                                                                                                                                                                                                                                                                                                            |
| [Product](https://docs.stripe.com/api/products.md)                            | A good or service that your business sells. A service product can include one or more features.                                                                                                                                                                                                                                                                                                               |
| [ProductFeature](https://docs.stripe.com/api/product-feature.md)              | Represents a single feature’s inclusion in a single product. Each product is associated with a ProductFeature for each feature that it includes, and each feature is associated with a ProductFeature for each product that includes it.                                                                                                                                                                      |
| [Subscription](https://docs.stripe.com/api/subscriptions.md)                  | Represents a customer’s scheduled recurring purchase of a product. Use a subscription to collect payments and provide repeated delivery of or continuous access to a product.                                                                                                                                                                                                                                 |

Here’s an example of how products, features, and entitlements work together. Imagine that you want to set up a subscription service that offers two tiers: a standard product with basic functionality, and an advanced product that adds extended functionality.

1. You create two features: `basic_features` and `extended_features`.
1. You create two products: `standard_product` and `advanced_product`.
1. For the standard product, you create one ProductFeature that associates `basic_features` with `standard_product`.
1. For the advanced product, you create two ProductFeatures: one that associates `basic_features` with `advanced_product` and one that associates `extended_features` with `advanced_product`.

A customer, `first_customer`, subscribes to the standard product. When you create the subscription, Stripe automatically creates an Entitlement that associates `first_customer` with `basic_features`.

Another customer, `second_customer`, subscribes to the advanced product. When you create the Subscription, Stripe automatically creates two Entitlements: one that associates `second_customer` with `basic_features`, and one that associates `second_customer` with `extended_features`.

You can determine which features to provision for a customer by [retrieving their active entitlements or listening to the Active Entitlement Summary event](https://docs.stripe.com/billing/entitlements.md#entitlements). You don’t have to retrieve their subscriptions, products, and features.

## Set up Stripe

And then install the Stripe CLI. The CLI provides webhook testing and you can run it to make API calls to Stripe.  This guide shows how to use the CLI to set up a pricing model in a later section.

```bash
\# Install Homebrew to run this command: https://brew.sh/
brew install stripe/stripe-cli/stripe

# Connect the CLI to your dashboard
stripe login
```

```bash
\# 1. Download the latest `mac-os` tar.gz file of your cpu architecture type from https://github.com/stripe/stripe-cli/releases/latest

# 2. Tar the downloaded file
tar -xvf stripe_[X.X.X]_mac-os_[ARCH_TYPE].tar.gz

# Optionally, install the binary in a location where you can execute it globally (for example, `/usr/local/bin`).

# Connect the CLI to your dashboard
stripe login
```

To install the Stripe CLI on Debian and Ubuntu-based distributions:

```bash
brew install stripe/stripe-cli/stripe

# Connect the CLI to your dashboard
stripe login
```

On April 5th, 2024, we changed Stripe CLI’s GPG key to install the Stripe CLI through apt. If you configured the public key before April 5th, you’ll encounter this error:

```
W: An error occurred during the signature verification. The repository is not updated and the previous index files will be used. GPG error: https://packages.stripe.dev/stripe-cli-debian-local stable InRelease: The following signatures were invalid: EXPKEYSIG DEEBD57F917C83E3 Stripe <security@stripe.com>
W: Failed to fetch https://packages.stripe.dev/stripe-cli-debian-local/dists/stable/InRelease  The following signatures were invalid: EXPKEYSIG DEEBD57F917C83E3 Stripe <security@stripe.com>
W: Some index files failed to download. They have been ignored, or old ones used instead
```

To resolve this error, refresh Stripe’s GPG key by following step 1.

To install the Stripe CLI on Debian and Ubuntu-based distributions:

```bash
\# 1. Add Stripe CLI's GPG key to the apt sources keyring:
curl -s https://packages.stripe.dev/api/security/keypair/stripe-cli-gpg/public | gpg --dearmor | sudo tee /usr/share/keyrings/stripe.gpg

# 2. Add CLI's apt repository to the apt sources list:
echo "deb [signed-by=/usr/share/keyrings/stripe.gpg] https://packages.stripe.dev/stripe-cli-debian-local stable main" | sudo tee -a /etc/apt/sources.list.d/stripe.list

# 3. Update the package list
sudo apt update

# 4. Install the CLI
sudo apt install stripe

# 5. Connect the CLI to your dashboard
stripe login
```

```bash
\# 1. Add CLI's yum repository to the yum sources list:
echo -e "[Stripe]\nname=stripe\nbaseurl=https://packages.stripe.dev/stripe-cli-rpm-local/\nenabled=1\ngpgcheck=0" >> /etc/yum.repos.d/stripe.repo

# 2. Install the CLI
sudo yum install stripe
```

```bash
\# Download the latest `linux` tar.gz file from <https://github.com/stripe/stripe-cli/releases/latest>

# Unzip the file:
tar -xvf stripe_X.X.X_linux_x86_64.tar.gz

# Move `./stripe` to your execution path.

# Connect the CLI to your dashboard
stripe login
```

```bash
\# 1. Download the latest `windows` zip file from
# https://github.com/stripe/stripe-cli/releases/latest

# 2. Unzip the `stripe_X.X.X_windows_x86_64.zip` file

# 3. Run the unzipped `.exe` file

# Connect the CLI to your dashboard
stripe login
```

```bash
\# See https://scoop.sh

scoop bucket add stripe https://github.com/stripe/scoop-stripe-cli.git

scoop install stripe
```

For additional install options, see [Get started with the Stripe CLI](https://docs.stripe.com/stripe-cli.md).

## Create the pricing model

## Create the customer

Stripe needs a *customer* for each subscription.  In your application frontend, collect any necessary information from your users and pass it to the backend.

If you need to collect address details, the Address Element enables you to collect a shipping or billing address for your customers. For more information on the Address Element, visit the [Address Element](https://docs.stripe.com/elements/address-element.md) page.

On the server, create the Stripe customer object.

```dotnet
StripeConfiguration.ApiKey = "<<secret key>>";

var options = new CustomerCreateOptions
{
    Email = "{{CUSTOMER_EMAIL}}",
    Name = "{{CUSTOMER_NAME}}",
    Shipping = new ShippingOptions
    {
        Address = new AddressOptions
        {
            City = "Brothers",
            Country = "US",
            Line1 = "27 Fredrick Ave",
            PostalCode = "97712",
            State = "CA",
        },
        Name = "{{CUSTOMER_NAME}}",
    },
    Address = new AddressOptions
    {
        City = "Brothers",
        Country = "US",
        Line1 = "27 Fredrick Ave",
        PostalCode = "97712",
        State = "CA",
    },
};
var service = new CustomerService();
Customer customer = service.Create(options);
```

```go
stripe.Key = "<<secret key>>"

params := &stripe.CustomerParams{
  Email: stripe.String("{{CUSTOMER_EMAIL}}"),
  Name: stripe.String("{{CUSTOMER_NAME}}"),
  Shipping: &stripe.CustomerShippingParams{
    Address: &stripe.AddressParams{
      City: stripe.String("Brothers"),
      Country: stripe.String("US"),
      Line1: stripe.String("27 Fredrick Ave"),
      PostalCode: stripe.String("97712"),
      State: stripe.String("CA"),
    },
    Name: stripe.String("{{CUSTOMER_NAME}}"),
  },
  Address: &stripe.AddressParams{
    City: stripe.String("Brothers"),
    Country: stripe.String("US"),
    Line1: stripe.String("27 Fredrick Ave"),
    PostalCode: stripe.String("97712"),
    State: stripe.String("CA"),
  },
};
result, err := customer.New(params);
```

```java
Stripe.apiKey = "<<secret key>>";

CustomerCreateParams params =
  CustomerCreateParams.builder()
    .setEmail("{{CUSTOMER_EMAIL}}")
    .setName("{{CUSTOMER_NAME}}")
    .setShipping(
      CustomerCreateParams.Shipping.builder()
        .setAddress(
          CustomerCreateParams.Shipping.Address.builder()
            .setCity("Brothers")
            .setCountry("US")
            .setLine1("27 Fredrick Ave")
            .setPostalCode("97712")
            .setState("CA")
            .build()
        )
        .setName("{{CUSTOMER_NAME}}")
        .build()
    )
    .setAddress(
      CustomerCreateParams.Address.builder()
        .setCity("Brothers")
        .setCountry("US")
        .setLine1("27 Fredrick Ave")
        .setPostalCode("97712")
        .setState("CA")
        .build()
    )
    .build();

Customer customer = Customer.create(params);
```

```node
const stripe = require('stripe')('<<secret key>>');

const customer = await stripe.customers.create({
  email: '{{CUSTOMER_EMAIL}}',
  name: '{{CUSTOMER_NAME}}',
  shipping: {
    address: {
      city: 'Brothers',
      country: 'US',
      line1: '27 Fredrick Ave',
      postal_code: '97712',
      state: 'CA',
    },
    name: '{{CUSTOMER_NAME}}',
  },
  address: {
    city: 'Brothers',
    country: 'US',
    line1: '27 Fredrick Ave',
    postal_code: '97712',
    state: 'CA',
  },
});
```

```python
import stripe
stripe.api_key = "<<secret key>>"

customer = stripe.Customer.create(
  email="{{CUSTOMER_EMAIL}}",
  name="{{CUSTOMER_NAME}}",
  shipping={
    "address": {
      "city": "Brothers",
      "country": "US",
      "line1": "27 Fredrick Ave",
      "postal_code": "97712",
      "state": "CA",
    },
    "name": "{{CUSTOMER_NAME}}",
  },
  address={
    "city": "Brothers",
    "country": "US",
    "line1": "27 Fredrick Ave",
    "postal_code": "97712",
    "state": "CA",
  },
)
```

```php
$stripe = new \Stripe\StripeClient('<<secret key>>');

$customer = $stripe->customers->create([
  'email' => '{{CUSTOMER_EMAIL}}',
  'name' => '{{CUSTOMER_NAME}}',
  'shipping' => [
    'address' => [
      'city' => 'Brothers',
      'country' => 'US',
      'line1' => '27 Fredrick Ave',
      'postal_code' => '97712',
      'state' => 'CA',
    ],
    'name' => '{{CUSTOMER_NAME}}',
  ],
  'address' => [
    'city' => 'Brothers',
    'country' => 'US',
    'line1' => '27 Fredrick Ave',
    'postal_code' => '97712',
    'state' => 'CA',
  ],
]);
```

```ruby
Stripe.api_key = '<<secret key>>'

customer = Stripe::Customer.create({
  email: '{{CUSTOMER_EMAIL}}',
  name: '{{CUSTOMER_NAME}}',
  shipping: {
    address: {
      city: 'Brothers',
      country: 'US',
      line1: '27 Fredrick Ave',
      postal_code: '97712',
      state: 'CA',
    },
    name: '{{CUSTOMER_NAME}}',
  },
  address: {
    city: 'Brothers',
    country: 'US',
    line1: '27 Fredrick Ave',
    postal_code: '97712',
    state: 'CA',
  },
})
```

## Create the subscription

If you want to render the Payment Element without first creating a subscription, see [Collect payment details before creating an Intent](https://docs.stripe.com/payments/accept-a-payment-deferred.md?type=subscription).

Let your new customer choose a plan and then create the subscription—in this guide, they choose between Basic and Premium.

In your app, pass the selected price ID and the ID of the customer record to the backend.

On the backend, create the subscription with status `incomplete` using `payment_behavior=default_incomplete`. Then return the `client_secret` from the subscription’s first [payment intent](https://docs.stripe.com/payments/payment-intents.md) to the frontend to complete payment by expanding the[`confirmation_secret`](https://docs.stripe.com/api/invoices/object.md#invoice_object-confirmation_secret) on the latest invoice of the subscription.

Set [save_default_payment_method](https://docs.stripe.com/api/subscriptions/object.md#subscription_object-payment_settings-save_default_payment_method) to `on_subscription` to save the payment method as the default for a subscription when a payment succeeds. Saving a default payment method increases the success rate of future subscription payments.

```ruby
<<setup key>>

post '/create-subscription' do
  content_type 'application/json'
  data = JSON.parse(request.body.read)
  customer_id = cookies[:customer]
  price_id = data['priceId']

  # Create the subscription. Note we're expanding the Subscription's
  # latest invoice and that invoice's confirmation_secret
  # so we can pass it to the front end to confirm the payment
  subscription = Stripe::Subscription.create(
    customer: customer_id,
    items: [{
      price: price_id,
    }],
    payment_behavior: 'default_incomplete',
    payment_settings: {save_default_payment_method: 'on_subscription'},
    expand: ['latest_invoice.confirmation_secret']
  )

  { subscriptionId: subscription.id, clientSecret: subscription.latest_invoice.confirmation_secret.client_secret }.to_json
end
```

```python
<<setup key>>

@app.route('/create-subscription', methods=['POST'])
def create_subscription():
    data = json.loads(request.data)
    customer_id = data['customerId']
    price_id = data['priceId']

    try:
        # Create the subscription. Note we're expanding the Subscription's
        # latest invoice and that invoice's confirmation_secret
        # so we can pass it to the front end to confirm the payment
        subscription = stripe.Subscription.create(
            customer=customer_id,
            items=[{
                'price': price_id,
            }],
            payment_behavior='default_incomplete',
            payment_settings={'save_default_payment_method': 'on_subscription'},
            expand=['latest_invoice.confirmation_secret'],
        )
        return jsonify(subscriptionId=subscription.id, clientSecret=subscription.latest_invoice.confirmation_secret.client_secret)

    except Exception as e:
        return jsonify(error={'message': e.user_message}), 400
```

```php
<<setup key>>

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    // Get the request body and decode it as JSON.
    $body = file_get_contents('php://input');
    $json = json_decode($body);

    // Get the customer ID from the cookie and the price ID from the JSON data.
    $customer_id = $_COOKIE['customer'];
    $price_id = $json->priceId;

    // Create the subscription with the customer ID, price ID, and necessary options.
    $subscription = $stripe->subscriptions->create([
        'customer' => $customer_id,
        'items' => [[
            'price' => $price_id,
        ]],
        'payment_behavior' => 'default_incomplete',
        'payment_settings' => ['save_default_payment_method' => 'on_subscription'],
        'expand' => ['latest_invoice.confirmation_secret'],
    ]);

    // Return the subscription ID and client secret as a JSON response.
    header('Content-Type: application/json');
    echo json_encode([
        'subscriptionId' => $subscription->id,
        'clientSecret' => $subscription->latest_invoice->confirmation_secret->client_secret,
    ]);
}
```

```java
<<setup key>>

post(
  "/create-subscription",
  (request, response) -> {
    response.type("application/json");
    String customerId = request.cookie("customer");
    CreateSubscriptionRequest postBody = gson.fromJson(
      request.body(),
      CreateSubscriptionRequest.class
    );
    String priceId = postBody.getPriceId();

    // Automatically save the payment method to the subscription
    // when the first payment is successful.
    SubscriptionCreateParams.PaymentSettings paymentSettings =
      SubscriptionCreateParams.PaymentSettings
        .builder()
        .setSaveDefaultPaymentMethod(SaveDefaultPaymentMethod.ON_SUBSCRIPTION)
        .build();

    // Create the subscription. Note we're expanding the Subscription's
    // latest invoice and that invoice's confirmation_secret
    // so we can pass it to the front end to confirm the payment
    SubscriptionCreateParams subCreateParams = SubscriptionCreateParams
      .builder()
      .setCustomer(customerId)
      .addItem(
        SubscriptionCreateParams
          .Item.builder()
          .setPrice(priceId)
          .build()
      )
      .setPaymentSettings(paymentSettings)
      .setPaymentBehavior(SubscriptionCreateParams.PaymentBehavior.DEFAULT_INCOMPLETE)
      .addAllExpand(Arrays.asList("latest_invoice.confirmation_secret"))
      .build();

    Subscription subscription = Subscription.create(subCreateParams);

    Map<String, Object> responseData = new HashMap<>();
    responseData.put("subscriptionId", subscription.getId());
    responseData.put("clientSecret", subscription.getLatestInvoiceObject().getConfirmationSecret().getClientSecret());
    return StripeObject.PRETTY_PRINT_GSON.toJson(responseData);
  }
);
```

```javascript
<<setup key>>

app.post('/create-subscription', async (req, res) => {
  const customerId = req.cookies['customer'];
  const priceId = req.body.priceId;

  try {
    // Create the subscription. Note we're expanding the Subscription's
    // latest invoice and that invoice's confirmation_secret
    // so we can pass it to the front end to confirm the payment
    const subscription = await stripe.subscriptions.create({
      customer: customerId,
      items: [{
        price: priceId,
      }],
      payment_behavior: 'default_incomplete',
      payment_settings: { save_default_payment_method: 'on_subscription' },
      expand: ['latest_invoice.confirmation_secret'],
    });

    res.send({
      subscriptionId: subscription.id,
      clientSecret: subscription.latest_invoice.confirmation_secret.client_secret,
    });
  } catch (error) {
    return res.status(400).send({ error: { message: error.message } });
  }
});
```

```go
<<setup key>>

func handleCreateSubscription(w http.ResponseWriter, r *http.Request) {
    if r.Method != "POST" {
        http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
        return
    }

    var req struct {
        PriceID string `json:"priceId"`
    }

    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        writeJSON(w, nil, err)
        log.Printf("json.NewDecoder.Decode: %v", err)
        return
    }

    cookie, _ := r.Cookie("customer")
    customerID := cookie.Value

    // Automatically save the payment method to the subscription
    // when the first payment is successful.
    paymentSettings := &stripe.SubscriptionPaymentSettingsParams{
		    SaveDefaultPaymentMethod: stripe.String("on_subscription"),
  	}

    // Create the subscription. Note we're expanding the Subscription's
    // latest invoice and that invoice's confirmation_secret
    // so we can pass it to the front end to confirm the payment
    subscriptionParams := &stripe.SubscriptionParams{
        Customer: stripe.String(customerID),
        Items: []*stripe.SubscriptionItemsParams{
            {
                Price: stripe.String(req.PriceID),
            },
        },
        PaymentSettings: paymentSettings,
        PaymentBehavior: stripe.String("default_incomplete"),
    }
    subscriptionParams.AddExpand("latest_invoice.confirmation_secret")
    s, err := subscription.New(subscriptionParams)

    if err != nil {
        writeJSON(w, nil, err)
        log.Printf("subscription.New: %v", err)
        return
    }

    writeJSON(w, struct {
        SubscriptionID string `json:"subscriptionId"`
        ClientSecret string `json:"clientSecret"`
    }{
        SubscriptionID: s.ID,
        ClientSecret: s.LatestInvoice.ConfirmationSecret.ClientSecret,
    }, nil)
}
```

```dotnet
<<setup key>>

[HttpPost("create-subscription")]
public ActionResult<SubscriptionCreateResponse> CreateSubscription([FromBody] CreateSubscriptionRequest req)
{
    var customerId = HttpContext.Request.Cookies["customer"];

    // Automatically save the payment method to the subscription
    // when the first payment is successful.
    var paymentSettings = new SubscriptionPaymentSettingsOptions {
        SaveDefaultPaymentMethod = "on_subscription",
    };

    // Create the subscription. Note we're expanding the Subscription's
    // latest invoice and that invoice's confirmation_secret
    // so we can pass it to the front end to confirm the payment
    var subscriptionOptions = new SubscriptionCreateOptions
    {
        Customer = customerId,
        Items = new List<SubscriptionItemOptions>
        {
            new SubscriptionItemOptions
            {
                Price = req.PriceId,
            },
        },
        PaymentSettings = paymentSettings,
        PaymentBehavior = "default_incomplete",
    };
    subscriptionOptions.AddExpand("latest_invoice.confirmation_secret");
    var subscriptionService = new SubscriptionService();
    try
    {
        Subscription subscription = subscriptionService.Create(subscriptionOptions);

        return new SubscriptionCreateResponse
        {
          SubscriptionId = subscription.Id,
          ClientSecret = subscription.LatestInvoice.ConfirmationSecret.ClientSecret,
        };
    }
    catch (StripeException e)
    {
        Console.WriteLine($"Failed to create subscription.{e}");
        return BadRequest();
    }
}
```

If you’re using a *multi-currency Price*, use the [currency](https://docs.stripe.com/api/subscriptions/create.md#create_subscription-currency) parameter to tell the Subscription which of the Price’s currencies to use. (If you omit the `currency` parameter, then the Subscription uses the Price’s default currency.)

At this point the Subscription is `inactive` and awaiting payment. Here’s an example response. The minimum fields to store are highlighted, but store whatever your application frequently accesses.

```json
{
  "id": "sub_JgRjFjhKbtD2qz",
  "object": "subscription",
  "application_fee_percent": null,
  "automatic_tax": {
    "disabled_reason": null,
    "enabled": false,
    "liability": "null"
  },
  "billing_cycle_anchor": 1623873347,
  "billing_cycle_anchor_config": null,
  "cancel_at": null,
  "cancel_at_period_end": false,
  "canceled_at": null,
  "cancellation_details": {
    comment: null,
    feedback: null,
    reason: null
  },
  "collection_method": "charge_automatically",
  "created": 1623873347,
  "currency": "usd
  "customer": "cus_CMqDWO2xODTZqt",
  "days_until_due": null,
  "default_payment_method": null,
  "default_source": null,
  "default_tax_rates": [

  ],
  "discounts": [],
  "ended_at": null,
  "invoice_customer_balance_settings": {
    "account_tax_ids": null,
    issuer: {
      type: "self"
    }
  },
  "items": {
    "object": "list",
    "data": [
      {
        "id": "si_JgRjmS4Ur1khEx",
        "object": "subscription_item",
        "created": 1623873347,
        "current_period_end": 1626465347,
        "current_period_start": 1623873347,
        discounts: [],
        "metadata": {
        },
        "plan": {
          "id": "price_1J32RfGPZ1iASj5zHHp57z7C",
          "object": "plan",
          "active": true,
          "amount": 2000,
          "amount_decimal": "2000",
          "billing_scheme": "per_unit",
          "created": 1623864151,
          "currency": "usd",
          "interval": "month",
          "interval_count": 1,
          "livemode": false,
          "metadata": {
          },
          "nickname": null,
          "product": "prod_JgPF5xnq7qBun3",
          "tiers": null,
          "tiers_mode": null,
          "transform_usage": null,
          "trial_period_days": null,
          "usage_type": "licensed"
        },
        "price": {
          "id": "price_1J32RfGPZ1iASj5zHHp57z7C",
          "object": "price",
          "active": true,
          "billing_scheme": "per_unit",
          "created": 1623864151,
          "currency": "usd",
          "livemode": false,
          "lookup_key": null,
          "metadata": {
          },
          "nickname": null,
          "product": "prod_JgPF5xnq7qBun3",
          "recurring": {
            "interval": "month",
            "interval_count": 1,
            "trial_period_days": null,
            "usage_type": "licensed"
          },
          "tiers_mode": null,
          "transform_quantity": null,
          "type": "recurring",
          "unit_amount": 2000,
          "unit_amount_decimal": "2000"
        },
        "quantity": 1,
        "subscription": "sub_JgRjFjhKbtD2qz",
        "tax_rates": [

        ]
      }
    ],
    "has_more": false,
    "total_count": 1,
    "url": "/v1/subscription_items?subscription=sub_JgRjFjhKbtD2qz"
  },
  "latest_invoice": {
    "id": "in_1J34pzGPZ1iASj5zB87qdBNZ",
    "object": "invoice",
    "account_country": "US",
    "account_name": "Angelina's Store",
    "account_tax_ids": null,
    "amount_due": 2000,
    "amount_overpaid": 0,
    "amount_paid": 0,
    "amount_remaining": 2000,
    "amount_shipping": 0,
    "attempt_count": 0,
    "attempted": false,
    "auto_advance": false,
    "automatic_tax": {
      "disabled_reason": null,
      "enabled": false,
      liability: null,
      "status": null
    },
    "automatically_finalizes_at": null,
    "billing_reason": "subscription_update",
    "collection_method": "charge_automatically",
    "created": 1623873347,
    "currency": "usd",
    "custom_fields": null,
    "customer": "cus_CMqDWO2xODTZqt",
    "customer_address": null,
    "customer_email": "angelina@stripe.com",
    "customer_name": null,
    "customer_phone": null,
    "customer_shipping": {
      "address": {
        "city": "",
        "country": "US",
        "line1": "Berry",
        "line2": "",
        "postal_code": "",
        "state": ""
      },
      "name": "",
      "phone": null
    },
    "customer_tax_exempt": "none",
    "customer_tax_ids": [

    ],
    "default_payment_method": null,
    "default_source": null,
    "default_tax_rates": [

    ],
    "description": null,
    "discounts": [],
    "due_date": null,
    "effective_at": "1623873347
    "ending_balance": 0,
    "footer": null,
    "from_invoice": null,
    "hosted_invoice_url": "https://invoice.stripe.com/i/acct_1By64KGPZ1iASj5z/invst_JgRjzIOILGeq2MKC9T0KtyXnD5udsLp",
    "invoice_pdf": "https://pay.stripe.com/invoice/acct_1By64KGPZ1iASj5z/invst_JgRjzIOILGeq2MKC9T0KtyXnD5udsLp/pdf",
    "last_finalization_error": null,
    "latest_revision": null,
    "lines": {
      "object": "list",
      "data": [
        {
          "id": "il_1N2CjMBwKQ696a5NeOawRQP2",
          "object": "line_item",
          "amount": 2000,
          "currency": "usd",
          "description": "1 × Gold Special (at $20.00 / month)",
          "discount_amounts": [

          ],
          "discountable": true,
          "discounts": [

          ],
          "invoice": "in_1J34pzGPZ1iASj5zB87qdBNZ",
          "livemode": false,
          "metadata": {
          },
          "parent": {
            "invoice_item_details": null,
            "subscription_item_details":
            {
              "invoice_item": null
            "proration": false
            "proration_details":
            {
              "credited_items": null
            }
            subscription:
            "sub_JgRjFjhKbtD2qz"
            subscription_item:
              "si_JgRjmS4Ur1khEx"
            }
            type: "subscription_item_details"
          },
          "period": {
            "end": 1626465347,
            "start": 1623873347
          },
          "plan": {
            "id": "price_1J32RfGPZ1iASj5zHHp57z7C",
            "object": "plan",
            "active": true,
            "amount": 2000,
            "amount_decimal": "2000",
            "billing_scheme": "per_unit",
            "created": 1623864151,
            "currency": "usd",
            "interval": "month",
            "interval_count": 1,
            "livemode": false,
            "metadata": {
            },
            "nickname": null,
            "product": "prod_JgPF5xnq7qBun3",
            "tiers": null,
            "tiers_mode": null,
            "transform_usage": null,
            "trial_period_days": null,
            "usage_type": "licensed"
          },
          "price": {
            "id": "price_1J32RfGPZ1iASj5zHHp57z7C",
            "object": "price",
            "active": true,
            "billing_scheme": "per_unit",
            "created": 1623864151,
            "currency": "usd",
            "livemode": false,
            "lookup_key": null,
            "metadata": {
            },
            "nickname": null,
            "product": "prod_JgPF5xnq7qBun3",
            "recurring": {
              "interval": "month",
              "interval_count": 1,
              "trial_period_days": null,
              "usage_type": "licensed"
            },
            "tiers_mode": null,
            "transform_quantity": null,
            "type": "recurring",
            "unit_amount": 2000,
            "unit_amount_decimal": "2000"
          },
          "quantity": 1,
          "taxes": [],
        }
      ],
      "has_more": false,
      "total_count": 1,
      "url": "/v1/invoices/in_1J34pzGPZ1iASj5zB87qdBNZ/lines"
    },
    "livemode": false,
    "metadata": {
    },
    "next_payment_attempt": null,
    "number": "C008FC2-0354",
    "on_behalf_of": null,
    "parent": {
      "quote_details": null,
      "subscription_details": {
        "metadata": {},
        "pause_collection": null,
        "subscription": "sub_JgRjFjhKbtD2qz",
      }
    }
    "payment_intent": {
      "id": "pi_1J34pzGPZ1iASj5zI2nOAaE6",
      "object": "payment_intent",
      "allowed_source_types": [
        "card"
      ],
      "amount": 2000,
      "amount_capturable": 0,
      "amount_received": 0,
      "application": null,
      "application_fee_amount": null,
      "canceled_at": null,
      "cancellation_reason": null,
      "capture_method": "automatic",
      "charges": {
        "object": "list",
        "data": [

        ],
        "has_more": false,
        "total_count": 0,
        "url": "/v1/charges?payment_intent=pi_1J34pzGPZ1iASj5zI2nOAaE6"
      },
      "client_secret": "pi_1J34pzGPZ1iASj5zI2nOAaE6_secret_l7FN6ldFfXiFmJEumenJ2y2wu",
      "confirmation_method": "automatic",
      "created": 1623873347,
      "currency": "usd",
      "customer": "cus_CMqDWO2xODTZqt",
      "description": "Subscription creation",
      "invoice": "in_1J34pzGPZ1iASj5zB87qdBNZ",
      "last_payment_error": null,
      "livemode": false,
      "metadata": {
      },
      "next_action": null,
      "next_source_action": null,
      "on_behalf_of": null,
      "payment_method": null,
      "payment_method_options": {
        "card": {
          "installments": null,
          "network": null,
          "request_three_d_secure": "automatic"
        }
      },
      "payment_method_types": [
        "card"
      ],
      "receipt_email": null,
      "review": null,
      "setup_future_usage": "off_session",
      "shipping": null,
      "source": "card_1By6iQGPZ1iASj5z7ijKBnXJ",
      "statement_descriptor": null,
      "statement_descriptor_suffix": null,
      "status": "requires_confirmation",
      "transfer_data": null,
      "transfer_group": null
    },
    "payment_settings": {
      "payment_method_options": null,
      "payment_method_types": null,
      "save_default_payment_method": "on_subscription"
    },
    "period_end": 1623873347,
    "period_start": 1623873347,
    "post_payment_credit_notes_amount": 0,
    "pre_payment_credit_notes_amount": 0,
    "receipt_number": null,
    "starting_balance": 0,
    "statement_descriptor": null,
    "status": "open",
    "status_transitions": {
      "finalized_at": 1623873347,
      "marked_uncollectible_at": null,
      "paid_at": null,
      "voided_at": null
    },
    "subscription": "sub_JgRjFjhKbtD2qz",
    "subtotal": 2000,
    "tax": null,
    "tax_percent": null,
    "total": 2000,
    "total_discount_amounts": [],
    "total_tax_amounts": [],
    "transfer_data": null,
    "webhooks_delivered_at": 1623873347
  },
  "livemode": false,
  "metadata": {
  },
  "next_pending_invoice_item_invoice": null,
  "pause_collection": null,
  "pending_invoice_item_interval": null,
  "pending_setup_intent": null,
  "pending_update": null,
  "plan": {
    "id": "price_1J32RfGPZ1iASj5zHHp57z7C",
    "object": "plan",
    "active": true,
    "amount": 2000,
    "amount_decimal": "2000",
    "billing_scheme": "per_unit",
    "created": 1623864151,
    "currency": "usd",
    "interval": "month",
    "interval_count": 1,
    "livemode": false,
    "metadata": {
    },
    "nickname": null,
    "product": "prod_JgPF5xnq7qBun3",
    "tiers": null,
    "tiers_mode": null,
    "transform_usage": null,
    "trial_period_days": null,
    "usage_type": "licensed"
  },
  "quantity": 1,
  "schedule": null,
  "start": 1623873347,
  "start_date": 1623873347,
  "status": "incomplete",
  "tax_percent": null,
  "transfer_data": null,
  "trial_end": null,
  "trial_start": null
}
```

## Collect payment information

Use the [Mobile Payment Element](https://docs.stripe.com/payments/elements/mobile-payment-element.md) to collect payment details and activate the subscription. You can customize Elements to match the look and feel of your application.

The Mobile Payment Element securely collects all necessary payment details for a wide variety of payments methods. Learn about the [supported payment methods](https://docs.stripe.com/payments/payment-methods/payment-method-support.md#product-support) for Mobile Payment Element and Subscriptions.

### Add the Payment Element to your app

This step shows one way to get started, but you can use any [in-app payments integration](https://docs.stripe.com/payments/mobile/integration.md).

Initialize and present the Mobile Payment Element using the PaymentSheet class.

The Mobile Payment Element renders a sheet that allows your customer to select a payment method. The form automatically collects all necessary payments details for the payment method that they select.

Setting `allowsDelayedPaymentMethods` to true allows [delayed notification](https://docs.stripe.com/payments/payment-methods.md#payment-notification) payment methods like US bank accounts. For these payment methods, the final payment status isn’t known when the `PaymentSheet` completes, and instead succeeds or fails later. If you support these types of payment methods, inform the customer their order is confirmed and only fulfill their order (for example, ship their product) when the payment is successful.

You can customize the Payment Element to match the design of your app by using the [`appearance` property](https://docs.stripe.com/elements/appearance-api.md?platform=ios) your `PaymentSheet.Configuration` object.

### Confirm payment 

The Mobile Payment Element creates a PaymentMethod and confirms the incomplete Subscription’s first PaymentIntent, causing a charge to be made. If *Strong Customer Authentication* (SCA) is required for the payment, the Payment Element handles the authentication process before confirming the PaymentIntent.

## Listen for webhooks

To complete the integration, you need to process *webhooks* sent by Stripe. These are events triggered whenever state inside of Stripe changes, such as subscriptions creating new invoices. In your application, set up an HTTP handler to accept a POST request containing the webhook event, and verify the signature of the event:

```ruby
<<setup key>>

post '/webhook' do
  # You can use webhooks to receive information about asynchronous payment events.
  # For more about our webhook events check out https://stripe.com/docs/webhooks.
  webhook_secret = ENV['STRIPE_WEBHOOK_SECRET']
  payload = request.body.read
  if !webhook_secret.empty?
    # Retrieve the event by verifying the signature using the raw body and secret if webhook signing is configured.
    sig_header = request.env['HTTP_STRIPE_SIGNATURE']
    event = nil

    begin
      event = Stripe::Webhook.construct_event(
        payload, sig_header, webhook_secret
      )
    rescue JSON::ParserError => e
      # Invalid payload
      status 400
      return
    rescue Stripe::SignatureVerificationError => e
      # Invalid signature
      puts '⚠️  Webhook signature verification failed.'
      status 400
      return
    end
  else
    data = JSON.parse(payload, symbolize_names: true)
    event = Stripe::Event.construct_from(data)
  end
  # Get the type of webhook event sent - used to check the status of PaymentIntents.
  event_type = event['type']
  data = event['data']
  data_object = data['object']

  if event_type == 'invoice.paid'
    # Used to provision services after the trial has ended.
    # The status of the invoice will show up as paid. Store the status in your
    # database to reference when a user accesses your service to avoid hitting rate
    # limits.
    # puts data_object
  end

  if event_type == 'invoice.payment_failed'
    # If the payment fails or the customer does not have a valid payment method,
    # an invoice.payment_failed event is sent, the subscription becomes past_due.
    # Use this webhook to notify your user that their payment has
    # failed and to retrieve new card details.
    # puts data_object
  end

  if event_type == 'customer.subscription.deleted'
    # handle subscription canceled automatically based
    # upon your subscription settings. Or if the user cancels it.
    # puts data_object
  end

  content_type 'application/json'
  { status: 'success' }.to_json
end
```

```python
<<setup key>>

@app.route('/webhook', methods=['POST'])
def webhook_received():
  # You can use webhooks to receive information about asynchronous payment events.
  # For more about our webhook events check out https://stripe.com/docs/webhooks.
  webhook_secret = os.getenv('STRIPE_WEBHOOK_SECRET')
  request_data = json.loads(request.data)

  if webhook_secret:
    # Retrieve the event by verifying the signature using the raw body and secret if webhook signing is configured.
    signature = request.headers.get('stripe-signature')
    try:
      event = stripe.Webhook.construct_event(
        payload=request.data, sig_header=signature, secret=webhook_secret)
      data = event['data']
    except Exception as e:
      return e
    # Get the type of webhook event sent - used to check the status of PaymentIntents.
    event_type = event['type']
  else:
    data = request_data['data']
    event_type = request_data['type']

  data_object = data['object']

  if event_type == 'invoice.paid':
    # Used to provision services after the trial has ended.
    # The status of the invoice will show up as paid. Store the status in your
    # database to reference when a user accesses your service to avoid hitting rate
    # limits.
    print(data)

  if event_type == 'invoice.payment_failed':
    # If the payment fails or the customer does not have a valid payment method,
    # an invoice.payment_failed event is sent, the subscription becomes past_due.
    # Use this webhook to notify your user that their payment has
    # failed and to retrieve new card details.
    print(data)

  if event_type == 'customer.subscription.deleted':
    # handle subscription canceled automatically based
    # upon your subscription settings. Or if the user cancels it.
    print(data)

  return jsonify({'status': 'success'})
```

```php
<<setup key>>

$event = null;
$payload = @file_get_contents('php://input');
$sig_header = $_SERVER['HTTP_STRIPE_SIGNATURE'];
$webhook_secret = '{{STRIPE_WEBHOOK_SECRET}}';
try {
  $event = \Stripe\Webhook::constructEvent(
    $payload, $sig_header, $webhook_secret
  );
} catch(\UnexpectedValueException $e) {
  // Invalid payload
  http_response_code(400);
  exit();
} catch(\Stripe\Exception\SignatureVerificationException $e) {
  // Invalid signature
  http_response_code(400);
  exit();
}

// Handle the event
// Review important events for Billing webhooks
// https://stripe.com/docs/billing/webhooks
// Remove comment to see the various objects sent for this sample
switch ($event->type) {
  case 'invoice.paid':
    // The status of the invoice will show up as paid. Store the status in your
    // database to reference when a user accesses your service to avoid hitting rate
    // limits.
    break;
  case 'invoice.payment_failed':
    // If the payment fails or the customer does not have a valid payment method,
    // an invoice.payment_failed event is sent, the subscription becomes past_due.
    // Use this webhook to notify your user that their payment has
    // failed and to retrieve new card details.
    break;
  case 'customer.subscription.deleted':
    // handle subscription canceled automatically based
    // upon your subscription settings. Or if the user
    // cancels it.
    break;
  // ... handle other event types
  default:
    // Unhandled event type
}

http_response_code(200);
```

```java
<<setup key>>

post(
  "/webhook",
  (request, response) -> {
    String payload = request.body();
    String sigHeader = request.headers("Stripe-Signature");
    String endpointSecret = dotenv.get("STRIPE_WEBHOOK_SECRET");
    Event event = null;

    try {
      event = Webhook.constructEvent(payload, sigHeader, endpointSecret);
    } catch (SignatureVerificationException e) {
      // Invalid signature
      response.status(400);
      return "";
    }

    // Deserialize the nested object inside the event
    EventDataObjectDeserializer dataObjectDeserializer = event.getDataObjectDeserializer();
    StripeObject stripeObject = null;
    if (dataObjectDeserializer.getObject().isPresent()) {
      stripeObject = dataObjectDeserializer.getObject().get();
    } else {
      // Deserialization failed, probably due to an API version mismatch.
      // Refer to the Javadoc documentation on `EventDataObjectDeserializer` for
      // instructions on how to handle this case, or return an error here.
    }

    switch (event.getType()) {
      case "invoice.paid":
        // Used to provision services after the trial has ended.
        // The status of the invoice will show up as paid. Store the status in your
        // database to reference when a user accesses your service to avoid hitting rate
        // limits.
        break;
      case "invoice.payment_failed":
        // If the payment fails or the customer does not have a valid payment method,
        // an invoice.payment_failed event is sent, the subscription becomes past_due.
        // Use this webhook to notify your user that their payment has
        // failed and to retrieve new card details.
        break;
      case "customer.subscription.deleted":
        // handle subscription canceled automatically based
        // upon your subscription settings. Or if the user
        // cancels it.
        break;
      default:
      // Unhandled event type
    }

    response.status(200);
    return "";
  }
);
```

```javascript
<<setup key>>

app.post(
  '/webhook',
  bodyParser.raw({ type: 'application/json' }),
  async (req, res) => {
    // Retrieve the event by verifying the signature using the raw body and secret.
    let event;

    try {
      event = stripe.webhooks.constructEvent(
        req.body,
        req.headers['stripe-signature'],
        process.env.STRIPE_WEBHOOK_SECRET
      );
    } catch (err) {
      console.log(err);
      console.log(`⚠️  Webhook signature verification failed.`);
      console.log(
        `⚠️  Check the env file and enter the correct webhook secret.`
      );
      return res.sendStatus(400);
    }
    // Extract the object from the event.
    const dataObject = event.data.object;

    // Handle the event
    // Review important events for Billing webhooks
    // https://stripe.com/docs/billing/webhooks
    // Remove comment to see the various objects sent for this sample
    switch (event.type) {
      case 'invoice.paid':
        // Used to provision services after the trial has ended.
        // The status of the invoice will show up as paid. Store the status in your
        // database to reference when a user accesses your service to avoid hitting rate limits.
        break;
      case 'invoice.payment_failed':
        // If the payment fails or the customer does not have a valid payment method,
        //  an invoice.payment_failed event is sent, the subscription becomes past_due.
        // Use this webhook to notify your user that their payment has
        // failed and to retrieve new card details.
        break;
      case 'customer.subscription.deleted':
        if (event.request != null) {
          // handle a subscription canceled by your request
          // from above.
        } else {
          // handle subscription canceled automatically based
          // upon your subscription settings.
        }
        break;
      default:
      // Unexpected event type
    }
    res.sendStatus(200);
  }
);
```

```go
<<setup key>>

func handleWebhook(w http.ResponseWriter, r *http.Request) {
  if r.Method != "POST" {
    http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
    return
  }
  b, err := ioutil.ReadAll(r.Body)
  if err != nil {
    http.Error(w, err.Error(), http.StatusBadRequest)
    log.Printf("ioutil.ReadAll: %v", err)
    return
  }

  event, err := webhook.ConstructEvent(b, r.Header.Get("Stripe-Signature"), os.Getenv("STRIPE_WEBHOOK_SECRET"))
  if err != nil {
    http.Error(w, err.Error(), http.StatusBadRequest)
    log.Printf("webhook.ConstructEvent: %v", err)
    return
  }

  if event.Type == "invoice.paid" {
    // Used to provision services after the trial has ended.
    // The status of the invoice will show up as paid. Store the status in your
    // database to reference when a user accesses your service to avoid hitting rate
    // limits.
    return
  }

  if event.Type == "invoice.payment_failed" {
    // If the payment fails or the customer does not have a valid payment method,
    // an invoice.payment_failed event is sent, the subscription becomes past_due.
    // Use this webhook to notify your user that their payment has
    // failed and to retrieve new card details.
    return
  }

  if event.Type == "customer.subscription.deleted" {
    // handle subscription canceled automatically based
    // upon your subscription settings. Or if the user cancels it. {
    return
  }
}
```

```dotnet
<<setup key>>

[HttpPost("webhook")]
public async Task<IActionResult> Webhook()
{
  var json = await new StreamReader(HttpContext.Request.Body).ReadToEndAsync();
  Event stripeEvent;
  try
  {
    stripeEvent = EventUtility.ConstructEvent(
      json,
      Request.Headers["Stripe-Signature"],
      this.options.Value.WebhookSecret
    );
    Console.WriteLine($"Webhook notification with type: {stripeEvent.Type} found for {stripeEvent.Id}");
  }
  catch (Exception e)
  {
    Console.WriteLine($"Something failed {e}");
    return BadRequest();
  }

  if (stripeEvent.Type == "invoice.paid")
  {
    // Used to provision services after the trial has ended.
    // The status of the invoice will show up as paid. Store the status in your
    // database to reference when a user accesses your service to avoid hitting rate
    // limits.
  }

  if (stripeEvent.Type == "invoice.payment_failed")
  {
    // If the payment fails or the customer does not have a valid payment method,
    // an invoice.payment_failed event is sent, the subscription becomes past_due.
    // Use this webhook to notify your user that their payment has
    // failed and to retrieve new card details.
  }

  if (stripeEvent.Type == "customer.subscription.deleted")
  {
    // handle subscription canceled automatically based
    // upon your subscription settings. Or if the user cancels it.
  }
  return Ok();
}
```

During development, use the Stripe CLI to [observe webhooks and forward them to your application](https://docs.stripe.com/webhooks.md#test-webhook). Run the following in a new terminal while your development app is running:

```bash
stripe listen --forward-to localhost:4242/webhook
```

For production, set up a webhook endpoint URL in the Dashboard, or use the [Webhook Endpoints API](https://docs.stripe.com/api/webhook_endpoints.md).

You’ll listen to a couple of events to complete the remaining steps in this guide. See [Subscription events](https://docs.stripe.com/billing/subscriptions/overview.md#subscription-events) for more details about subscription-specific webhooks.

## Provision access to your service

Now that the subscription is active, give your user access to your service.  To do this, listen to the `customer.subscription.created`, `customer.subscription.updated`, and `customer.subscription.deleted` events.  These events pass a subscription object which contains a `status` field indicating whether the subscription is active, past due, or canceled.  See [the subscription lifecycle](https://docs.stripe.com/billing/subscriptions/overview.md#subscription-lifecycle) for a complete list of statuses.

In your webhook handler:

1. Verify the subscription status.  If it’s `active` then your user has paid for your product.
1. Check the product the customer subscribed to and grant access to your service. Checking the product instead of the price gives you more flexibility if you need to change the pricing or billing interval.
1. Store the `product.id`, `subscription.id` and `subscription.status` in your database along with the `customer.id` you already saved.  Check this record when determining which features to enable for the user in your application.

The state of a subscription might change at any point during its lifetime, even if your application does not directly make any calls to Stripe.  For example, a renewal might fail due to an expired credit card, which puts the subscription into a past due state.  Or, if you implement the [customer portal](https://docs.stripe.com/customer-management.md), a user might cancel their subscription without directly visiting your application.  Implementing your handler correctly keeps your application state in sync with Stripe.

## Cancel the subscription

It’s common to allow customers to cancel their subscriptions. This example adds a cancellation option to the account settings page.

The example collects the subscription ID on the frontend, but your application can get this information from your database for your logged in user.

![Sample subscription cancelation interface.](images/billing/subscriptions/fixed-price-subscriptions-guide-account-settings.png)
Account settings with the ability to cancel the subscription


On the backend, define the endpoint for your app to call.

```ruby
<<setup key>>

post '/cancel-subscription' do
  content_type 'application/json'
  data = JSON.parse request.body.read

  deleted_subscription = Stripe::Subscription.cancel(data['subscriptionId'])

  deleted_subscription.to_json
end
```

```python
<<setup key>>

@app.route('/cancel-subscription', methods=['POST'])
def cancelSubscription():
    data = json.loads(request.data)
    try:
         # Cancel the subscription by deleting it
        deletedSubscription = stripe.Subscription.delete(data['subscriptionId'])
        return jsonify(deletedSubscription)
    except Exception as e:
        return jsonify(error=str(e)), 403
```

```php
<<setup key>>

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
  $body = file_get_contents('php://input');
  $json = json_decode($body);

  $subscription = $stripe->subscriptions->retrieve(
    $json->subscriptionId
  );
  $subscription->delete();

  header('Content-Type: application/json');
  echo json_encode([
    'subscription' => $subscription,
  ]);
}
```

```java
<<setup key>>

post(
      "/cancel-subscription",
      (request, response) -> {
        response.type("application/json");
        // Set the default payment method on the customer
        CancelPostBody postBody = gson.fromJson(
          request.body(),
          CancelPostBody.class
        );

        Subscription subscription = Subscription.retrieve(
          postBody.getSubscriptionId()
        );

        Subscription deletedSubscription = subscription.cancel();
        return deletedSubscription.toJson();
      }
    );
```

```javascript
<<setup key>>

app.post('/cancel-subscription', async (req, res) => {
  // Delete the subscription
  const deletedSubscription = await stripe.subscriptions.del(
    req.body.subscriptionId
  );
  res.send(deletedSubscription);
});
```

```go
<<setup key>>

func handleCancelSubscription(w http.ResponseWriter, r *http.Request) {
  if r.Method != "POST" {
    http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
    return
  }
  var req struct {
    SubscriptionID string `json:"subscriptionId"`
  }
  if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("json.NewDecoder.Decode: %v", err)
    return
  }
  s, err := subscription.Cancel(req.SubscriptionID, nil)
  if err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("subscription.Cancel: %v", err)
    return
  }
  writeJSON(w, s)
}
```

```dotnet
using Newtonsoft.Json;

public class CancelSubscriptionRequest
{
    [JsonProperty("subscriptionId")]
    public string Subscription { get; set; }
}
```

```dotnet
<<setup key>>

[HttpPost("cancel-subscription")]
public ActionResult<Subscription> CancelSubscription([FromBody] CancelSubscriptionRequest req)
{
    var service = new SubscriptionService();
    var subscription = service.Cancel(req.Subscription, null);
    return subscription;
}
```

Your backend receives a `customer.subscription.deleted` event.

After the subscription is canceled, update your database to remove the Stripe subscription ID you previously stored, and limit access to your service.

When a subscription is canceled, it can’t be reactivated. Instead, collect updated billing information from your customer, update their default payment method, and create a new subscription with their existing customer record.

## Test your integration

### Test payment methods

Use the following table to test different payment methods and scenarios.

| Payment method    | Scenario                                                                                         | How to test                                                                                                                                                                                                  |
| ----------------- | ------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| BECS Direct Debit | Your customer successfully pays with BECS Direct Debit.                                          | Fill out the form using the account number `900123456` and BSB `000-000`. The confirmed PaymentIntent initially transitions to `processing`, then transitions to the `succeeded` status three minutes later. |
| BECS Direct Debit | Your customer’s payment fails with an `account_closed` error code.                               | Fill out the form using the account number `111111113` and BSB `000-000`.                                                                                                                                    |
| Credit card       | The card payment succeeds and doesn’t require authentication.                                    | Fill out the credit card form using the credit card number `4242 4242 4242 4242` with any expiration, CVC, and postal code.                                                                                  |
| Credit card       | The card payment requires *authentication*.                                                      | Fill out the credit card form using the credit card number `4000 0025 0000 3155` with any expiration, CVC, and postal code.                                                                                  |
| Credit card       | The card is declined with a decline code like `insufficient_funds`.                              | Fill out the credit card form using the credit card number `4000 0000 0000 9995` with any expiration, CVC, and postal code.                                                                                  |
| SEPA Direct Debit | Your customer successfully pays with SEPA Direct Debit.                                          | Fill out the form using the account number `AT321904300235473204`. The confirmed PaymentIntent initially transitions to processing, then transitions to the succeeded status three minutes later.            |
| SEPA Direct Debit | Your customer’s PaymentIntent status transitions from `processing` to `requires_payment_method`. | Fill out the form using the account number `AT861904300235473202`.                                                                                                                                           |

### Monitor events

Set up webhooks to listen to subscription change events, such as upgrades and cancellations. Learn more about [subscription webhooks](https://docs.stripe.com/billing/subscriptions/webhooks.md). You can view events in the [Dashboard](https://dashboard.stripe.com/test/events) or with the [Stripe CLI](https://docs.stripe.com/webhooks.md#test-webhook).

For more details, see [testing your Billing integration](https://docs.stripe.com/billing/testing.md).

## Let customers change their plans

To let your customers change their subscription, collect the price ID of the option they want to change to. Then send the new price ID from the app to a backend endpoint. This example also passes the subscription ID, but you can retrieve it from your database for your logged in user.

On the backend, define the endpoint for your frontend to call, passing the subscription ID and the new price ID. The subscription is now Premium, at 15 USD per month, instead of Basic at 5 USD per month.

```ruby
<<setup key>>

post '/update-subscription' do
  content_type 'application/json'
  data = JSON.parse request.body.read

  subscription = Stripe::Subscription.retrieve(data['subscriptionId'])

  updated_subscription =
    Stripe::Subscription.update(
      data['subscriptionId'],
      cancel_at_period_end: false,
      items: [
        { id: subscription.items.data[0].id, price: 'price_H1NlVtpo6ubk0m' }
      ]
    )

  updated_subscription.to_json
end
```

```python
<<setup key>>

@app.route('/update-subscription', methods=['POST'])
def updateSubscription():
    data = json.loads(request.data)
    try:
        subscription = stripe.Subscription.retrieve(data['subscriptionId'])

        updatedSubscription = stripe.Subscription.modify(
            data['subscriptionId'],
            cancel_at_period_end=False,
            items=[{
                'id': subscription['items']['data'][0].id,
                'price': 'price_H1NlVtpo6ubk0m',
            }]
        )
        return jsonify(updatedSubscription)
    except Exception as e:
        return jsonify(error=str(e)), 403
```

```php
<<setup key>>

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
  $body = file_get_contents('php://input');
  $json = json_decode($body);

  $subscription = $stripe->subscriptions->retrieve($json->subscriptionId);

  $updated_subscription = $stripe->subscriptions->update($json->subscriptionId, [
    'items' => [
      [
        'id' => $subscription->items->data[0]->id,
        'price' => 'price_H1NlVtpo6ubk0m',
      ],
    ],
  ]);

  header('Content-Type: application/json');
  echo json_encode([
    'updatedSubscription' => $updated_subscription,
  ]);
}
```

```java
<<setup key>>

post(
  "/update-subscription",
  (request, response) -> {
    response.type("application/json");
    // Set the default payment method on the customer
    UpdatePostBody postBody = gson.fromJson(
      request.body(),
      UpdatePostBody.class
    );

    Subscription subscription = Subscription.retrieve(
      postBody.getSubscriptionId()
    );

    SubscriptionUpdateParams params = SubscriptionUpdateParams
      .builder()
      .addItem(
        SubscriptionUpdateParams
          .Item.builder()
          .setId(subscription.getItems().getData().get(0).getId())
          .setPrice("price_H1NlVtpo6ubk0m")
          .build()
      )
      .setCancelAtPeriodEnd(false)
      .build();

    subscription.update(params);
    return subscription.toJson();
  }
);
```

```javascript
<<setup key>>

app.post('/update-subscription', async (req, res) => {
  const subscription = await stripe.subscriptions.retrieve(
    req.body.subscriptionId
  );
  const updatedSubscription = await stripe.subscriptions.update(
    req.body.subscriptionId,
    {
      cancel_at_period_end: false,
      items: [
        {
          id: subscription.items.data[0].id,
          price: "price_H1NlVtpo6ubk0m",
        },
      ],
    }
  );

  res.send(updatedSubscription);
});
```

```go
<<setup key>>

func handleUpdateSubscription(w http.ResponseWriter, r *http.Request) {
  if r.Method != "POST" {
    http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
    return
  }

  var req struct {
    SubscriptionID string `json:"subscriptionId"`
    NewPriceID     string `json:"newPriceId"`
  }

  if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("json.NewDecoder.Decode: %v", err)
    return
  }

  s, err := subscription.Get(req.SubscriptionID, nil)
  if err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("subscription.Get: %v", err)
    return
  }

  params := &stripe.SubscriptionParams{
    CancelAtPeriodEnd: stripe.Bool(false),
    Items: []*stripe.SubscriptionItemsParams{{
      ID:    stripe.String(s.Items.Data[0].ID),
      Price: stripe.String("price_H1NlVtpo6ubk0m"),
    }},
  }

  updatedSubscription, err := subscription.Update(req.SubscriptionID, params)

  if err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("subscription.Update: %v", err)
    return
  }

  writeJSON(w, updatedSubscription)
}
```

```dotnet
using Newtonsoft.Json;

public class UpdateSubscriptionRequest
{
    [JsonProperty("subscriptionId")]
    public string Subscription { get; set; }

    [JsonProperty("newPriceId")]
    public string NewPrice { get; set; }
}
```

```dotnet
<<setup key>>

[HttpPost("update-subscription")]
public ActionResult<Subscription> UpdateSubscription([FromBody] UpdateSubscriptionRequest req)
{
    var service = new SubscriptionService();
    var subscription = service.Get(req.Subscription);

    var options = new SubscriptionUpdateOptions
    {
        CancelAtPeriodEnd = false,
        Items = new List<SubscriptionItemOptions>
        {
            new SubscriptionItemOptions
            {
                Id = subscription.Items.Data[0].Id,
                Price = "price_H1NlVtpo6ubk0m",
            }
        }
    };
    var updatedSubscription = service.Update(req.Subscription, options);
    return updatedSubscription;
}
```

Your application receives a `customer.subscription.updated` event.

## Preview a price change

When your customer changes their subscription, there’s often an adjustment to the amount they owe, known as a [proration](https://docs.stripe.com/billing/subscriptions/prorations.md). You can use the [create preview invoice endpoint](https://docs.stripe.com/api/invoices/create_preview.md) to display the adjusted amount to your customers.

From the app, pass the preview invoice details to a backend endpoint.

On the backend, define the endpoint for your frontend to call.

```ruby
<<setup key>>

post '/create-preview-invoice' do
  content_type 'application/json'
  data = JSON.parse request.body.read

  subscription = Stripe::Subscription.retrieve(data['subscriptionId'])

  invoice =
    Stripe::Invoice.create_preview(
      customer: data['customerId'],
      subscription: data['subscriptionId'],
      subscription_details: {
        items: [
          { id: subscription.items.data[0].id, deleted: true },
          { price: ENV[data['newPriceId']], deleted: false }
        ]
      }
    )

  invoice.to_json
end
```

```python
<<setup key>>

@app.route('/create-preview-invoice', methods=['POST'])
def createPreviewInvoice():
    data = json.loads(request.data)
    try:
        # Retrieve the subscription
        subscription = stripe.Subscription.retrieve(data['subscriptionId'])

        # Retrieve the invoice
        invoice = stripe.Invoice.create_preview(
            customer=data['customerId'],
            subscription=data['subscriptionId'],
            subscription_details={
              "items": [
                  {
                      'id': subscription['items']['data'][0].id,
                      'deleted': True,
                  },
                  {
                      'price': 'price_H1NlVtpo6ubk0m',
                      'deleted': False,
                  }
              ]
            }
        )
        return jsonify(invoice)
    except Exception as e:
        return jsonify(error=str(e)), 403
```

```php
<<setup key>>

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
  $body = file_get_contents('php://input');
  $json = json_decode($body);

  $subscription = $stripe->subscriptions->retrieve($json->subscriptionId);

  $invoice = $stripe->invoices->createPreview([
    'customer' => $json->customerId,
    'subscription' => $json->subscriptionId,
    'subscription_details' => [
      'items' => [
        [
          'id' => $subscription->items->data[0]->id,
          'deleted' => true
        ],
        [
          'price' => $json->newPriceId,
          'deleted' => false
        ],
      ],
    ],
  ]);

  header('Content-Type: application/json');
  echo json_encode([
    'invoice' => $invoice,
  ]);
}
```

```java
<<setup key>>

post(
  "/create-preview-invoice",
  (request, response) -> {
    response.type("application/json");
    PreviewInvoicePostBody postBody = gson.fromJson(
      request.body(),
      PreviewInvoicePostBody.class
    );

    Subscription subscription = Subscription.retrieve(
      postBody.getSubscriptionId()
    );

    InvoiceCreatePreviewParams invoiceParams = InvoiceCreatePreviewParams
      .builder()
      .setCustomer(postBody.getCustomerId())
      .setSubscription(postBody.getSubscriptionId())
      .setSubscriptionDetails(
        InvoiceCreatePreviewParams.SubscriptionDetails.builder()
          .addItem(
            InvoiceCreatePreviewParams.SubscriptionDetails.Item.builder()
              .setId(subscription.getItems().getData().get(0).getId())
              .setDeleted(true)
              .build()
          )
          .addItem(
            InvoiceCreatePreviewParams.SubscriptionDetails.Item.builder()
              .setPrice(dotenv.get(postBody.getNewPriceId().toUpperCase()))
              .build()
          )
          .build()
      )
      .build();

    Invoice invoice = Invoice.createPreview(invoiceParams);

    return invoice.toJson();
  }
);
```

```javascript
<<setup key>>

app.post('/create-preview-invoice', async (req, res) => {
  const subscription = await stripe.subscriptions.retrieve(
    req.body.subscriptionId
  );

  const invoice = await stripe.invoices.createPreview({
    customer: req.body.customerId,
    subscription: req.body.subscriptionId,
    subscription_details: {
      items: [
        {
          id: subscription.items.data[0].id,
          deleted: true,
        },
        {
          // This price ID is the price you want to change the subscription to.
          price: 'price_H1NlVtpo6ubk0m',
          deleted: false,
        },
      ],
    }
  });
  res.send(invoice);
});
```

```go
<<setup key>>

func handleCreatePreviewInvoice(w http.ResponseWriter, r *http.Request) {
  if r.Method != "POST" {
    http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
    return
  }
  var req struct {
    SubscriptionID string `json:"subscriptionId"`
    CustomerID     string `json:"customerId"`
    NewPriceID     string `json:"newPriceId"`
  }

  if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("json.NewDecoder.Decode: %v", err)
    return
  }

  s, err := subscription.Get(req.SubscriptionID, nil)
  if err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("subscription.Get: %v", err)
    return
  }
  params := &stripe.InvoiceCreatePreviewParams{
    Customer:     stripe.String(req.CustomerID),
    Subscription: stripe.String(req.SubscriptionID),
    SubscriptionDetails: &stripe.InvoiceCreatePreviewSubscriptionDetailsParams{
      Items: []*stripe.SubscriptionItemsParams{{
        ID:      stripe.String(s.Items.Data[0].ID),
        Deleted: stripe.Bool(true),
      }, {
        Price:   stripe.String(os.Getenv(req.NewPriceID)),
        Deleted: stripe.Bool(false),
      }},
    },
  }
  in, err := invoice.CreatePreview(params)

  if err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("invoice.CreatePreview: %v", err)
    return
  }

  writeJSON(w, in)
}
```

```dotnet
using Newtonsoft.Json;

public class CreatePreviewInvoiceRequest
{
    [JsonProperty("customerId")]
    public string Customer { get; set; }

    [JsonProperty("subscriptionId")]
    public string Subscription { get; set; }

    [JsonProperty("newPriceId")]
    public string NewPrice { get; set; }
}
```

```dotnet
<<setup key>>

[HttpPost("create-preview-invoice")]
public ActionResult<Invoice> CreatePreviewInvoice([FromBody] CreatePreviewInvoiceRequest req)
{
    var service = new SubscriptionService();
    var subscription = service.Get(req.Subscription);

    var invoiceService = new InvoiceService();
    var options = new InvoiceCreatePreviewOptions
    {
        Customer = req.Customer,
        Subscription = req.Subscription,
        SubscriptionDetails = new InvoiceSubscriptionDetailsOptions
        {
            Items = new List<InvoiceSubscriptionItemOptions>
            {
                new InvoiceSubscriptionItemOptions
                {
                    Id = subscription.Items.Data[0].Id,
                    Deleted = true,
                },
                new InvoiceSubscriptionItemOptions
                {
                    Price = Environment.GetEnvironmentVariable(req.NewPrice),
                    Deleted = false,
                },
            },
        },
    };
    Invoice previewInvoice = invoiceService.CreatePreview(options);
    return previewInvoice;
}
```

## Display the customer payment method

Displaying the brand and last four digits of your customer’s card can help them know which card is being charged, or if they need to update their payment method.

On the front end, send the payment method ID to a back-end endpoint that retrieves the payment method details.

On the back end, define the endpoint for your app to call.

```ruby
<<setup key>>

post '/retrieve-customer-payment-method' do
  content_type 'application/json'
  data = JSON.parse request.body.read

  payment_method = Stripe::PaymentMethod.retrieve(data['paymentMethodId'])

  payment_method.to_json
end
```

```python
<<setup key>>

@app.route('/retrieve-customer-payment-method', methods=['POST'])
def retrieveCustomerPaymentMethod():
    data = json.loads(request.data)
    try:
        paymentMethod = stripe.PaymentMethod.retrieve(
            data['paymentMethodId'],
        )
        return jsonify(paymentMethod)
    except Exception as e:
        return jsonify(error=str(e)), 403
```

```php
<<setup key>>

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
  $body = file_get_contents('php://input');
  $json = json_decode($body);

  $payment_method = $stripe->paymentMethods->retrieve($json->paymentMethodId);

  header('Content-Type: application/json');
  echo json_encode([
    'paymentMethod' => $payment_method,
  ]);
}
```

```java
<<setup key>>

post(
  "/retrieve-customer-payment-method",
  (request, response) -> {
    response.type("application/json");
    // Set the default payment method on the customer
    PaymentMethodBody paymentMethodBody = gson.fromJson(
      request.body(),
      PaymentMethodBody.class
    );

    PaymentMethod paymentMethod = PaymentMethod.retrieve(
      paymentMethodBody.getPaymentMethodId()
    );
    return paymentMethod.toJson();
  }
);
```

```javascript
<<setup key>>

app.post('/retrieve-customer-payment-method', async (req, res) => {
  const paymentMethod = await stripe.paymentMethods.retrieve(
    req.body.paymentMethodId
  );

  res.send(paymentMethod);
});
```

```go
<<setup key>>

func handleRetrieveCustomerPaymentMethod(w http.ResponseWriter, r *http.Request) {
  if r.Method != "POST" {
    http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
    return
  }
  var req struct {
    PaymentMethodID string `json:"paymentMethodId"`
  }
  if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("json.NewDecoder.Decode: %v", err)
    return
  }

  pm, err := paymentmethod.Get(req.PaymentMethodID, nil)
  if err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    log.Printf("paymentmethod.Get: %v", err)
    return
  }

  writeJSON(w, pm)
}
```

```dotnet
using Newtonsoft.Json;

public class RetrieveCustomerPaymentMethodRequest
{
    [JsonProperty("paymentMethodId")]
    public string PaymentMethod { get; set; }
}
```

```dotnet
<<setup key>>

[HttpPost("retrieve-customer-payment-method")]
public ActionResult<PaymentMethod> RetrieveCustomerPaymentMethod([FromBody] RetrieveCustomerPaymentMethodRequest req)
{
    var service = new PaymentMethodService();
    var paymentMethod = service.Get(req.PaymentMethod);
    return paymentMethod;
}
```

Example response:

```json
{
  "id": "pm_1GcbHY2eZvKYlo2CoqlVxo42",
  "object": "payment_method",
  "billing_details": {
    "address": {
      "city": null,
      "country": null,
      "line1": null,
      "line2": null,
      "postal_code": null,
      "state": null
    },
    "email": null,
    "name": null,
    "phone": null
  },
  "card": {
    "brand": "visa",
    "checks": {
      "address_line1_check": null,
      "address_postal_code_check": null,
      "cvc_check": "pass"
    },
    "country": "US",
    "exp_month": 8,
    "exp_year": 2021,
    "fingerprint": "Xt5EWLLDS7FJjR1c",
    "funding": "credit",
    "generated_from": null,
    "last4": "4242",
    "three_d_secure_usage": {
      "supported": true
    },
    "wallet": null
  },
  "created": 1588010536,
  "customer": "cus_HAxB7dVQxhoKLh",
  "livemode": false,
  "metadata": {},
  "type": "card"
}
```

We recommend that you save the `paymentMethod.id` and `last4` in your database, for example, `paymentMethod.id` as `stripeCustomerPaymentMethodId` in your `users` collection or table. You can optionally store `exp_month`, `exp_year`, `fingerprint`, `billing_details` as needed. This is to limit the number of calls you make to Stripe—for both performance efficiency and to avoid possible rate limiting.

## Disclose Stripe to your customers 

Stripe collects information on customer interactions with Elements to provide services to you, prevent fraud, and improve its services. This includes using cookies and IP addresses to identify which Elements a customer saw during a single checkout session. You’re responsible for disclosing and obtaining all rights and consents necessary for Stripe to use data in these ways. For more information, visit our [privacy center](https://stripe.com/legal/privacy-center#as-a-business-user-what-notice-do-i-provide-to-my-end-customers-about-stripe).
